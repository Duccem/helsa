"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@ably";
exports.ids = ["vendor-chunks/@ably"];
exports.modules = {

/***/ "(ssr)/../../../node_modules/@ably/chat/dist/chat/ably-chat.js":
/*!***************************************************************!*\
  !*** ../../../node_modules/@ably/chat/dist/chat/ably-chat.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ChatClient: () => (/* binding */ Pr),\n/* harmony export */   ChatEntityType: () => (/* binding */ Ir),\n/* harmony export */   ConnectionLifecycle: () => (/* binding */ Kn),\n/* harmony export */   ErrorCodes: () => (/* binding */ m),\n/* harmony export */   LogLevel: () => (/* binding */ ot),\n/* harmony export */   MessageEvents: () => (/* binding */ L),\n/* harmony export */   PresenceEvents: () => (/* binding */ nr),\n/* harmony export */   RoomLifecycle: () => (/* binding */ d),\n/* harmony export */   RoomOptionsDefaults: () => (/* binding */ Cr),\n/* harmony export */   chatMessageFromAblyMessage: () => (/* binding */ Mr),\n/* harmony export */   chatMessageFromEncoded: () => (/* binding */ Or),\n/* harmony export */   errorInfoIs: () => (/* binding */ Dr),\n/* harmony export */   getEntityTypeFromAblyMessage: () => (/* binding */ Sr),\n/* harmony export */   getEntityTypeFromEncoded: () => (/* binding */ xr),\n/* harmony export */   reactionFromAblyMessage: () => (/* binding */ Tr),\n/* harmony export */   reactionFromEncoded: () => (/* binding */ Fr)\n/* harmony export */ });\n/* harmony import */ var ably__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ably */ \"(ssr)/../../../node_modules/ably/build/ably-node.js\");\n\nvar ot = /* @__PURE__ */ ((i) => (i.Trace = \"trace\", i.Debug = \"debug\", i.Info = \"info\", i.Warn = \"warn\", i.Error = \"error\", i.Silent = \"silent\", i))(ot || {});\nconst zn = (i, e, t) => {\n  const r = t ? `, context: ${JSON.stringify(t)}` : \"\", s = `[${(/* @__PURE__ */ new Date()).toISOString()}] ${e.valueOf().toUpperCase()} ably-chat: ${i}${r}`;\n  switch (e) {\n    case \"trace\":\n    case \"debug\": {\n      console.log(s);\n      break;\n    }\n    case \"info\": {\n      console.info(s);\n      break;\n    }\n    case \"warn\": {\n      console.warn(s);\n      break;\n    }\n    case \"error\": {\n      console.error(s);\n      break;\n    }\n  }\n}, $n = (i) => {\n  const e = i.logHandler ?? zn;\n  return new Wn(e, i.logLevel);\n}, qn = /* @__PURE__ */ new Map([\n  [\n    \"trace\",\n    0\n    /* Trace */\n  ],\n  [\n    \"debug\",\n    1\n    /* Debug */\n  ],\n  [\n    \"info\",\n    2\n    /* Info */\n  ],\n  [\n    \"warn\",\n    3\n    /* Warn */\n  ],\n  [\n    \"error\",\n    4\n    /* Error */\n  ],\n  [\n    \"silent\",\n    5\n    /* Silent */\n  ]\n]);\nclass Wn {\n  constructor(e, t) {\n    this._handler = e;\n    const r = qn.get(t);\n    if (r === void 0)\n      throw new ably__WEBPACK_IMPORTED_MODULE_0__.ErrorInfo(`Invalid log level: ${t}`, 5e4, 500);\n    this._levelNumber = r;\n  }\n  trace(e, t) {\n    this._write(e, \"trace\", 0, t);\n  }\n  debug(e, t) {\n    this._write(e, \"debug\", 1, t);\n  }\n  info(e, t) {\n    this._write(e, \"info\", 2, t);\n  }\n  warn(e, t) {\n    this._write(e, \"warn\", 3, t);\n  }\n  error(e, t) {\n    this._write(e, \"error\", 4, t);\n  }\n  _write(e, t, r, s) {\n    r >= this._levelNumber && this._handler(e, t, s);\n  }\n}\nconst Un = {\n  logLevel: ot.Error\n}, Bn = (i) => (i = i ?? {}, {\n  ...i,\n  logLevel: i.logLevel ?? Un.logLevel\n});\nclass Gn {\n  constructor(e) {\n    this._status = e;\n  }\n  get status() {\n    return this._status;\n  }\n}\nconst Hn = ably__WEBPACK_IMPORTED_MODULE_0__.Realtime.EventEmitter;\nclass S extends Hn {\n}\nconst Vn = 5e3;\nvar Kn = /* @__PURE__ */ ((i) => (i.Initialized = \"initialized\", i.Connecting = \"connecting\", i.Connected = \"connected\", i.Disconnected = \"disconnected\", i.Suspended = \"suspended\", i.Failed = \"failed\", i))(Kn || {});\nclass Qn extends S {\n  /**\n   * Constructs a new `DefaultConnection` instance.\n   * @param ably The Ably Realtime client.\n   * @param logger The logger to use.\n   */\n  constructor(e, t) {\n    super(), this._state = \"initialized\", this._logger = t, this._state = this._mapAblyStatusToChat(e.connection.state), this._error = e.connection.errorReason, this._connection = e.connection, this._connection.on((r) => {\n      const s = this._mapAblyStatusToChat(r.current);\n      if (s === this._state)\n        return;\n      const c = {\n        current: s,\n        previous: this._state,\n        error: r.reason,\n        retryIn: r.retryIn\n      };\n      if (s === \"disconnected\" && !this._transientTimeout) {\n        this._transientTimeout = setTimeout(() => {\n          this._transientTimeout = void 0, this._applyStatusChange(c);\n        }, Vn);\n        return;\n      }\n      this._transientTimeout && (clearTimeout(this._transientTimeout), this._transientTimeout = void 0), this._applyStatusChange(c);\n    });\n  }\n  /**\n   * @inheritdoc\n   */\n  get current() {\n    return this._state;\n  }\n  /**\n   * @inheritdoc\n   */\n  get error() {\n    return this._error;\n  }\n  /**\n   * @inheritdoc\n   */\n  onChange(e) {\n    return this.on(e), {\n      off: () => {\n        this.off(e);\n      }\n    };\n  }\n  /**\n   * @inheritdoc\n   */\n  offAll() {\n    this.off();\n  }\n  _applyStatusChange(e) {\n    this._state = e.current, this._error = e.error, this._logger.info(\"Connection state changed\", e), this.emit(e.current, e);\n  }\n  _mapAblyStatusToChat(e) {\n    switch (e) {\n      case \"closing\":\n      case \"closed\":\n        return \"failed\";\n      default:\n        return e;\n    }\n  }\n}\nvar it = Object.prototype.hasOwnProperty;\nfunction st(i, e, t) {\n  for (t of i.keys())\n    if (j(t, e)) return t;\n}\nfunction j(i, e) {\n  var t, r, s;\n  if (i === e) return !0;\n  if (i && e && (t = i.constructor) === e.constructor) {\n    if (t === Date) return i.getTime() === e.getTime();\n    if (t === RegExp) return i.toString() === e.toString();\n    if (t === Array) {\n      if ((r = i.length) === e.length)\n        for (; r-- && j(i[r], e[r]); ) ;\n      return r === -1;\n    }\n    if (t === Set) {\n      if (i.size !== e.size)\n        return !1;\n      for (r of i)\n        if (s = r, s && typeof s == \"object\" && (s = st(e, s), !s) || !e.has(s)) return !1;\n      return !0;\n    }\n    if (t === Map) {\n      if (i.size !== e.size)\n        return !1;\n      for (r of i)\n        if (s = r[0], s && typeof s == \"object\" && (s = st(e, s), !s) || !j(r[1], e.get(s)))\n          return !1;\n      return !0;\n    }\n    if (t === ArrayBuffer)\n      i = new Uint8Array(i), e = new Uint8Array(e);\n    else if (t === DataView) {\n      if ((r = i.byteLength) === e.byteLength)\n        for (; r-- && i.getInt8(r) === e.getInt8(r); ) ;\n      return r === -1;\n    }\n    if (ArrayBuffer.isView(i)) {\n      if ((r = i.byteLength) === e.byteLength)\n        for (; r-- && i[r] === e[r]; ) ;\n      return r === -1;\n    }\n    if (!t || typeof i == \"object\") {\n      r = 0;\n      for (t in i)\n        if (it.call(i, t) && ++r && !it.call(e, t) || !(t in e) || !j(i[t], e[t])) return !1;\n      return Object.keys(e).length === r;\n    }\n  }\n  return i !== i && e !== e;\n}\nclass $ {\n  constructor(e, t, r, s) {\n    this.seriesId = e, this.timestamp = t, this.counter = r, this.index = s;\n  }\n  /**\n   * Returns the string representation of the timeserial object.\n   * @returns The timeserial string.\n   */\n  toString() {\n    return `${this.seriesId}@${this.timestamp.toString()}-${this.counter.toString()}${this.index ? `:${this.index.toString()}` : \"\"}`;\n  }\n  /**\n   * Calculate the timeserial object from a timeserial string.\n   *\n   * @param timeserial The timeserial string to parse.\n   * @returns The parsed timeserial object.\n   * @throws {@link ErrorInfo} if timeserial is invalid.\n   */\n  static calculateTimeserial(e) {\n    const [t, r] = e.split(\"@\");\n    if (!t || !r)\n      throw new ably__WEBPACK_IMPORTED_MODULE_0__.ErrorInfo(\"invalid timeserial\", 5e4, 500);\n    const [s, c] = r.split(\"-\");\n    if (!s || !c)\n      throw new ably__WEBPACK_IMPORTED_MODULE_0__.ErrorInfo(\"invalid timeserial\", 5e4, 500);\n    const [u, g] = c.split(\":\");\n    if (!u)\n      throw new ably__WEBPACK_IMPORTED_MODULE_0__.ErrorInfo(\"invalid timeserial\", 5e4, 500);\n    return new $(t, Number(s), Number(u), g ? Number(g) : void 0);\n  }\n  /**\n   * Compares this timeserial to the supplied timeserial, returning a number indicating their relative order.\n   * @param timeserialToCompare The timeserial to compare against. Can be a string or a Timeserial object.\n   * @returns 0 if the timeserials are equal, <0 if the first timeserial is less than the second, >0 if the first timeserial is greater than the second.\n   * @throws {@link ErrorInfo} if comparison timeserial is invalid.\n   */\n  _timeserialCompare(e) {\n    const t = typeof e == \"string\" ? $.calculateTimeserial(e) : e, r = this.timestamp - t.timestamp;\n    if (r)\n      return r;\n    const s = this.counter - t.counter;\n    if (s)\n      return s;\n    const c = this.seriesId === t.seriesId ? 0 : this.seriesId < t.seriesId ? -1 : 1;\n    return c || (this.index !== void 0 && t.index !== void 0 ? this.index - t.index : 0);\n  }\n  /**\n   * Determines if this timeserial occurs logically before the given timeserial.\n   *\n   * @param timeserial The timeserial to compare against. Can be a string or a Timeserial object.\n   * @returns true if this timeserial precedes the given timeserial, in global order.\n   * @throws {@link ErrorInfo} if the given timeserial is invalid.\n   */\n  before(e) {\n    return this._timeserialCompare(e) < 0;\n  }\n  /**\n   * Determines if this timeserial occurs logically after the given timeserial.\n   *\n   * @param timeserial The timeserial to compare against. Can be a string or a Timeserial object.\n   * @returns true if this timeserial follows the given timeserial, in global order.\n   * @throws {@link ErrorInfo} if the given timeserial is invalid.\n   */\n  after(e) {\n    return this._timeserialCompare(e) > 0;\n  }\n  /**\n   * Determines if this timeserial is equal to the given timeserial.\n   * @param timeserial The timeserial to compare against. Can be a string or a Timeserial object.\n   * @returns true if this timeserial is equal to the given timeserial.\n   * @throws {@link ErrorInfo} if the given timeserial is invalid.\n   */\n  equal(e) {\n    return this._timeserialCompare(e) === 0;\n  }\n}\nclass fe {\n  constructor(e, t, r, s, c, u, g) {\n    this.timeserial = e, this.clientId = t, this.roomId = r, this.text = s, this.createdAt = c, this.metadata = u, this.headers = g, this._calculatedTimeserial = $.calculateTimeserial(e), Object.freeze(this);\n  }\n  before(e) {\n    return this._calculatedTimeserial.before(e.timeserial);\n  }\n  after(e) {\n    return this._calculatedTimeserial.after(e.timeserial);\n  }\n  equal(e) {\n    return this._calculatedTimeserial.equal(e.timeserial);\n  }\n}\nclass Xn {\n  constructor(e, t) {\n    this._apiProtocolVersion = 3, this._realtime = e, this._logger = t;\n  }\n  async getMessages(e, t) {\n    return this._makeAuthorizedPaginatedRequest(\n      `/chat/v1/rooms/${e}/messages`,\n      t\n    ).then((r) => (r.items = r.items.map((s) => {\n      const c = s.metadata, u = s.headers;\n      return new fe(\n        s.timeserial,\n        s.clientId,\n        s.roomId,\n        s.text,\n        new Date(s.createdAt),\n        c ?? {},\n        u ?? {}\n      );\n    }), r));\n  }\n  async sendMessage(e, t) {\n    const r = { text: t.text };\n    return t.metadata && (r.metadata = t.metadata), t.headers && (r.headers = t.headers), this._makeAuthorizedRequest(\n      `/chat/v1/rooms/${e}/messages`,\n      \"POST\",\n      r\n    );\n  }\n  async getOccupancy(e) {\n    return this._makeAuthorizedRequest(`/chat/v1/rooms/${e}/occupancy`, \"GET\");\n  }\n  async _makeAuthorizedRequest(e, t, r) {\n    const s = await this._realtime.request(t, e, this._apiProtocolVersion, {}, r);\n    if (!s.success)\n      throw this._logger.error(\"ChatApi._makeAuthorizedRequest(); failed to make request\", {\n        url: e,\n        statusCode: s.statusCode,\n        errorCode: s.errorCode,\n        errorMessage: s.errorMessage\n      }), new ably__WEBPACK_IMPORTED_MODULE_0__.ErrorInfo(s.errorMessage, s.errorCode, s.statusCode);\n    return s.items[0];\n  }\n  async _makeAuthorizedPaginatedRequest(e, t, r) {\n    const s = await this._realtime.request(\"GET\", e, this._apiProtocolVersion, t, r);\n    if (!s.success)\n      throw this._logger.error(\"ChatApi._makeAuthorizedPaginatedRequest(); failed to make request\", {\n        url: e,\n        statusCode: s.statusCode,\n        errorCode: s.errorCode,\n        errorMessage: s.errorMessage\n      }), new ably__WEBPACK_IMPORTED_MODULE_0__.ErrorInfo(s.errorMessage, s.errorCode, s.statusCode);\n    return s;\n  }\n}\nvar J = typeof globalThis < \"u\" ? globalThis : typeof window < \"u\" ? window : typeof global < \"u\" ? global : typeof self < \"u\" ? self : {};\nfunction Yn(i) {\n  return i && i.__esModule && Object.prototype.hasOwnProperty.call(i, \"default\") ? i.default : i;\n}\nvar Z = { exports: {} };\nZ.exports;\n(function(i, e) {\n  var t = 200, r = \"__lodash_hash_undefined__\", s = 9007199254740991, c = \"[object Arguments]\", u = \"[object Array]\", g = \"[object Boolean]\", f = \"[object Date]\", y = \"[object Error]\", p = \"[object Function]\", R = \"[object GeneratorFunction]\", U = \"[object Map]\", ye = \"[object Number]\", ee = \"[object Object]\", we = \"[object Promise]\", be = \"[object RegExp]\", B = \"[object Set]\", ve = \"[object String]\", Re = \"[object Symbol]\", te = \"[object WeakMap]\", Ae = \"[object ArrayBuffer]\", G = \"[object DataView]\", Ee = \"[object Float32Array]\", Ie = \"[object Float64Array]\", Se = \"[object Int8Array]\", Te = \"[object Int16Array]\", Me = \"[object Int32Array]\", De = \"[object Uint8Array]\", Ce = \"[object Uint8ClampedArray]\", Pe = \"[object Uint16Array]\", xe = \"[object Uint32Array]\", ft = /[\\\\^$.*+?()[\\]{}|]/g, _t = /\\w*$/, mt = /^\\[object .+?Constructor\\]$/, pt = /^(?:0|[1-9]\\d*)$/, _ = {};\n  _[c] = _[u] = _[Ae] = _[G] = _[g] = _[f] = _[Ee] = _[Ie] = _[Se] = _[Te] = _[Me] = _[U] = _[ye] = _[ee] = _[be] = _[B] = _[ve] = _[Re] = _[De] = _[Ce] = _[Pe] = _[xe] = !0, _[y] = _[p] = _[te] = !1;\n  var yt = typeof J == \"object\" && J && J.Object === Object && J, wt = typeof self == \"object\" && self && self.Object === Object && self, A = yt || wt || Function(\"return this\")(), Oe = e && !e.nodeType && e, Fe = Oe && !0 && i && !i.nodeType && i, bt = Fe && Fe.exports === Oe;\n  function vt(n, a) {\n    return n.set(a[0], a[1]), n;\n  }\n  function Rt(n, a) {\n    return n.add(a), n;\n  }\n  function At(n, a) {\n    for (var o = -1, l = n ? n.length : 0; ++o < l && a(n[o], o, n) !== !1; )\n      ;\n    return n;\n  }\n  function Et(n, a) {\n    for (var o = -1, l = a.length, w = n.length; ++o < l; )\n      n[w + o] = a[o];\n    return n;\n  }\n  function Le(n, a, o, l) {\n    for (var w = -1, b = n ? n.length : 0; ++w < b; )\n      o = a(o, n[w], w, n);\n    return o;\n  }\n  function It(n, a) {\n    for (var o = -1, l = Array(n); ++o < n; )\n      l[o] = a(o);\n    return l;\n  }\n  function St(n, a) {\n    return n == null ? void 0 : n[a];\n  }\n  function je(n) {\n    var a = !1;\n    if (n != null && typeof n.toString != \"function\")\n      try {\n        a = !!(n + \"\");\n      } catch {\n      }\n    return a;\n  }\n  function ke(n) {\n    var a = -1, o = Array(n.size);\n    return n.forEach(function(l, w) {\n      o[++a] = [w, l];\n    }), o;\n  }\n  function ne(n, a) {\n    return function(o) {\n      return n(a(o));\n    };\n  }\n  function Ne(n) {\n    var a = -1, o = Array(n.size);\n    return n.forEach(function(l) {\n      o[++a] = l;\n    }), o;\n  }\n  var Tt = Array.prototype, Mt = Function.prototype, H = Object.prototype, re = A[\"__core-js_shared__\"], ze = function() {\n    var n = /[^.]+$/.exec(re && re.keys && re.keys.IE_PROTO || \"\");\n    return n ? \"Symbol(src)_1.\" + n : \"\";\n  }(), $e = Mt.toString, T = H.hasOwnProperty, V = H.toString, Dt = RegExp(\n    \"^\" + $e.call(T).replace(ft, \"\\\\$&\").replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, \"$1.*?\") + \"$\"\n  ), qe = bt ? A.Buffer : void 0, We = A.Symbol, Ue = A.Uint8Array, Ct = ne(Object.getPrototypeOf, Object), Pt = Object.create, xt = H.propertyIsEnumerable, Ot = Tt.splice, Be = Object.getOwnPropertySymbols, Ft = qe ? qe.isBuffer : void 0, Lt = ne(Object.keys, Object), ie = O(A, \"DataView\"), k = O(A, \"Map\"), se = O(A, \"Promise\"), ae = O(A, \"Set\"), oe = O(A, \"WeakMap\"), N = O(Object, \"create\"), jt = C(ie), kt = C(k), Nt = C(se), zt = C(ae), $t = C(oe), Ge = We ? We.prototype : void 0, He = Ge ? Ge.valueOf : void 0;\n  function M(n) {\n    var a = -1, o = n ? n.length : 0;\n    for (this.clear(); ++a < o; ) {\n      var l = n[a];\n      this.set(l[0], l[1]);\n    }\n  }\n  function qt() {\n    this.__data__ = N ? N(null) : {};\n  }\n  function Wt(n) {\n    return this.has(n) && delete this.__data__[n];\n  }\n  function Ut(n) {\n    var a = this.__data__;\n    if (N) {\n      var o = a[n];\n      return o === r ? void 0 : o;\n    }\n    return T.call(a, n) ? a[n] : void 0;\n  }\n  function Bt(n) {\n    var a = this.__data__;\n    return N ? a[n] !== void 0 : T.call(a, n);\n  }\n  function Gt(n, a) {\n    var o = this.__data__;\n    return o[n] = N && a === void 0 ? r : a, this;\n  }\n  M.prototype.clear = qt, M.prototype.delete = Wt, M.prototype.get = Ut, M.prototype.has = Bt, M.prototype.set = Gt;\n  function E(n) {\n    var a = -1, o = n ? n.length : 0;\n    for (this.clear(); ++a < o; ) {\n      var l = n[a];\n      this.set(l[0], l[1]);\n    }\n  }\n  function Ht() {\n    this.__data__ = [];\n  }\n  function Vt(n) {\n    var a = this.__data__, o = K(a, n);\n    if (o < 0)\n      return !1;\n    var l = a.length - 1;\n    return o == l ? a.pop() : Ot.call(a, o, 1), !0;\n  }\n  function Kt(n) {\n    var a = this.__data__, o = K(a, n);\n    return o < 0 ? void 0 : a[o][1];\n  }\n  function Qt(n) {\n    return K(this.__data__, n) > -1;\n  }\n  function Xt(n, a) {\n    var o = this.__data__, l = K(o, n);\n    return l < 0 ? o.push([n, a]) : o[l][1] = a, this;\n  }\n  E.prototype.clear = Ht, E.prototype.delete = Vt, E.prototype.get = Kt, E.prototype.has = Qt, E.prototype.set = Xt;\n  function P(n) {\n    var a = -1, o = n ? n.length : 0;\n    for (this.clear(); ++a < o; ) {\n      var l = n[a];\n      this.set(l[0], l[1]);\n    }\n  }\n  function Yt() {\n    this.__data__ = {\n      hash: new M(),\n      map: new (k || E)(),\n      string: new M()\n    };\n  }\n  function Jt(n) {\n    return Q(this, n).delete(n);\n  }\n  function Zt(n) {\n    return Q(this, n).get(n);\n  }\n  function en(n) {\n    return Q(this, n).has(n);\n  }\n  function tn(n, a) {\n    return Q(this, n).set(n, a), this;\n  }\n  P.prototype.clear = Yt, P.prototype.delete = Jt, P.prototype.get = Zt, P.prototype.has = en, P.prototype.set = tn;\n  function x(n) {\n    this.__data__ = new E(n);\n  }\n  function nn() {\n    this.__data__ = new E();\n  }\n  function rn(n) {\n    return this.__data__.delete(n);\n  }\n  function sn(n) {\n    return this.__data__.get(n);\n  }\n  function an(n) {\n    return this.__data__.has(n);\n  }\n  function on(n, a) {\n    var o = this.__data__;\n    if (o instanceof E) {\n      var l = o.__data__;\n      if (!k || l.length < t - 1)\n        return l.push([n, a]), this;\n      o = this.__data__ = new P(l);\n    }\n    return o.set(n, a), this;\n  }\n  x.prototype.clear = nn, x.prototype.delete = rn, x.prototype.get = sn, x.prototype.has = an, x.prototype.set = on;\n  function cn(n, a) {\n    var o = ue(n) || xn(n) ? It(n.length, String) : [], l = o.length, w = !!l;\n    for (var b in n)\n      T.call(n, b) && !(w && (b == \"length\" || Mn(b, l))) && o.push(b);\n    return o;\n  }\n  function Ve(n, a, o) {\n    var l = n[a];\n    (!(T.call(n, a) && Ye(l, o)) || o === void 0 && !(a in n)) && (n[a] = o);\n  }\n  function K(n, a) {\n    for (var o = n.length; o--; )\n      if (Ye(n[o][0], a))\n        return o;\n    return -1;\n  }\n  function hn(n, a) {\n    return n && Ke(a, le(a), n);\n  }\n  function ce(n, a, o, l, w, b, I) {\n    var v;\n    if (l && (v = b ? l(n, w, b, I) : l(n)), v !== void 0)\n      return v;\n    if (!X(n))\n      return n;\n    var et = ue(n);\n    if (et) {\n      if (v = In(n), !a)\n        return Rn(n, v);\n    } else {\n      var F = D(n), tt = F == p || F == R;\n      if (Fn(n))\n        return _n(n, a);\n      if (F == ee || F == c || tt && !b) {\n        if (je(n))\n          return b ? n : {};\n        if (v = Sn(tt ? {} : n), !a)\n          return An(n, hn(v, n));\n      } else {\n        if (!_[F])\n          return b ? n : {};\n        v = Tn(n, F, ce, a);\n      }\n    }\n    I || (I = new x());\n    var nt = I.get(n);\n    if (nt)\n      return nt;\n    if (I.set(n, v), !et)\n      var rt = o ? En(n) : le(n);\n    return At(rt || n, function(de, Y) {\n      rt && (Y = de, de = n[Y]), Ve(v, Y, ce(de, a, o, l, Y, n, I));\n    }), v;\n  }\n  function un(n) {\n    return X(n) ? Pt(n) : {};\n  }\n  function ln(n, a, o) {\n    var l = a(n);\n    return ue(n) ? l : Et(l, o(n));\n  }\n  function dn(n) {\n    return V.call(n);\n  }\n  function gn(n) {\n    if (!X(n) || Cn(n))\n      return !1;\n    var a = Ze(n) || je(n) ? Dt : mt;\n    return a.test(C(n));\n  }\n  function fn(n) {\n    if (!Xe(n))\n      return Lt(n);\n    var a = [];\n    for (var o in Object(n))\n      T.call(n, o) && o != \"constructor\" && a.push(o);\n    return a;\n  }\n  function _n(n, a) {\n    if (a)\n      return n.slice();\n    var o = new n.constructor(n.length);\n    return n.copy(o), o;\n  }\n  function he(n) {\n    var a = new n.constructor(n.byteLength);\n    return new Ue(a).set(new Ue(n)), a;\n  }\n  function mn(n, a) {\n    var o = a ? he(n.buffer) : n.buffer;\n    return new n.constructor(o, n.byteOffset, n.byteLength);\n  }\n  function pn(n, a, o) {\n    var l = a ? o(ke(n), !0) : ke(n);\n    return Le(l, vt, new n.constructor());\n  }\n  function yn(n) {\n    var a = new n.constructor(n.source, _t.exec(n));\n    return a.lastIndex = n.lastIndex, a;\n  }\n  function wn(n, a, o) {\n    var l = a ? o(Ne(n), !0) : Ne(n);\n    return Le(l, Rt, new n.constructor());\n  }\n  function bn(n) {\n    return He ? Object(He.call(n)) : {};\n  }\n  function vn(n, a) {\n    var o = a ? he(n.buffer) : n.buffer;\n    return new n.constructor(o, n.byteOffset, n.length);\n  }\n  function Rn(n, a) {\n    var o = -1, l = n.length;\n    for (a || (a = Array(l)); ++o < l; )\n      a[o] = n[o];\n    return a;\n  }\n  function Ke(n, a, o, l) {\n    o || (o = {});\n    for (var w = -1, b = a.length; ++w < b; ) {\n      var I = a[w], v = void 0;\n      Ve(o, I, v === void 0 ? n[I] : v);\n    }\n    return o;\n  }\n  function An(n, a) {\n    return Ke(n, Qe(n), a);\n  }\n  function En(n) {\n    return ln(n, le, Qe);\n  }\n  function Q(n, a) {\n    var o = n.__data__;\n    return Dn(a) ? o[typeof a == \"string\" ? \"string\" : \"hash\"] : o.map;\n  }\n  function O(n, a) {\n    var o = St(n, a);\n    return gn(o) ? o : void 0;\n  }\n  var Qe = Be ? ne(Be, Object) : kn, D = dn;\n  (ie && D(new ie(new ArrayBuffer(1))) != G || k && D(new k()) != U || se && D(se.resolve()) != we || ae && D(new ae()) != B || oe && D(new oe()) != te) && (D = function(n) {\n    var a = V.call(n), o = a == ee ? n.constructor : void 0, l = o ? C(o) : void 0;\n    if (l)\n      switch (l) {\n        case jt:\n          return G;\n        case kt:\n          return U;\n        case Nt:\n          return we;\n        case zt:\n          return B;\n        case $t:\n          return te;\n      }\n    return a;\n  });\n  function In(n) {\n    var a = n.length, o = n.constructor(a);\n    return a && typeof n[0] == \"string\" && T.call(n, \"index\") && (o.index = n.index, o.input = n.input), o;\n  }\n  function Sn(n) {\n    return typeof n.constructor == \"function\" && !Xe(n) ? un(Ct(n)) : {};\n  }\n  function Tn(n, a, o, l) {\n    var w = n.constructor;\n    switch (a) {\n      case Ae:\n        return he(n);\n      case g:\n      case f:\n        return new w(+n);\n      case G:\n        return mn(n, l);\n      case Ee:\n      case Ie:\n      case Se:\n      case Te:\n      case Me:\n      case De:\n      case Ce:\n      case Pe:\n      case xe:\n        return vn(n, l);\n      case U:\n        return pn(n, l, o);\n      case ye:\n      case ve:\n        return new w(n);\n      case be:\n        return yn(n);\n      case B:\n        return wn(n, l, o);\n      case Re:\n        return bn(n);\n    }\n  }\n  function Mn(n, a) {\n    return a = a ?? s, !!a && (typeof n == \"number\" || pt.test(n)) && n > -1 && n % 1 == 0 && n < a;\n  }\n  function Dn(n) {\n    var a = typeof n;\n    return a == \"string\" || a == \"number\" || a == \"symbol\" || a == \"boolean\" ? n !== \"__proto__\" : n === null;\n  }\n  function Cn(n) {\n    return !!ze && ze in n;\n  }\n  function Xe(n) {\n    var a = n && n.constructor, o = typeof a == \"function\" && a.prototype || H;\n    return n === o;\n  }\n  function C(n) {\n    if (n != null) {\n      try {\n        return $e.call(n);\n      } catch {\n      }\n      try {\n        return n + \"\";\n      } catch {\n      }\n    }\n    return \"\";\n  }\n  function Pn(n) {\n    return ce(n, !0, !0);\n  }\n  function Ye(n, a) {\n    return n === a || n !== n && a !== a;\n  }\n  function xn(n) {\n    return On(n) && T.call(n, \"callee\") && (!xt.call(n, \"callee\") || V.call(n) == c);\n  }\n  var ue = Array.isArray;\n  function Je(n) {\n    return n != null && Ln(n.length) && !Ze(n);\n  }\n  function On(n) {\n    return jn(n) && Je(n);\n  }\n  var Fn = Ft || Nn;\n  function Ze(n) {\n    var a = X(n) ? V.call(n) : \"\";\n    return a == p || a == R;\n  }\n  function Ln(n) {\n    return typeof n == \"number\" && n > -1 && n % 1 == 0 && n <= s;\n  }\n  function X(n) {\n    var a = typeof n;\n    return !!n && (a == \"object\" || a == \"function\");\n  }\n  function jn(n) {\n    return !!n && typeof n == \"object\";\n  }\n  function le(n) {\n    return Je(n) ? cn(n) : fn(n);\n  }\n  function kn() {\n    return [];\n  }\n  function Nn() {\n    return !1;\n  }\n  i.exports = Pn;\n})(Z, Z.exports);\nvar Jn = Z.exports;\nconst Zn = /* @__PURE__ */ Yn(Jn);\nvar m = /* @__PURE__ */ ((i) => (i[i.MessagesAttachmentFailed = 102001] = \"MessagesAttachmentFailed\", i[i.PresenceAttachmentFailed = 102002] = \"PresenceAttachmentFailed\", i[i.ReactionsAttachmentFailed = 102003] = \"ReactionsAttachmentFailed\", i[i.OccupancyAttachmentFailed = 102004] = \"OccupancyAttachmentFailed\", i[i.TypingAttachmentFailed = 102005] = \"TypingAttachmentFailed\", i[i.MessagesDetachmentFailed = 102050] = \"MessagesDetachmentFailed\", i[i.PresenceDetachmentFailed = 102051] = \"PresenceDetachmentFailed\", i[i.ReactionsDetachmentFailed = 102052] = \"ReactionsDetachmentFailed\", i[i.OccupancyDetachmentFailed = 102053] = \"OccupancyDetachmentFailed\", i[i.TypingDetachmentFailed = 102054] = \"TypingDetachmentFailed\", i[i.RoomDiscontinuity = 102100] = \"RoomDiscontinuity\", i[i.RoomInFailedState = 102101] = \"RoomInFailedState\", i[i.RoomIsReleasing = 102102] = \"RoomIsReleasing\", i[i.RoomIsReleased = 102103] = \"RoomIsReleased\", i[i.PreviousOperationFailed = 102104] = \"PreviousOperationFailed\", i[i.RoomLifecycleError = 102105] = \"RoomLifecycleError\", i))(m || {});\nconst Dr = (i, e) => i.code === e, ge = \"0.2.1\", er = `chat-js/${ge}`, tr = { params: { agent: er } }, q = (i, e, t) => {\n  const r = {\n    ...t,\n    params: {\n      ...t == null ? void 0 : t.params,\n      ...tr.params\n    }\n  };\n  return e.channels.get(i, r);\n}, _e = (i) => `${i}::$chat::$chatMessages`, W = () => new S();\nvar L = /* @__PURE__ */ ((i) => (i.Created = \"message.created\", i))(L || {}), nr = /* @__PURE__ */ ((i) => (i.Enter = \"enter\", i.Leave = \"leave\", i.Update = \"update\", i.Present = \"present\", i))(nr || {}), ct = /* @__PURE__ */ ((i) => (i.Changed = \"typing.changed\", i))(ct || {}), z = /* @__PURE__ */ ((i) => (i.Reaction = \"roomReaction\", i))(z || {});\nfunction ht(i, e) {\n  const t = e;\n  if (!i)\n    throw new ably__WEBPACK_IMPORTED_MODULE_0__.ErrorInfo(\"received incoming message without roomId\", 5e4, 500);\n  if (!t.data)\n    throw new ably__WEBPACK_IMPORTED_MODULE_0__.ErrorInfo(\"received incoming message without data\", 5e4, 500);\n  if (!t.clientId)\n    throw new ably__WEBPACK_IMPORTED_MODULE_0__.ErrorInfo(\"received incoming message without clientId\", 5e4, 500);\n  if (!t.timestamp)\n    throw new ably__WEBPACK_IMPORTED_MODULE_0__.ErrorInfo(\"received incoming message without timestamp\", 5e4, 500);\n  if (t.data.text === void 0)\n    throw new ably__WEBPACK_IMPORTED_MODULE_0__.ErrorInfo(\"received incoming message without text\", 5e4, 500);\n  if (!t.extras)\n    throw new ably__WEBPACK_IMPORTED_MODULE_0__.ErrorInfo(\"received incoming message without extras\", 5e4, 500);\n  if (!t.extras.timeserial)\n    throw new ably__WEBPACK_IMPORTED_MODULE_0__.ErrorInfo(\"received incoming message without timeserial\", 5e4, 500);\n  return new fe(\n    t.extras.timeserial,\n    t.clientId,\n    i,\n    t.data.text,\n    new Date(t.timestamp),\n    t.data.metadata ?? {},\n    t.extras.headers ?? {}\n  );\n}\nconst me = (i) => {\n  const e = i.channel.subscriptions;\n  lt(e, i.listener, i.events);\n}, ut = (i) => {\n  const e = i.channel.presence.subscriptions;\n  lt(e, i.listener, i.events);\n}, lt = (i, e, t) => {\n  if (t) {\n    i.on(t, e);\n    return;\n  }\n  i.on(e);\n};\nclass rr extends S {\n  /**\n   * Constructs a new `DefaultMessages` instance.\n   * @param roomId The unique identifier of the room.\n   * @param realtime An instance of the Ably Realtime client.\n   * @param chatApi An instance of the ChatApi.\n   * @param clientId The client ID of the user.\n   * @param logger An instance of the Logger.\n   * @param initAfter A promise that is awaited before creating any channels.\n   */\n  constructor(e, t, r, s, c, u) {\n    super(), this._discontinuityEmitter = W(), this._roomId = e, this._channel = u.then(() => this._makeChannel(e, t)), this._channel.catch((g) => {\n      c.debug(\"Messages: channel initialization canceled\", { roomId: e, error: g });\n    }), this._chatApi = r, this._clientId = s, this._logger = c, this._listenerSubscriptionPoints = /* @__PURE__ */ new Map();\n  }\n  /**\n   * Creates the realtime channel for messages. Called after initAfter is resolved.\n   */\n  _makeChannel(e, t) {\n    const r = q(_e(e), t);\n    return me({\n      listener: this._processEvent.bind(this),\n      events: [L.Created],\n      channel: r\n    }), r.on(\"attached\", (s) => {\n      this._handleAttach(s.resumed);\n    }), r.on(\"update\", (s) => {\n      s.current === \"attached\" && s.previous === \"attached\" && this._handleAttach(s.resumed);\n    }), r;\n  }\n  /**\n   * @inheritdoc Messages\n   */\n  async _getBeforeSubscriptionStart(e, t) {\n    this._logger.trace(\"DefaultSubscriptionManager.getBeforeSubscriptionStart();\");\n    const r = this._listenerSubscriptionPoints.get(e);\n    if (r === void 0)\n      throw this._logger.error(\n        \"DefaultSubscriptionManager.getBeforeSubscriptionStart(); listener has not been subscribed yet\"\n      ), new ably__WEBPACK_IMPORTED_MODULE_0__.ErrorInfo(\n        \"cannot query history; listener has not been subscribed yet\",\n        4e4,\n        400\n      );\n    const s = await r, c = $.calculateTimeserial(s.fromSerial);\n    if (t.end && t.end > c.timestamp)\n      throw this._logger.error(\n        \"DefaultSubscriptionManager.getBeforeSubscriptionStart(); end time is after the subscription point of the listener\",\n        {\n          endTime: t.end,\n          subscriptionTime: c.timestamp\n        }\n      ), new ably__WEBPACK_IMPORTED_MODULE_0__.ErrorInfo(\n        \"cannot query history; end time is after the subscription point of the listener\",\n        4e4,\n        400\n      );\n    return this._chatApi.getMessages(this._roomId, {\n      ...t,\n      direction: \"backwards\",\n      ...s\n    });\n  }\n  /**\n   * Handle the case where the channel experiences a detach and reattaches.\n   */\n  _handleAttach(e) {\n    if (this._logger.trace(\"DefaultSubscriptionManager.handleAttach();\"), e) return;\n    const t = this._subscribeAtChannelAttach();\n    for (const [r] of this._listenerSubscriptionPoints.entries())\n      this._listenerSubscriptionPoints.set(r, t);\n  }\n  /**\n   * Create a promise that resolves with the attachSerial of the channel or the timeserial of the latest message.\n   */\n  async _resolveSubscriptionStart() {\n    const e = await this._getChannelProperties();\n    if (e.state === \"attached\") {\n      if (e.properties.channelSerial)\n        return { fromSerial: e.properties.channelSerial };\n      throw this._logger.error(\"DefaultSubscriptionManager.handleAttach(); channelSerial is undefined\"), new ably__WEBPACK_IMPORTED_MODULE_0__.ErrorInfo(\"channel is attached, but channelSerial is not defined\", 4e4, 400);\n    }\n    return this._subscribeAtChannelAttach();\n  }\n  async _getChannelProperties() {\n    return await this._channel;\n  }\n  async _subscribeAtChannelAttach() {\n    const e = await this._getChannelProperties();\n    return new Promise((t, r) => {\n      e.state === \"attached\" && (this._logger.debug(\"Messages._subscribeAtChannelAttach(); channel is attached already, using attachSerial\", {\n        attachSerial: e.properties.attachSerial\n      }), e.properties.attachSerial ? t({ fromSerial: e.properties.attachSerial }) : (this._logger.error(\"DefaultSubscriptionManager.handleAttach(); attachSerial is undefined\"), r(\n        new ably__WEBPACK_IMPORTED_MODULE_0__.ErrorInfo(\"channel is attached, but attachSerial is not defined\", 4e4, 400)\n      ))), e.once(\"attached\", () => {\n        this._logger.debug(\"Messages._subscribeAtChannelAttach(); channel is now attached, using attachSerial\", {\n          attachSerial: e.properties.attachSerial\n        }), e.properties.attachSerial ? t({ fromSerial: e.properties.attachSerial }) : (this._logger.error(\"DefaultSubscriptionManager.handleAttach(); attachSerial is undefined\"), r(\n          new ably__WEBPACK_IMPORTED_MODULE_0__.ErrorInfo(\"channel is attached, but attachSerial is not defined\", 4e4, 400)\n        ));\n      });\n    });\n  }\n  /**\n   * @inheritdoc Messages\n   */\n  get channel() {\n    return this._channel;\n  }\n  /**\n   * @inheritdoc Messages\n   */\n  async get(e) {\n    return this._logger.trace(\"Messages.query();\"), this._chatApi.getMessages(this._roomId, e);\n  }\n  /**\n   * @inheritdoc Messages\n   * @throws {@link ErrorInfo} if metadata defines reserved keys.\n   * @throws {@link ErrorInfo} if headers defines any headers prefixed with reserved words.\n   */\n  async send(e) {\n    this._logger.trace(\"Messages.send();\");\n    const { text: t, metadata: r, headers: s } = e;\n    if (r && r[\"ably-chat\"] !== void 0)\n      throw new ably__WEBPACK_IMPORTED_MODULE_0__.ErrorInfo(\"unable to send message; metadata cannot use reserved key 'ably-chat'\", 40001, 400);\n    if (s) {\n      for (const u of Object.keys(s))\n        if (u.startsWith(\"ably-chat\"))\n          throw new ably__WEBPACK_IMPORTED_MODULE_0__.ErrorInfo(\n            \"unable to send message; headers cannot have any key starting with reserved prefix 'ably-chat'\",\n            40001,\n            400\n          );\n    }\n    const c = await this._chatApi.sendMessage(this._roomId, { text: t, headers: s, metadata: r });\n    return new fe(\n      c.timeserial,\n      this._clientId,\n      this._roomId,\n      t,\n      new Date(c.createdAt),\n      r ?? {},\n      s ?? {}\n    );\n  }\n  /**\n   * @inheritdoc Messages\n   */\n  subscribe(e) {\n    this._logger.trace(\"Messages.subscribe();\"), super.on([L.Created], e);\n    const t = this._resolveSubscriptionStart();\n    return t.catch(() => {\n      this._logger.debug(\"Messages.subscribe(); subscription point was not resolved before the room was released\", {\n        roomId: this._roomId\n      });\n    }), this._listenerSubscriptionPoints.set(e, t), {\n      unsubscribe: () => {\n        this._listenerSubscriptionPoints.delete(e), this._logger.trace(\"Messages.unsubscribe();\"), super.off(e);\n      },\n      getPreviousMessages: (r) => this._getBeforeSubscriptionStart(e, r)\n    };\n  }\n  /**\n   * @inheritdoc Messages\n   */\n  unsubscribeAll() {\n    this._logger.trace(\"Messages.unsubscribeAll();\"), super.off(), this._listenerSubscriptionPoints.clear();\n  }\n  _processEvent(e) {\n    this._logger.trace(\"Messages._processEvent();\", {\n      channelEventMessage: e\n    });\n    const { name: t } = e;\n    switch (t) {\n      case L.Created: {\n        const r = this._parseNewMessage(e);\n        if (!r)\n          return;\n        this.emit(L.Created, { type: t, message: r });\n        break;\n      }\n      default:\n        this._logger.warn(\"Messages._processEvent(); received unknown event\", { name: t });\n    }\n  }\n  /**\n   * Validate the realtime message and convert it to a chat message.\n   */\n  _parseNewMessage(e) {\n    try {\n      return ht(this._roomId, e);\n    } catch (t) {\n      this._logger.error(\"failed to parse incoming message;\", { channelEventMessage: e, error: t });\n    }\n  }\n  /**\n   * @inheritdoc HandlesDiscontinuity\n   */\n  discontinuityDetected(e) {\n    this._logger.warn(\"Messages.discontinuityDetected();\", { reason: e }), this._discontinuityEmitter.emit(\"discontinuity\", e);\n  }\n  /**\n   * @inheritdoc EmitsDiscontinuities\n   */\n  onDiscontinuity(e) {\n    return this._logger.trace(\"Messages.onDiscontinuity();\"), this._discontinuityEmitter.on(e), {\n      off: () => {\n        this._discontinuityEmitter.off(e);\n      }\n    };\n  }\n  /**\n   * @inheritdoc ContributesToRoomLifecycle\n   */\n  get attachmentErrorCode() {\n    return m.MessagesAttachmentFailed;\n  }\n  /**\n   * @inheritdoc ContributesToRoomLifecycle\n   */\n  get detachmentErrorCode() {\n    return m.MessagesDetachmentFailed;\n  }\n}\nclass ir extends S {\n  /**\n   * Constructs a new `DefaultOccupancy` instance.\n   * @param roomId The unique identifier of the room.\n   * @param realtime An instance of the Ably Realtime client.\n   * @param chatApi An instance of the ChatApi.\n   * @param logger An instance of the Logger.\n   * @param initAfter A promise that is awaited before creating any channels.\n   */\n  constructor(e, t, r, s, c) {\n    super(), this._discontinuityEmitter = W(), this._roomId = e, this._channel = c.then(() => this._makeChannel(e, t)), this._channel.catch((u) => {\n      s.debug(\"Occupancy: channel initialization canceled\", { roomId: e, error: u });\n    }), this._chatApi = r, this._logger = s;\n  }\n  /**\n   * Creates the realtime channel for occupancy. Called after initAfter is resolved.\n   */\n  _makeChannel(e, t) {\n    const r = q(_e(e), t, { params: { occupancy: \"metrics\" } });\n    return me({\n      listener: this._internalOccupancyListener.bind(this),\n      events: [\"[meta]occupancy\"],\n      channel: r\n    }), r;\n  }\n  /**\n   * @inheritdoc Occupancy\n   */\n  subscribe(e) {\n    return this._logger.trace(\"Occupancy.subscribe();\"), this.on(e), {\n      unsubscribe: () => {\n        this._logger.trace(\"Occupancy.unsubscribe();\"), this.off(e);\n      }\n    };\n  }\n  /**\n   * @inheritdoc Occupancy\n   */\n  unsubscribeAll() {\n    this._logger.trace(\"Occupancy.unsubscribeAll();\"), this.off();\n  }\n  /**\n   * @inheritdoc Occupancy\n   */\n  async get() {\n    return this._logger.trace(\"Occupancy.get();\"), this._chatApi.getOccupancy(this._roomId);\n  }\n  /**\n   * @inheritdoc Occupancy\n   */\n  get channel() {\n    return this._channel;\n  }\n  /**\n   * An internal listener that listens for occupancy events from the underlying channel and translates them into\n   * occupancy events for the public API.\n   */\n  _internalOccupancyListener(e) {\n    if (typeof e.data != \"object\") {\n      this._logger.error(\"invalid occupancy event received; data is not an object\", e);\n      return;\n    }\n    const { metrics: t } = e.data;\n    if (t === void 0) {\n      this._logger.error(\"invalid occupancy event received; metrics is missing\", e);\n      return;\n    }\n    const { connections: r, presenceMembers: s } = t;\n    if (r === void 0) {\n      this._logger.error(\"invalid occupancy event received; connections is missing\", e);\n      return;\n    }\n    if (typeof r != \"number\" || !Number.isInteger(r)) {\n      this._logger.error(\"invalid occupancy event received; connections is not a number\", e);\n      return;\n    }\n    if (s === void 0) {\n      this._logger.error(\"invalid occupancy event received; presenceMembers is missing\", e);\n      return;\n    }\n    if (typeof s != \"number\" || !Number.isInteger(s)) {\n      this._logger.error(\"invalid occupancy event received; presenceMembers is not a number\", e);\n      return;\n    }\n    this.emit(\"occupancy\", {\n      connections: r,\n      presenceMembers: s\n    });\n  }\n  onDiscontinuity(e) {\n    return this._logger.trace(\"Occupancy.onDiscontinuity();\"), this._discontinuityEmitter.on(e), {\n      off: () => {\n        this._discontinuityEmitter.off(e);\n      }\n    };\n  }\n  discontinuityDetected(e) {\n    this._logger.warn(\"Occupancy.discontinuityDetected();\", { reason: e }), this._discontinuityEmitter.emit(\"discontinuity\", e);\n  }\n  /**\n   * @inheritdoc ContributesToRoomLifecycle\n   */\n  get attachmentErrorCode() {\n    return m.OccupancyAttachmentFailed;\n  }\n  /**\n   * @inheritdoc ContributesToRoomLifecycle\n   */\n  get detachmentErrorCode() {\n    return m.OccupancyDetachmentFailed;\n  }\n}\nclass sr extends S {\n  /**\n   * Constructs a new `DefaultPresence` instance.\n   * @param roomId The unique identifier of the room.\n   * @param roomOptions The room options for presence.\n   * @param realtime An instance of the Ably Realtime client.\n   * @param clientId The client ID, attached to presences messages as an identifier of the sender.\n   * A channel can have multiple connections using the same clientId.\n   * @param logger An instance of the Logger.\n   * @param initAfter A promise that is awaited before creating any channels.\n   */\n  constructor(e, t, r, s, c, u) {\n    super(), this._discontinuityEmitter = W(), this.subscribeToEvents = (g) => {\n      var f;\n      try {\n        this.emit(g.action, {\n          action: g.action,\n          clientId: g.clientId,\n          timestamp: g.timestamp,\n          // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n          data: (f = g.data) == null ? void 0 : f.userCustomData\n        });\n      } catch (y) {\n        throw this._logger.error(\"unable to handle presence event: not a valid presence event\", { action: g.action }), new ably__WEBPACK_IMPORTED_MODULE_0__.ErrorInfo(\n          `unable to handle ${g.action} presence event: not a valid presence event`,\n          5e4,\n          500,\n          y.message\n        );\n      }\n    }, this._channel = u.then(() => this._makeChannel(e, t, r)), this._channel.catch((g) => {\n      c.debug(\"Presence: channel initialization canceled\", { roomId: e, error: g });\n    }), this._clientId = s, this._logger = c;\n  }\n  /**\n   * Creates the realtime channel for presence. Called after initAfter is resolved.\n   */\n  _makeChannel(e, t, r) {\n    var u, g;\n    const s = [\"PUBLISH\", \"SUBSCRIBE\"];\n    (((u = t.presence) == null ? void 0 : u.enter) === void 0 || t.presence.enter) && s.push(\"PRESENCE\"), (((g = t.presence) == null ? void 0 : g.subscribe) === void 0 || t.presence.subscribe) && s.push(\"PRESENCE_SUBSCRIBE\");\n    const c = q(_e(e), r, { modes: s });\n    return ut({\n      listener: this.subscribeToEvents.bind(this),\n      channel: c\n    }), c;\n  }\n  /**\n   * Get the underlying Ably realtime channel used for presence in this chat room.\n   * @returns The realtime channel.\n   */\n  get channel() {\n    return this._channel;\n  }\n  /**\n   * @inheritDoc\n   */\n  async get(e) {\n    return this._logger.trace(\"Presence.get()\", { params: e }), (await (await this._channel).presence.get(e)).map((s) => {\n      var c;\n      return {\n        clientId: s.clientId,\n        action: s.action,\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n        data: (c = s.data) == null ? void 0 : c.userCustomData,\n        updatedAt: s.timestamp,\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n        extras: s.extras\n      };\n    });\n  }\n  /**\n   * @inheritDoc\n   */\n  async isUserPresent(e) {\n    return (await (await this._channel).presence.get({ clientId: e })).length > 0;\n  }\n  /**\n   * Method to join room presence, will emit an enter event to all subscribers. Repeat calls will trigger more enter events.\n   * @param {PresenceData} data - The users data, a JSON serializable object that will be sent to all subscribers.\n   * @returns {Promise<void>} or upon failure, the promise will be rejected with an {@link ErrorInfo} object which explains the error.\n   */\n  async enter(e) {\n    this._logger.trace(\"Presence.enter()\", { data: e });\n    const t = {\n      userCustomData: e\n    };\n    return (await this._channel).presence.enterClient(this._clientId, t);\n  }\n  /**\n   * Method to update room presence, will emit an update event to all subscribers. If the user is not present, it will be treated as a join event.\n   * @param {PresenceData} data - The users data, a JSON serializable object that will be sent to all subscribers.\n   * @returns {Promise<void>} or upon failure, the promise will be rejected with an {@link ErrorInfo} object which explains the error.\n   */\n  async update(e) {\n    this._logger.trace(\"Presence.update()\", { data: e });\n    const t = {\n      userCustomData: e\n    };\n    return (await this._channel).presence.updateClient(this._clientId, t);\n  }\n  /**\n   * Method to leave room presence, will emit a leave event to all subscribers. If the user is not present, it will be treated as a no-op.\n   * @param {PresenceData} data - The users data, a JSON serializable object that will be sent to all subscribers.\n   * @returns {Promise<void>} or upon failure, the promise will be rejected with an {@link ErrorInfo} object which explains the error.\n   */\n  async leave(e) {\n    this._logger.trace(\"Presence.leave()\", { data: e });\n    const t = {\n      userCustomData: e\n    };\n    return (await this._channel).presence.leaveClient(this._clientId, t);\n  }\n  subscribe(e, t) {\n    if (this._logger.trace(\"Presence.subscribe(); listenerOrEvents\", { listenerOrEvents: e }), !e && !t)\n      throw this._logger.error(\"could not subscribe to presence; invalid arguments\"), new ably__WEBPACK_IMPORTED_MODULE_0__.ErrorInfo(\"could not subscribe listener: invalid arguments\", 4e4, 400);\n    return t ? (this.on(e, t), {\n      unsubscribe: () => {\n        this._logger.trace(\"Presence.unsubscribe();\", { events: e }), this.off(t);\n      }\n    }) : (this.on(e), {\n      unsubscribe: () => {\n        this._logger.trace(\"Presence.unsubscribe();\"), this.off(e);\n      }\n    });\n  }\n  /**\n   * Unsubscribe all listeners from all presence events.\n   */\n  unsubscribeAll() {\n    this._logger.trace(\"Presence.unsubscribeAll()\"), this.off();\n  }\n  onDiscontinuity(e) {\n    return this._logger.trace(\"Presence.onDiscontinuity();\"), this._discontinuityEmitter.on(e), {\n      off: () => {\n        this._discontinuityEmitter.off(e);\n      }\n    };\n  }\n  discontinuityDetected(e) {\n    this._logger.warn(\"Presence.discontinuityDetected();\", { reason: e }), this._discontinuityEmitter.emit(\"discontinuity\", e);\n  }\n  /**\n   * @inheritDoc ContributesToRoomLifecycle\n   */\n  get attachmentErrorCode() {\n    return m.PresenceAttachmentFailed;\n  }\n  /**\n   * @inheritDoc\n   */\n  get detachmentErrorCode() {\n    return m.PresenceDetachmentFailed;\n  }\n}\nconst ar = new Error(\"request for lock canceled\");\nvar or = function(i, e, t, r) {\n  function s(c) {\n    return c instanceof t ? c : new t(function(u) {\n      u(c);\n    });\n  }\n  return new (t || (t = Promise))(function(c, u) {\n    function g(p) {\n      try {\n        y(r.next(p));\n      } catch (R) {\n        u(R);\n      }\n    }\n    function f(p) {\n      try {\n        y(r.throw(p));\n      } catch (R) {\n        u(R);\n      }\n    }\n    function y(p) {\n      p.done ? c(p.value) : s(p.value).then(g, f);\n    }\n    y((r = r.apply(i, e || [])).next());\n  });\n};\nclass cr {\n  constructor(e, t = ar) {\n    this._value = e, this._cancelError = t, this._queue = [], this._weightedWaiters = [];\n  }\n  acquire(e = 1, t = 0) {\n    if (e <= 0)\n      throw new Error(`invalid weight ${e}: must be positive`);\n    return new Promise((r, s) => {\n      const c = { resolve: r, reject: s, weight: e, priority: t }, u = dt(this._queue, (g) => t <= g.priority);\n      u === -1 && e <= this._value ? this._dispatchItem(c) : this._queue.splice(u + 1, 0, c);\n    });\n  }\n  runExclusive(e) {\n    return or(this, arguments, void 0, function* (t, r = 1, s = 0) {\n      const [c, u] = yield this.acquire(r, s);\n      try {\n        return yield t(c);\n      } finally {\n        u();\n      }\n    });\n  }\n  waitForUnlock(e = 1, t = 0) {\n    if (e <= 0)\n      throw new Error(`invalid weight ${e}: must be positive`);\n    return this._couldLockImmediately(e, t) ? Promise.resolve() : new Promise((r) => {\n      this._weightedWaiters[e - 1] || (this._weightedWaiters[e - 1] = []), hr(this._weightedWaiters[e - 1], { resolve: r, priority: t });\n    });\n  }\n  isLocked() {\n    return this._value <= 0;\n  }\n  getValue() {\n    return this._value;\n  }\n  setValue(e) {\n    this._value = e, this._dispatchQueue();\n  }\n  release(e = 1) {\n    if (e <= 0)\n      throw new Error(`invalid weight ${e}: must be positive`);\n    this._value += e, this._dispatchQueue();\n  }\n  cancel() {\n    this._queue.forEach((e) => e.reject(this._cancelError)), this._queue = [];\n  }\n  _dispatchQueue() {\n    for (this._drainUnlockWaiters(); this._queue.length > 0 && this._queue[0].weight <= this._value; )\n      this._dispatchItem(this._queue.shift()), this._drainUnlockWaiters();\n  }\n  _dispatchItem(e) {\n    const t = this._value;\n    this._value -= e.weight, e.resolve([t, this._newReleaser(e.weight)]);\n  }\n  _newReleaser(e) {\n    let t = !1;\n    return () => {\n      t || (t = !0, this.release(e));\n    };\n  }\n  _drainUnlockWaiters() {\n    if (this._queue.length === 0)\n      for (let e = this._value; e > 0; e--) {\n        const t = this._weightedWaiters[e - 1];\n        t && (t.forEach((r) => r.resolve()), this._weightedWaiters[e - 1] = []);\n      }\n    else {\n      const e = this._queue[0].priority;\n      for (let t = this._value; t > 0; t--) {\n        const r = this._weightedWaiters[t - 1];\n        if (!r)\n          continue;\n        const s = r.findIndex((c) => c.priority <= e);\n        (s === -1 ? r : r.splice(0, s)).forEach((c) => c.resolve());\n      }\n    }\n  }\n  _couldLockImmediately(e, t) {\n    return (this._queue.length === 0 || this._queue[0].priority < t) && e <= this._value;\n  }\n}\nfunction hr(i, e) {\n  const t = dt(i, (r) => e.priority <= r.priority);\n  i.splice(t + 1, 0, e);\n}\nfunction dt(i, e) {\n  for (let t = i.length - 1; t >= 0; t--)\n    if (e(i[t]))\n      return t;\n  return -1;\n}\nvar ur = function(i, e, t, r) {\n  function s(c) {\n    return c instanceof t ? c : new t(function(u) {\n      u(c);\n    });\n  }\n  return new (t || (t = Promise))(function(c, u) {\n    function g(p) {\n      try {\n        y(r.next(p));\n      } catch (R) {\n        u(R);\n      }\n    }\n    function f(p) {\n      try {\n        y(r.throw(p));\n      } catch (R) {\n        u(R);\n      }\n    }\n    function y(p) {\n      p.done ? c(p.value) : s(p.value).then(g, f);\n    }\n    y((r = r.apply(i, e || [])).next());\n  });\n};\nclass lr {\n  constructor(e) {\n    this._semaphore = new cr(1, e);\n  }\n  acquire() {\n    return ur(this, arguments, void 0, function* (e = 0) {\n      const [, t] = yield this._semaphore.acquire(1, e);\n      return t;\n    });\n  }\n  runExclusive(e, t = 0) {\n    return this._semaphore.runExclusive(() => e(), 1, t);\n  }\n  isLocked() {\n    return this._semaphore.isLocked();\n  }\n  waitForUnlock(e = 0) {\n    return this._semaphore.waitForUnlock(1, e);\n  }\n  release() {\n    this._semaphore.isLocked() && this._semaphore.release();\n  }\n  cancel() {\n    return this._semaphore.cancel();\n  }\n}\nvar d = /* @__PURE__ */ ((i) => (i.Initializing = \"initializing\", i.Initialized = \"initialized\", i.Attaching = \"attaching\", i.Attached = \"attached\", i.Detaching = \"detaching\", i.Detached = \"detached\", i.Suspended = \"suspended\", i.Failed = \"failed\", i.Releasing = \"releasing\", i.Released = \"released\", i))(d || {});\nclass dr extends S {\n  /**\n   * Constructs a new `DefaultStatus` instance.\n   * @param logger The logger to use.\n   */\n  constructor(e) {\n    super(), this._state = \"initializing\", this._internalEmitter = new S(), this._logger = e, this._state = \"initializing\", this._error = void 0;\n  }\n  /**\n   * @inheritdoc\n   */\n  get current() {\n    return this._state;\n  }\n  /**\n   * @inheritdoc\n   */\n  get error() {\n    return this._error;\n  }\n  /**\n   * @inheritdoc\n   */\n  onChange(e) {\n    return this.on(e), {\n      off: () => {\n        this.off(e);\n      }\n    };\n  }\n  onChangeOnce(e) {\n    this._internalEmitter.once(e);\n  }\n  /**\n   * @inheritdoc\n   */\n  offAll() {\n    this.off();\n  }\n  setStatus(e) {\n    const t = {\n      current: e.status,\n      error: e.error,\n      previous: this._state\n    };\n    this._state = t.current, this._error = t.error, this._logger.info(\"Room status changed\", t), this._internalEmitter.emit(t.current, t), this.emit(t.current, t);\n  }\n}\nclass gr {\n  /**\n   * Constructs a new `RoomLifecycleManager` instance.\n   * @param status The status to update.\n   * @param contributors The features that contribute to the room status.\n   * @param logger An instance of the Logger.\n   * @param transientDetachTimeout The number of milliseconds to consider a detach to be \"transient\"\n   */\n  constructor(e, t, r, s) {\n    this._mtx = new lr(), this._operationInProgress = !1, this._pendingDiscontinuityEvents = /* @__PURE__ */ new Map(), this._firstAttachesCompleted = /* @__PURE__ */ new Map(), this._releaseInProgress = !1, this._logger = r, this._contributors = t, this._transientDetachTimeouts = /* @__PURE__ */ new Map(), this._status = e, this._status.current !== d.Attached && (this._operationInProgress = !0), this._setupContributorListeners(s);\n  }\n  /**\n   * Sets up listeners for each contributor to the room status.\n   *\n   * @param transientDetachTimeout The number of milliseconds to consider a detach to be \"transient\"\n   */\n  _setupContributorListeners(e) {\n    for (const t of this._contributors)\n      t.channel.on([\"update\"], (r) => {\n        if (!this._firstAttachesCompleted.has(t)) {\n          this._logger.debug(\"RoomLifecycleManager() on update; ignoring update event for feature as first attach\", {\n            channel: t.channel.name,\n            change: r\n          });\n          return;\n        }\n        if (r.resumed) {\n          this._logger.debug(\"RoomLifecycleManager(); update event received but was resume\");\n          return;\n        }\n        if (this._operationInProgress) {\n          if (this._pendingDiscontinuityEvents.has(t)) {\n            this._logger.debug(\"RoomLifecycleManager(); subsequent update event for feature received, ignoring\", {\n              channel: t.channel.name,\n              change: r\n            });\n            return;\n          }\n          this._logger.debug(\n            \"RoomLifecycleManager(); queuing pending update event for feature as operation in progress\",\n            {\n              channel: t.channel.name,\n              change: r\n            }\n          ), this._pendingDiscontinuityEvents.set(t, r.reason);\n          return;\n        }\n        this._logger.debug(\"RoomLifecycleManager(); update event received\", {\n          channel: t.channel.name,\n          change: r\n        }), t.contributor.discontinuityDetected(r.reason);\n      }), t.channel.on(\n        [\"initialized\", \"attaching\", \"attached\", \"detaching\", \"detached\", \"suspended\", \"failed\"],\n        (r) => {\n          if (this._operationInProgress) {\n            this._logger.debug(\n              \"RoomLifecycleManager() on all events; ignoring contributor state change due to operation in progress\",\n              {\n                channel: t.channel.name,\n                current: r.current\n              }\n            ), r.current === d.Attached && !r.resumed && this._firstAttachesCompleted.has(t) && (this._logger.debug(\"RoomLifecycleManager(); resume failure detected\", {\n              channel: t.channel.name\n            }), this._pendingDiscontinuityEvents.has(t) || this._pendingDiscontinuityEvents.set(t, r.reason));\n            return;\n          }\n          if (r.current === d.Failed) {\n            this._logger.debug(\"RoomLifecycleManager(); detected channel failure\", {\n              channel: t.channel.name\n            }), this._clearAllTransientDetachTimeouts(), this._operationInProgress = !0, this._status.setStatus({\n              status: d.Failed,\n              error: r.reason\n            }), this._doChannelWindDown(t).catch((s) => {\n              this._logger.error(\"RoomLifecycleManager(); failed to detach all channels following failure\", {\n                contributor: t.channel.name,\n                error: s\n              });\n            });\n            return;\n          }\n          if (r.current === d.Attached) {\n            this._transientDetachTimeouts.has(t) && (this._logger.debug(\"RoomLifecycleManager(); detected transient detach\", {\n              channel: t.channel.name\n            }), clearTimeout(this._transientDetachTimeouts.get(t)), this._transientDetachTimeouts.delete(t)), this._status.current !== d.Attached && this._contributors.every((s) => s.channel.state === \"attached\") && (this._logger.debug(\"RoomLifecycleManager(); all features attached, setting room status to attached\"), this._status.setStatus({ status: d.Attached }));\n            return;\n          }\n          if (r.current === d.Suspended) {\n            this._logger.debug(\"RoomLifecycleManager(); detected channel suspension\", {\n              channel: t.channel.name\n            }), this._onChannelSuspension(t, r.reason);\n            return;\n          }\n          if (r.current === d.Attaching && !this._transientDetachTimeouts.has(t)) {\n            this._logger.debug(\"RoomLifecycleManager(); detected channel detach\", {\n              channel: t.channel.name\n            });\n            const s = setTimeout(() => {\n              this._status.setStatus({ status: d.Attaching, error: r.reason }), this._transientDetachTimeouts.delete(t), clearTimeout(s);\n            }, e);\n            this._transientDetachTimeouts.set(t, s);\n            return;\n          }\n        }\n      );\n  }\n  /**\n   * _onChannelSuspension is called when a contributing channel enters the suspended state, which means\n   * that the room is also suspended and we should wind-down channels until things recover.\n   *\n   * We transition the room status to the status of this contributor and provide the original\n   * error that caused the detachment.\n   *\n   * @param contributor The contributor that has detached.\n   * @param detachError The error that caused the detachment.\n   */\n  _onChannelSuspension(e, t) {\n    this._logger.debug(\"RoomLifecycleManager._onChannelSuspension();\", {\n      channel: e.channel.name,\n      error: t\n    }), this._operationInProgress = !0, this._clearAllTransientDetachTimeouts(), this._mtx.runExclusive(\n      () => (this._logger.error(\"RoomLifecycleManager._onChannelSuspension(); setting room status to contributor status\", {\n        status: e.channel.state,\n        error: t\n      }), this._status.setStatus({\n        status: e.channel.state,\n        error: t\n      }), this._doRetry(e)),\n      0\n      /* Internal */\n    ).catch((r) => {\n      this._logger.error(\"RoomLifecycleManager._onChannelSuspension(); unexpected error thrown\", { error: r });\n    });\n  }\n  /**\n   * Given some contributor that has entered a suspended state:\n   *\n   * - Wind down any other channels\n   * - Wait for our contributor to recover\n   * - Attach everything else\n   *\n   * Repeat until either of the following happens:\n   *\n   * - Our contributor reattaches and we can attach everything else (repeat with the next contributor to break if necessary)\n   * - The room enters a failed state\n   *\n   * @param contributor The contributor that has entered a suspended state.\n   * @returns A promise that resolves when the room is attached, or the room enters a failed state.\n   */\n  async _doRetry(e) {\n    const t = () => (this._logger.debug(\"RoomLifecycleManager.doAttachWithRetry();\"), this._status.setStatus({ status: d.Attaching }), this._doAttach().then((r) => {\n      var s;\n      if (this._logger.debug(\"RoomLifecycleManager.doAttachWithRetry(); attach result\", {\n        status: r.status,\n        error: r.error,\n        failedFeature: (s = r.failedFeature) == null ? void 0 : s.channel.name\n      }), r.status === d.Failed) {\n        this._mtx.runExclusive(\n          () => this._runDownChannelsOnFailedAttach(),\n          0\n          /* Internal */\n        );\n        return;\n      }\n      if (r.status === d.Suspended) {\n        const c = r.failedFeature;\n        if (!c)\n          throw new ably__WEBPACK_IMPORTED_MODULE_0__.ErrorInfo(\"no failed feature in _doRetry\", m.RoomLifecycleError, 500);\n        return this._logger.debug(\"RoomLifecycleManager.doAttachWithRetry(); feature suspended, retrying attach\", {\n          feature: c.channel.name\n        }), this._doRetry(c).catch();\n      }\n    }));\n    this._logger.debug(\"RoomLifecycleManager._doRetry(); winding down channels except problem\", {\n      channel: e.channel.name\n    });\n    try {\n      await this._doChannelWindDown(e).catch(() => {\n        if (this._status.current === d.Failed)\n          throw new Error(\"room is in a failed state\");\n        return new Promise((r) => {\n          setTimeout(() => {\n            r(this._doChannelWindDown(e));\n          }, 250);\n        });\n      });\n    } catch {\n      return;\n    }\n    return e.channel.state === d.Attached ? (this._logger.debug(\"RoomLifecycleManager._doRetry(); feature reattached, retrying attach\"), t()) : new Promise((r) => {\n      const s = (c) => {\n        if (c.current === d.Attached) {\n          e.channel.off(s), r();\n          return;\n        }\n        if (c.current === d.Failed)\n          throw e.channel.off(s), this._status.setStatus({ status: d.Failed, error: c.reason }), c.reason ?? new ably__WEBPACK_IMPORTED_MODULE_0__.ErrorInfo(\"unknown error in _doRetry\", m.RoomLifecycleError, 500);\n      };\n      e.channel.on(s);\n    }).then(() => (this._logger.debug(\"RoomLifecycleManager._doRetry(); feature reattached via listener, retrying attach\"), t()));\n  }\n  /**\n   * Clears all transient detach timeouts - used when some event supersedes the transient detach such\n   * as a failed channel or suspension.\n   */\n  _clearAllTransientDetachTimeouts() {\n    for (const e of this._transientDetachTimeouts.values())\n      clearTimeout(e);\n    this._transientDetachTimeouts.clear();\n  }\n  /**\n   * Try to attach all the channels in a room.\n   *\n   * If the operation succeeds, the room enters the attached state and this promise resolves.\n   * If a channel enters the suspended state, then we reject, but we will retry after a short delay as is the case\n   * in the core SDK.\n   * If a channel enters the failed state, we reject and then begin to wind down the other channels.\n   */\n  attach() {\n    return this._logger.trace(\"RoomLifecycleManager.attach();\"), this._mtx.runExclusive(\n      async () => {\n        if (this._status.current !== d.Attached) {\n          if (this._status.current === d.Released)\n            throw new ably__WEBPACK_IMPORTED_MODULE_0__.ErrorInfo(\"unable to attach room; room is released\", m.RoomIsReleased, 500);\n          if (this._status.current === d.Releasing)\n            throw new ably__WEBPACK_IMPORTED_MODULE_0__.ErrorInfo(\"unable to attach room; room is releasing\", m.RoomIsReleasing, 500);\n          return this._clearAllTransientDetachTimeouts(), this._operationInProgress = !0, this._status.setStatus({ status: d.Attaching }), this._doAttach().then((e) => {\n            var t;\n            if (e.status === d.Failed)\n              throw this._logger.debug(\"RoomLifecycleManager.attach(); room entered failed, winding down channels\", { result: e }), this._mtx.runExclusive(\n                () => this._runDownChannelsOnFailedAttach(),\n                0\n                /* Internal */\n              ), e.error ?? new ably__WEBPACK_IMPORTED_MODULE_0__.ErrorInfo(\"unknown error in attach\", m.RoomLifecycleError, 500);\n            if (e.status === d.Suspended) {\n              this._logger.debug(\"RoomLifecycleManager.attach(); room entered suspended, will retry\", {\n                error: e.error,\n                contributor: (t = e.failedFeature) == null ? void 0 : t.channel.name\n              });\n              const r = e.failedFeature;\n              throw r ? (this._mtx.runExclusive(\n                () => this._doRetry(r).catch(),\n                0\n                /* Internal */\n              ), e.error ?? new ably__WEBPACK_IMPORTED_MODULE_0__.ErrorInfo(\"unknown error in attach then block\", m.RoomLifecycleError, 500)) : new ably__WEBPACK_IMPORTED_MODULE_0__.ErrorInfo(\"no failed feature in attach\", m.RoomLifecycleError, 500);\n            }\n          });\n        }\n      },\n      2\n      /* AttachOrDetach */\n    );\n  }\n  async _doAttach() {\n    this._logger.trace(\"RoomLifecycleManager._doAttach();\");\n    const e = {\n      status: d.Attached\n    };\n    for (const t of this._contributors)\n      try {\n        this._logger.debug(\"RoomLifecycleManager._doAttach(); attaching\", { channel: t.channel.name }), await t.channel.attach(), this._logger.debug(\"RoomLifecycleManager._doAttach(); attached\", { channel: t.channel.name }), this._firstAttachesCompleted.set(t, !0);\n      } catch (r) {\n        switch (this._logger.error(\"RoomLifecycleManager._doAttach(); failed to attach\", { error: e.error }), e.failedFeature = t, e.error = new ably__WEBPACK_IMPORTED_MODULE_0__.ErrorInfo(\n          \"failed to attach feature\",\n          t.contributor.attachmentErrorCode,\n          500,\n          r\n        ), t.channel.state) {\n          case \"suspended\": {\n            e.status = d.Suspended;\n            break;\n          }\n          case \"failed\": {\n            e.status = d.Failed;\n            break;\n          }\n          default:\n            this._logger.error(\"Unexpected channel state\", { state: t.channel.state }), e.status = d.Failed, e.error = new ably__WEBPACK_IMPORTED_MODULE_0__.ErrorInfo(\n              `unexpected channel state in doAttach ${t.channel.state}`,\n              m.RoomLifecycleError,\n              500,\n              e.error\n            );\n        }\n        return this._status.setStatus(e), e;\n      }\n    this._status.setStatus(e), this._operationInProgress = !1;\n    for (const [t, r] of this._pendingDiscontinuityEvents)\n      t.contributor.discontinuityDetected(r);\n    return this._pendingDiscontinuityEvents.clear(), e;\n  }\n  /**\n   * If we've failed to attach, then we're in the failed state and all that is left to do is to detach all the channels.\n   *\n   * @returns A promise that resolves when all channels are detached. We do not throw.\n   */\n  _runDownChannelsOnFailedAttach() {\n    return this._doChannelWindDown().catch(() => (this._logger.debug(\"RoomLifecycleManager._runDownChannelsOnFailedAttach(); wind down failed, retrying\"), new Promise((e) => {\n      setTimeout(() => {\n        e(this._runDownChannelsOnFailedAttach());\n      }, 250);\n    })));\n  }\n  /**\n   * Detach all features except the one exception provided.\n   * If the room is in a failed state, then all channels should either reach the failed state or be detached.\n   *\n   * @param except The contributor to exclude from the detachment.\n   * @returns A promise that resolves when all channels are detached.\n   */\n  _doChannelWindDown(e) {\n    return Promise.all(\n      this._contributors.map(async (t) => {\n        if (!(t === e && this._status.current !== d.Failed)) {\n          if ((this._status.current === d.Failed || this._status.current === d.Releasing || this._status.current === d.Released) && t.channel.state === \"failed\") {\n            this._logger.debug(\"RoomLifecycleManager._doChannelWindDown(); ignoring failed channel\", {\n              channel: t.channel.name\n            });\n            return;\n          }\n          try {\n            this._logger.debug(\"RoomLifecycleManager._doChannelWindDown(); detaching\", {\n              channel: t.channel.name\n            }), await t.channel.detach(), this._logger.debug(\"RoomLifecycleManager._doChannelWindDown(); detached\", {\n              channel: t.channel.name\n            });\n          } catch (r) {\n            if (t.channel.state === \"failed\" && this._status.current !== d.Failed && this._status.current !== d.Releasing && this._status.current !== d.Released) {\n              const s = new ably__WEBPACK_IMPORTED_MODULE_0__.ErrorInfo(\n                \"failed to detach feature\",\n                t.contributor.detachmentErrorCode,\n                500,\n                r\n              );\n              throw this._status.setStatus({ status: d.Failed, error: s }), s;\n            }\n            throw new ably__WEBPACK_IMPORTED_MODULE_0__.ErrorInfo(\"detach failure, retry\", -1, -1, r);\n          }\n        }\n      })\n    );\n  }\n  /**\n   * Detaches the room. If the room is already detached, this is a no-op.\n   * If one of the channels fails to detach, the room status will be set to failed.\n   * If the room is in the process of detaching, this will wait for the detachment to complete.\n   *\n   * @returns A promise that resolves when the room is detached.\n   */\n  detach() {\n    return this._logger.trace(\"RoomLifecycleManager.detach();\"), this._mtx.runExclusive(\n      async () => {\n        if (this._status.current !== d.Detached) {\n          if (this._status.current === d.Released)\n            throw new ably__WEBPACK_IMPORTED_MODULE_0__.ErrorInfo(\"unable to detach room; room is released\", m.RoomIsReleased, 500);\n          if (this._status.current === d.Releasing)\n            throw new ably__WEBPACK_IMPORTED_MODULE_0__.ErrorInfo(\"unable to detach room; room is releasing\", m.RoomIsReleasing, 500);\n          if (this._status.current === d.Failed)\n            throw new ably__WEBPACK_IMPORTED_MODULE_0__.ErrorInfo(\"unable to detach room; room has failed\", m.RoomInFailedState, 500);\n          return this._operationInProgress = !0, this._clearAllTransientDetachTimeouts(), this._status.setStatus({ status: d.Detaching }), this._doDetach();\n        }\n      },\n      2\n      /* AttachOrDetach */\n    );\n  }\n  /**\n   * Perform a detach.\n   *\n   * If detaching a channel fails, we should retry until every channel is either in the detached state, or in the failed state.\n   */\n  async _doDetach() {\n    this._logger.trace(\"RoomLifecycleManager._doDetach();\");\n    let e, t = !1;\n    for (; !t; ) {\n      try {\n        this._logger.debug(\"RoomLifecycleManager._doDetach(); detaching all channels\"), await this._doChannelWindDown();\n      } catch (r) {\n        if (this._logger.error(\"RoomLifecycleManager._doDetach(); failed to detach all channels\", { error: r }), r instanceof ably__WEBPACK_IMPORTED_MODULE_0__.ErrorInfo && r.code === -1) {\n          this._logger.debug(\"RoomLifecycleManager._doDetach(); retrying detach\", { error: r }), await new Promise((s) => setTimeout(s, 250));\n          continue;\n        }\n        e || (this._logger.debug(\"RoomLifecycleManager._doDetach(); channel failed on detach\", { error: r }), e = r), await new Promise((s) => setTimeout(s, 250)), this._logger.debug(\"RoomLifecycleManager._doDetach(); retrying detach after failed channel\");\n        continue;\n      }\n      t = !0;\n    }\n    if (this._status.current !== d.Failed) {\n      this._status.setStatus({ status: d.Detached });\n      return;\n    }\n    throw e ?? new ably__WEBPACK_IMPORTED_MODULE_0__.ErrorInfo(\"unknown error in _doDetach\", m.RoomLifecycleError, 500);\n  }\n  /**\n   * Releases the room. If the room is already released, this is a no-op.\n   * Any channel that detaches into the failed state is ok. But any channel that fails to detach\n   * will cause the room status to be set to failed.\n   *\n   * @returns Returns a promise that resolves when the room is released. If a channel detaches into a non-terminated\n   * state (e.g. attached), the promise will reject.\n   */\n  release() {\n    return this._logger.trace(\"RoomLifecycleManager.release();\"), this._mtx.runExclusive(\n      async () => {\n        if (this._status.current !== d.Released) {\n          if (this._status.current === d.Detached) {\n            this._status.setStatus({ status: d.Released });\n            return;\n          }\n          return this._releaseInProgress ? new Promise((e, t) => {\n            this._status.onChangeOnce((r) => {\n              if (r.current === d.Released) {\n                e();\n                return;\n              }\n              this._logger.error(\"RoomLifecycleManager.release(); expected a non-attached state\", r), t(\n                new ably__WEBPACK_IMPORTED_MODULE_0__.ErrorInfo(\n                  \"failed to release room; existing attempt failed\",\n                  m.PreviousOperationFailed,\n                  500,\n                  r.error\n                )\n              );\n            });\n          }) : (this._clearAllTransientDetachTimeouts(), this._operationInProgress = !0, this._releaseInProgress = !0, this._status.setStatus({ status: d.Releasing }), this._logger.debug(\"RoomLifecycleManager.release(); releasing room\"), this._releaseChannels());\n        }\n      },\n      1\n      /* Release */\n    );\n  }\n  /**\n   *  Releases the room by detaching all channels. If the release operation fails, we wait\n   *  a short period and then try again.\n   */\n  _releaseChannels() {\n    return this._doRelease().catch((e) => (this._logger.error(\"RoomLifecycleManager._releaseChannels(); failed to release room, retrying\", { error: e }), new Promise((t) => {\n      setTimeout(() => {\n        t(this._releaseChannels());\n      }, 250);\n    })));\n  }\n  /**\n   * Performs the release operation. This will detach all channels in the room that aren't\n   * already detached or in the failed state.\n   */\n  _doRelease() {\n    return Promise.all(\n      this._contributors.map(async (e) => {\n        if (e.channel.state === \"failed\") {\n          this._logger.debug(\"RoomLifecycleManager.release(); ignoring failed channel\", {\n            channel: e.channel.name\n          });\n          return;\n        }\n        if (e.channel.state === \"detached\") {\n          this._logger.debug(\"RoomLifecycleManager.release(); ignoring detached channel\", {\n            channel: e.channel.name\n          });\n          return;\n        }\n        try {\n          this._logger.debug(\"RoomLifecycleManager.release(); detaching\", {\n            channel: e.channel.name\n          }), await e.channel.detach(), this._logger.debug(\"RoomLifecycleManager.release(); detached\", {\n            channel: e.channel.name\n          });\n        } catch (t) {\n          throw this._logger.error(\"RoomLifecycleManager.release(); failed to detach\", {\n            error: t,\n            channel: e.channel.name,\n            state: e.channel.state\n          }), t;\n        }\n      })\n    ).then(() => {\n      this._releaseInProgress = !1, this._status.setStatus({ status: d.Released });\n    });\n  }\n}\nconst Cr = {\n  /**\n   * The default presence options for a chat room.\n   */\n  presence: {\n    /**\n     * The client should be able to enter presence.\n     */\n    enter: !0,\n    /**\n     * The client should be able to subscribe to presence.\n     */\n    subscribe: !0\n  },\n  /**\n   * The default typing options for a chat room.\n   */\n  typing: {\n    /**\n     * The default timeout for typing events in milliseconds.\n     */\n    timeoutMs: 1e4\n  },\n  /**\n   * The default reactions options for a chat room.\n   */\n  reactions: {},\n  /**\n   * The default occupancy options for a chat room.\n   */\n  occupancy: {}\n}, fr = (i) => new ably__WEBPACK_IMPORTED_MODULE_0__.ErrorInfo(`invalid room configuration: ${i}`, 40001, 400), _r = (i) => {\n  if (i.typing && i.typing.timeoutMs <= 0)\n    throw fr(\"typing timeout must be greater than 0\");\n};\nclass mr {\n  constructor(e, t, r, s, c, u) {\n    this.type = e, this.clientId = t, this.createdAt = r, this.isSelf = s, this.metadata = c, this.headers = u, Object.freeze(this);\n  }\n}\nfunction gt(i, e) {\n  var r;\n  const t = i;\n  if (!t.data)\n    throw new ably__WEBPACK_IMPORTED_MODULE_0__.ErrorInfo(\"received incoming message without data\", 5e4, 500);\n  if (!t.data.type || typeof t.data.type != \"string\")\n    throw new ably__WEBPACK_IMPORTED_MODULE_0__.ErrorInfo(\"invalid reaction message with no type\", 5e4, 500);\n  if (!t.clientId)\n    throw new ably__WEBPACK_IMPORTED_MODULE_0__.ErrorInfo(\"received incoming message without clientId\", 5e4, 500);\n  if (!t.timestamp)\n    throw new ably__WEBPACK_IMPORTED_MODULE_0__.ErrorInfo(\"received incoming message without timestamp\", 5e4, 500);\n  return new mr(\n    t.data.type,\n    t.clientId,\n    new Date(t.timestamp),\n    e ? e === t.clientId : !1,\n    t.data.metadata ?? {},\n    ((r = t.extras) == null ? void 0 : r.headers) ?? {}\n  );\n}\nclass pr extends S {\n  /**\n   * Constructs a new `DefaultRoomReactions` instance.\n   * @param roomId The unique identifier of the room.\n   * @param realtime An instance of the Ably Realtime client.\n   * @param clientId The client ID of the user.\n   * @param logger An instance of the Logger.\n   * @param initAfter A promise that is awaited before creating any channels.\n   */\n  constructor(e, t, r, s, c) {\n    super(), this._discontinuityEmitter = W(), this._forwarder = (u) => {\n      const g = this._parseNewReaction(u, this._clientId);\n      g && this.emit(z.Reaction, g);\n    }, this._channel = c.then(() => this._makeChannel(e, t)), this._channel.catch((u) => {\n      s.debug(\"RoomReactions: channel initialization canceled\", { roomId: e, error: u });\n    }), this._clientId = r, this._logger = s;\n  }\n  /**\n   * Creates the realtime channel for room reactions. Called after initAfter is resolved.\n   */\n  _makeChannel(e, t) {\n    const r = q(`${e}::$chat::$reactions`, t);\n    return me({\n      listener: this._forwarder.bind(this),\n      events: [z.Reaction],\n      channel: r\n    }), r;\n  }\n  /**\n   * @inheritDoc Reactions\n   */\n  send(e) {\n    this._logger.trace(\"RoomReactions.send();\", e);\n    const { type: t, metadata: r, headers: s } = e;\n    if (!t)\n      return Promise.reject(new ably__WEBPACK_IMPORTED_MODULE_0__.ErrorInfo(\"unable to send reaction; type not set and it is required\", 40001, 400));\n    if (r && r[\"ably-chat\"] !== void 0)\n      return Promise.reject(\n        new ably__WEBPACK_IMPORTED_MODULE_0__.ErrorInfo(\"unable to send reaction; metadata cannot use reserved key 'ably-chat'\", 40001, 400)\n      );\n    if (s) {\n      for (const g of Object.keys(s))\n        if (g.startsWith(\"ably-chat\"))\n          return Promise.reject(\n            new ably__WEBPACK_IMPORTED_MODULE_0__.ErrorInfo(\n              \"unable to send reaction; headers cannot have any key starting with reserved prefix 'ably-chat'\",\n              40001,\n              400\n            )\n          );\n    }\n    const c = {\n      type: t,\n      metadata: r ?? {}\n    }, u = {\n      name: z.Reaction,\n      data: c,\n      extras: {\n        headers: s ?? {}\n      }\n    };\n    return this._channel.then((g) => g.publish(u));\n  }\n  /**\n   * @inheritDoc Reactions\n   */\n  subscribe(e) {\n    return this._logger.trace(\"RoomReactions.subscribe();\"), this.on(e), {\n      unsubscribe: () => {\n        this._logger.trace(\"RoomReactions.unsubscribe();\"), this.off(e);\n      }\n    };\n  }\n  /**\n   * @inheritDoc Reactions\n   */\n  unsubscribeAll() {\n    this._logger.trace(\"RoomReactions.unsubscribeAll();\"), this.off();\n  }\n  get channel() {\n    return this._channel;\n  }\n  _parseNewReaction(e, t) {\n    try {\n      return gt(e, t);\n    } catch (r) {\n      this._logger.error(\"failed to parse incoming reaction;\", { inbound: e, error: r });\n    }\n  }\n  discontinuityDetected(e) {\n    this._logger.warn(\"RoomReactions.discontinuityDetected();\", { reason: e }), this._discontinuityEmitter.emit(\"discontinuity\", e);\n  }\n  onDiscontinuity(e) {\n    return this._logger.trace(\"RoomReactions.onDiscontinuity();\"), this._discontinuityEmitter.on(e), {\n      off: () => {\n        this._discontinuityEmitter.off(e);\n      }\n    };\n  }\n  /**\n   * @inheritdoc ContributesToRoomLifecycle\n   */\n  get attachmentErrorCode() {\n    return m.ReactionsAttachmentFailed;\n  }\n  /**\n   * @inheritdoc ContributesToRoomLifecycle\n   */\n  get detachmentErrorCode() {\n    return m.ReactionsDetachmentFailed;\n  }\n}\nconst yr = 1500, wr = 3e4, br = 5;\nclass vr extends S {\n  /**\n   * Constructs a new `DefaultTyping` instance.\n   * @param roomId The unique identifier of the room.\n   * @param options The options for typing in the room.\n   * @param realtime An instance of the Ably Realtime client.\n   * @param clientId The client ID of the user.\n   * @param logger An instance of the Logger.\n   * @param initAfter A promise that is awaited before creating any channels.\n   */\n  constructor(e, t, r, s, c, u) {\n    super(), this._discontinuityEmitter = W(), this._receivedEventNumber = 0, this._triggeredEventNumber = 0, this._currentlyTyping = /* @__PURE__ */ new Set(), this._numRetries = 0, this._internalSubscribeToEvents = (g) => {\n      if (!g.clientId) {\n        this._logger.error(\"unable to handle typing event; no clientId\", { member: g });\n        return;\n      }\n      this._receivedEventNumber += 1, this._retryTimeout && (clearTimeout(this._retryTimeout), this._retryTimeout = void 0, this._numRetries = 0), this._getAndEmit(this._receivedEventNumber);\n    }, this._clientId = s, this._channel = u.then(() => this._makeChannel(e, r)), this._channel.catch((g) => {\n      c.debug(\"Typing: channel initialization canceled\", { roomId: e, error: g });\n    }), this._typingTimeoutMs = t.timeoutMs, this._logger = c;\n  }\n  /**\n   * Creates the realtime channel for typing indicators. Called after initAfter is resolved.\n   */\n  _makeChannel(e, t) {\n    const r = q(`${e}::$chat::$typingIndicators`, t);\n    return ut({\n      listener: this._internalSubscribeToEvents.bind(this),\n      channel: r\n    }), r;\n  }\n  /**\n   * @inheritDoc\n   */\n  get() {\n    return this._channel.then(\n      (e) => e.presence.get().then((t) => new Set(t.map((r) => r.clientId)))\n    );\n  }\n  /**\n   * @inheritDoc\n   */\n  get channel() {\n    return this._channel;\n  }\n  /**\n   * Start the typing timeout timer. This will emit a typingStopped event if the timer expires.\n   */\n  _startTypingTimer() {\n    this._logger.trace(\"DefaultTyping.startTypingTimer();\"), this._timerId = setTimeout(() => {\n      this._logger.debug(\"DefaultTyping.startTypingTimer(); timeout expired\"), this.stop();\n    }, this._typingTimeoutMs);\n  }\n  /**\n   * @inheritDoc\n   */\n  async start() {\n    if (this._logger.trace(\"DefaultTyping.start();\"), this._timerId) {\n      this._logger.debug(\"DefaultTyping.start(); already typing, resetting timer\"), clearTimeout(this._timerId), this._startTypingTimer();\n      return;\n    }\n    return this._startTypingTimer(), (await this.channel).presence.enterClient(this._clientId).then();\n  }\n  /**\n   * @inheritDoc\n   */\n  async stop() {\n    return this._logger.trace(\"DefaultTyping.stop();\"), this._timerId && (clearTimeout(this._timerId), this._timerId = void 0), (await this.channel).presence.leaveClient(this._clientId);\n  }\n  /**\n   * @inheritDoc\n   */\n  subscribe(e) {\n    return this._logger.trace(\"DefaultTyping.subscribe();\"), this.on(e), {\n      unsubscribe: () => {\n        this._logger.trace(\"DefaultTyping.unsubscribe();\"), this.off(e);\n      }\n    };\n  }\n  /**\n   * @inheritDoc\n   */\n  unsubscribeAll() {\n    this._logger.trace(\"DefaultTyping.unsubscribeAll();\"), this.off();\n  }\n  _getAndEmit(e) {\n    this.get().then((t) => {\n      this._retryTimeout && (clearTimeout(this._retryTimeout), this._retryTimeout = void 0, this._numRetries = 0), !(this._triggeredEventNumber >= e) && (this._triggeredEventNumber = e, !j(this._currentlyTyping, t) && (this._currentlyTyping = t, this.emit(ct.Changed, {\n        currentlyTyping: new Set(t)\n      })));\n    }).catch((t) => {\n      const r = this._numRetries < br;\n      if (this._logger.error(\"Error fetching currently typing clientIds set.\", {\n        error: t,\n        willReattempt: r\n      }), !r || this._retryTimeout)\n        return;\n      const s = Math.min(\n        wr,\n        yr * Math.pow(2, this._numRetries)\n      );\n      this._numRetries += 1, this._retryTimeout = setTimeout(() => {\n        this._retryTimeout = void 0, this._receivedEventNumber++, this._getAndEmit(this._receivedEventNumber);\n      }, s);\n    });\n  }\n  onDiscontinuity(e) {\n    return this._logger.trace(\"DefaultTyping.onDiscontinuity();\"), this._discontinuityEmitter.on(e), {\n      off: () => {\n        this._discontinuityEmitter.off(e);\n      }\n    };\n  }\n  discontinuityDetected(e) {\n    this._logger.warn(\"DefaultTyping.discontinuityDetected();\", { reason: e }), this._discontinuityEmitter.emit(\"discontinuity\", e);\n  }\n  get timeoutMs() {\n    return this._typingTimeoutMs;\n  }\n  /**\n   * @inheritdoc ContributesToRoomLifecycle\n   */\n  get attachmentErrorCode() {\n    return m.TypingAttachmentFailed;\n  }\n  /**\n   * @inheritdoc ContributesToRoomLifecycle\n   */\n  get detachmentErrorCode() {\n    return m.TypingDetachmentFailed;\n  }\n}\nfunction Rr(i) {\n  return new Promise((e) => {\n    i.then(() => {\n      e();\n    }).catch(() => {\n      e();\n    });\n  });\n}\nfunction at(i) {\n  let e;\n  const t = (s) => e ? (e(s), e = void 0, !0) : !1;\n  return { promise: new Promise((s, c) => {\n    e = c, i.then((u) => {\n      e && (e = void 0, s(u));\n    }).catch((u) => {\n      e && (e = void 0, c(u));\n    });\n  }), reject: t };\n}\nclass Ar {\n  /**\n   * Constructs a new Room instance.\n   *\n   * @param roomId The unique identifier of the room.\n   * @param options The options for the room.\n   * @param realtime An instance of the Ably Realtime client.\n   * @param chatApi An instance of the ChatApi.\n   * @param logger An instance of the Logger.\n   * @param initAfter The room will wait for this promise to finish before initializing\n   */\n  constructor(e, t, r, s, c, u) {\n    _r(t), c.debug(\"Room();\", { roomId: e, options: t }), this._roomId = e, this._options = t, this._chatApi = s, this._logger = c, this._status = new dr(c);\n    const g = at(Rr(u)), f = g.promise;\n    this._finalizer = () => (g.reject(\n      new ably__WEBPACK_IMPORTED_MODULE_0__.ErrorInfo(\"Room released before initialization started\", m.RoomIsReleased, 400)\n    ) && this._status.setStatus({ status: d.Released }), u), this._messages = new rr(\n      e,\n      r,\n      this._chatApi,\n      r.auth.clientId,\n      c,\n      f\n    );\n    const y = [this._messages];\n    t.presence && (this._logger.debug(\"enabling presence on room\", { roomId: e }), this._presence = new sr(\n      e,\n      t,\n      r,\n      r.auth.clientId,\n      c,\n      f\n    ), y.push(this._presence)), t.typing && (this._logger.debug(\"enabling typing on room\", { roomId: e }), this._typing = new vr(\n      e,\n      t.typing,\n      r,\n      r.auth.clientId,\n      c,\n      f\n    ), y.push(this._typing)), t.reactions && (this._logger.debug(\"enabling reactions on room\", { roomId: e }), this._reactions = new pr(e, r, r.auth.clientId, c, f), y.push(this._reactions)), t.occupancy && (this._logger.debug(\"enabling occupancy on room\", { roomId: e }), this._occupancy = new ir(e, r, this._chatApi, c, f), y.push(this._occupancy)), this._asyncOpsAfter = this._setupAsyncRoomInit(y, f, r), this._asyncOpsAfter.catch((p) => {\n      this._logger.debug(\"Room initialization was prevented before finishing\", { error: p, roomId: e });\n    });\n  }\n  /**\n   * Runs async room initialization and waits for all features to finish initializing. Handles calls to release()\n   * at different points in the initialization process.\n   *\n   * @param features Array of all enabled room features that are to be initialized with channels.\n   * @param initFeaturesAfter Initialization of features starts after this promise resolves\n   * @param realtime The Ably.Realtime instance used by this room\n   * @returns A promise that is resolved when the room is initialized or rejected if the room is released before initialization finishes.\n   */\n  _setupAsyncRoomInit(e, t, r) {\n    const s = at(\n      t.then(() => {\n        let c;\n        const u = new Promise((f) => {\n          c = f;\n        });\n        this._finalizer = () => (s.reject(\n          new ably__WEBPACK_IMPORTED_MODULE_0__.ErrorInfo(\"Room released before initialization finished\", m.RoomIsReleased, 400)\n        ), u.then((f) => f()));\n        const g = e.map((f) => f.channel.then((y) => ({\n          channel: y,\n          contributor: f\n        })));\n        return Promise.all(g).then((f) => {\n          const y = new gr(this._status, f.toReversed(), this._logger, 5e3);\n          this._lifecycleManager = y;\n          let p = !1;\n          c(() => p ? Promise.resolve() : (p = !0, y.release().then(() => {\n            for (const R of f)\n              r.channels.release(R.channel.name);\n          }))), this._status.setStatus({ status: d.Initialized });\n        }).catch((f) => {\n          throw c(() => Promise.resolve()), this._logger.error(\"Room features initialization failed\", { error: f, roomId: this.roomId }), this._status.setStatus({\n            status: d.Failed,\n            error: new ably__WEBPACK_IMPORTED_MODULE_0__.ErrorInfo(\"Room features initialization failed.\", 4e4, 400, f)\n          }), f;\n        });\n      })\n    );\n    return s.promise;\n  }\n  /**\n   * @inheritdoc Room\n   */\n  get roomId() {\n    return this._roomId;\n  }\n  /**\n   * @inheritDoc Room\n   */\n  options() {\n    return Zn(this._options);\n  }\n  /**\n   * @inheritdoc Room\n   */\n  get messages() {\n    return this._messages;\n  }\n  /**\n   * @inheritdoc Room\n   */\n  get presence() {\n    if (!this._presence)\n      throw this._logger.error(\"Presence is not enabled for this room\"), new ably__WEBPACK_IMPORTED_MODULE_0__.ErrorInfo(\"Presence is not enabled for this room\", 4e4, 400);\n    return this._presence;\n  }\n  /**\n   * @inheritdoc Room\n   */\n  get reactions() {\n    if (!this._reactions)\n      throw this._logger.error(\"Reactions are not enabled for this room\"), new ably__WEBPACK_IMPORTED_MODULE_0__.ErrorInfo(\"Reactions are not enabled for this room\", 4e4, 400);\n    return this._reactions;\n  }\n  /**\n   * @inheritdoc Room\n   */\n  get typing() {\n    if (!this._typing)\n      throw this._logger.error(\"Typing is not enabled for this room\"), new ably__WEBPACK_IMPORTED_MODULE_0__.ErrorInfo(\"Typing is not enabled for this room\", 4e4, 400);\n    return this._typing;\n  }\n  /**\n   * @inheritdoc Room\n   */\n  get occupancy() {\n    if (!this._occupancy)\n      throw this._logger.error(\"Occupancy is not enabled for this room\"), new ably__WEBPACK_IMPORTED_MODULE_0__.ErrorInfo(\"Occupancy is not enabled for this room\", 4e4, 400);\n    return this._occupancy;\n  }\n  /**\n   * @inheritdoc Room\n   */\n  get status() {\n    return this._status;\n  }\n  /**\n   * @inheritdoc Room\n   */\n  async attach() {\n    return this._logger.trace(\"Room.attach();\"), this._asyncOpsAfter.then(() => {\n      var e;\n      return (e = this._lifecycleManager) == null ? void 0 : e.attach();\n    });\n  }\n  /**\n   * @inheritdoc Room\n   */\n  async detach() {\n    return this._logger.trace(\"Room.detach();\"), this._asyncOpsAfter.then(() => {\n      var e;\n      return (e = this._lifecycleManager) == null ? void 0 : e.detach();\n    });\n  }\n  /**\n   * Releases resources associated with the room.\n   * We guarantee that this does not throw an error.\n   */\n  release() {\n    return this._logger.trace(\"Room.release();\"), this._finalizer();\n  }\n  /**\n   * @internal\n   *\n   * Returns a promise that is resolved when the room is initialized or\n   * rejected if the room gets released before initialization.\n   */\n  initializationStatus() {\n    return this._asyncOpsAfter;\n  }\n}\nclass Er {\n  /**\n   * Constructs a new Rooms instance.\n   *\n   * @param realtime An instance of the Ably Realtime client.\n   * @param clientOptions The client options from the chat instance.\n   * @param logger An instance of the Logger.\n   */\n  constructor(e, t, r) {\n    this._rooms = /* @__PURE__ */ new Map(), this._releasing = /* @__PURE__ */ new Map(), this._realtime = e, this._chatApi = new Xn(e, r), this._clientOptions = t, this._logger = r;\n  }\n  /**\n   * @inheritDoc\n   */\n  get(e, t) {\n    this._logger.trace(\"Rooms.get();\", { roomId: e });\n    const r = this._rooms.get(e);\n    if (r) {\n      if (!j(r.options(), t))\n        throw new ably__WEBPACK_IMPORTED_MODULE_0__.ErrorInfo(\"Room already exists with different options\", 4e4, 400);\n      return r;\n    }\n    const s = this._releasing.get(e), c = s ? s.promise : Promise.resolve(), u = new Ar(e, t, this._realtime, this._chatApi, this._logger, c);\n    return this._rooms.set(e, u), u;\n  }\n  /**\n   * @inheritDoc\n   */\n  get clientOptions() {\n    return this._clientOptions;\n  }\n  /**\n   * @inheritDoc\n   */\n  release(e) {\n    this._logger.trace(\"Rooms.release();\", { roomId: e });\n    const t = this._rooms.get(e), r = this._releasing.get(e);\n    if (!t)\n      return r ? r.promise : Promise.resolve();\n    this._rooms.delete(e);\n    let s = 0;\n    r && (s = r.count + 1);\n    const c = t.release().then(() => {\n      this._logger.debug(\"Rooms.release(); room released\", { roomId: e });\n      const u = this._releasing.get(e);\n      u && u.count < s && this._releasing.delete(e);\n    });\n    return this._releasing.set(e, { count: s, promise: c }), c;\n  }\n}\nclass Pr {\n  /**\n   * Constructor for Chat\n   * @param realtime - The Ably Realtime client.\n   * @param clientOptions - The client options.\n   */\n  constructor(e, t) {\n    this._realtime = e, this._clientOptions = Bn(t), this._logger = $n(this._clientOptions), this._connection = new Gn(new Qn(e, this._logger)), this._rooms = new Er(e, this._clientOptions, this._logger), this._addAgent(\"chat-js\"), this._logger.trace(`ably chat client version ${ge}; initialized`);\n  }\n  /**\n   * Returns the rooms object, which provides access to chat rooms.\n   *\n   * @returns The rooms object.\n   */\n  get rooms() {\n    return this._rooms;\n  }\n  /**\n   * Returns the underlying connection to Ably, which can be used to monitor the clients\n   * connection to Ably servers.\n   *\n   * @returns The connection object.\n   */\n  get connection() {\n    return this._connection;\n  }\n  /**\n   * Returns the clientId of the current client.\n   *\n   * @returns The clientId.\n   */\n  get clientId() {\n    return this._realtime.auth.clientId;\n  }\n  /**\n   * Returns the underlying Ably Realtime client.\n   * @returns The Ably Realtime client.\n   */\n  get realtime() {\n    return this._realtime;\n  }\n  /**\n   * Returns the resolved client options for the client, including any defaults that have been set.\n   * @returns The client options.\n   */\n  get clientOptions() {\n    return this._clientOptions;\n  }\n  /**\n   * Returns the logger instance for the client.\n   * @internal\n   * @returns The logger instance.\n   */\n  get logger() {\n    return this._logger;\n  }\n  /**\n   * Adds additional agent information to the client.\n   * Used internally to add React-specific agent information.\n   * @param agent - The agent to add.\n   * @internal\n   */\n  addReactAgent() {\n    this._addAgent(\"chat-react\");\n  }\n  /**\n   * Sets the agent string for the client.\n   * @param agent - The agent to add.\n   * @internal\n   */\n  _addAgent(e) {\n    const t = this._realtime;\n    t.options.agents = { ...t.options.agents ?? t.options.agents, [e]: ge };\n  }\n}\nvar Ir = /* @__PURE__ */ ((i) => (i.ChatMessage = \"chatMessage\", i.Reaction = \"reaction\", i))(Ir || {});\nfunction pe(i) {\n  if (typeof i != \"object\" || i === null)\n    throw new ably__WEBPACK_IMPORTED_MODULE_0__.ErrorInfo(\"invalid encoded type; encoded is not type object or is null\", 4e4, 400);\n  if (!(\"name\" in i) || typeof i.name != \"string\")\n    throw new ably__WEBPACK_IMPORTED_MODULE_0__.ErrorInfo(\"invalid encoded inbound message; message does not have a valid name field\", 4e4, 400);\n}\nfunction xr(i) {\n  return pe(i), Sr(i);\n}\nasync function Or(i) {\n  pe(i);\n  const e = await ably__WEBPACK_IMPORTED_MODULE_0__.Realtime.Message.fromEncoded(i);\n  return Mr(e);\n}\nasync function Fr(i) {\n  pe(i);\n  const e = await ably__WEBPACK_IMPORTED_MODULE_0__.Realtime.Message.fromEncoded(i);\n  return Tr(e);\n}\nfunction Sr(i) {\n  switch (i.name) {\n    case L.Created:\n      return \"chatMessage\";\n    case z.Reaction:\n      return \"reaction\";\n    case void 0:\n      throw new ably__WEBPACK_IMPORTED_MODULE_0__.ErrorInfo(\"received incoming message without event name\", 4e4, 400);\n    default:\n      throw new ably__WEBPACK_IMPORTED_MODULE_0__.ErrorInfo(`unknown message type: ${i.name}`, 4e4, 400);\n  }\n}\nfunction Tr(i) {\n  return gt(i);\n}\nfunction Mr(i) {\n  const e = i.id.split(\":\")[2];\n  return ht(e, i);\n}\n\n//# sourceMappingURL=ably-chat.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0BhYmx5L2NoYXQvZGlzdC9jaGF0L2FibHktY2hhdC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUEwQjtBQUMxQiw4SkFBOEo7QUFDOUo7QUFDQSw4QkFBOEIsa0JBQWtCLGdCQUFnQiwyQ0FBMkMsSUFBSSwyQkFBMkIsYUFBYSxFQUFFLEVBQUUsRUFBRTtBQUM3SjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiwyQ0FBVyx1QkFBdUIsRUFBRTtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQywwQkFBMEI7QUFDM0I7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVywwQ0FBVTtBQUNyQjtBQUNBO0FBQ0E7QUFDQSxzTkFBc047QUFDdE47QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsU0FBUztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLFNBQVM7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsU0FBUztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixLQUFLO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixTQUFTO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCLG1DQUFtQyxTQUFTO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSw0aUNBQTRpQztBQUM1aUMsaUVBQWlFLEdBQUcsVUFBVSxVQUFVLGFBQWE7QUFDckc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsaUJBQWlCLEVBQUU7QUFDcEIsMkVBQTJFLCtIQUErSCwyRUFBMkUsd0VBQXdFO0FBQzdWO0FBQ0E7QUFDQTtBQUNBLGNBQWMsMkNBQVc7QUFDekI7QUFDQSxjQUFjLDJDQUFXO0FBQ3pCO0FBQ0EsY0FBYywyQ0FBVztBQUN6QjtBQUNBLGNBQWMsMkNBQVc7QUFDekI7QUFDQSxjQUFjLDJDQUFXO0FBQ3pCO0FBQ0EsY0FBYywyQ0FBVztBQUN6QjtBQUNBLGNBQWMsMkNBQVc7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RCxxQkFBcUI7QUFDbEYsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRkFBZ0Y7QUFDaEY7QUFDQTtBQUNBO0FBQ0Esa0VBQWtFO0FBQ2xFLGFBQWEsMkNBQVc7QUFDeEIsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtFQUFrRTtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsMkNBQVc7QUFDeEIsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzRUFBc0U7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQiwyRUFBMkUsa0NBQWtDLDJDQUFXO0FBQ3hIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJGQUEyRjtBQUMzRjtBQUNBLE9BQU8sbUNBQW1DLHVDQUF1QyxvRUFBb0U7QUFDckosWUFBWSwyQ0FBVztBQUN2QjtBQUNBLGtFQUFrRTtBQUNsRTtBQUNBLFNBQVMsbUNBQW1DLHVDQUF1QyxvRUFBb0U7QUFDdkosY0FBYywyQ0FBVztBQUN6QjtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRDtBQUNoRDtBQUNBO0FBQ0E7QUFDQSxjQUFjLGlCQUFpQjtBQUMvQixjQUFjLGlCQUFpQjtBQUMvQjtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDLFlBQVksbUNBQW1DO0FBQy9DO0FBQ0EsZ0JBQWdCLDJDQUFXLDBCQUEwQjtBQUNyRDtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsMkNBQVc7QUFDL0IscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThELGtDQUFrQztBQUNoRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBLGdEQUFnRDtBQUNoRDtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQSwrRkFBK0Y7QUFDL0YsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtEO0FBQ2xEO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQ7QUFDQSxLQUFLO0FBQ0wsWUFBWSxVQUFVO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IscUJBQXFCO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCwyQkFBMkIsU0FBUztBQUN6RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLDJEQUEyRCxLQUFLLGtDQUFrQztBQUNsRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0QsS0FBSyxXQUFXO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQ7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RCxxQkFBcUI7QUFDbkYsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsVUFBVSx3QkFBd0I7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRDtBQUNyRDtBQUNBLG9EQUFvRDtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRDtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTREO0FBQzVEO0FBQ0E7QUFDQSxZQUFZLGFBQWE7QUFDekI7QUFDQSw0REFBNEQ7QUFDNUQ7QUFDQTtBQUNBLFlBQVkscUNBQXFDO0FBQ2pEO0FBQ0EsNERBQTREO0FBQzVEO0FBQ0E7QUFDQTtBQUNBLDREQUE0RDtBQUM1RDtBQUNBO0FBQ0E7QUFDQSw0REFBNEQ7QUFDNUQ7QUFDQTtBQUNBO0FBQ0EsNERBQTREO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLDJEQUEyRDtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQsS0FBSyxXQUFXO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsUUFBUTtBQUNSLGtHQUFrRyxrQkFBa0IsT0FBTywyQ0FBVztBQUN0SSw4QkFBOEIsVUFBVTtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLDZEQUE2RCxxQkFBcUI7QUFDbEYsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsVUFBVTtBQUN0QztBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELFdBQVc7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RCxhQUFhO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBLGFBQWEsY0FBYztBQUMzQixlQUFlLGVBQWUsdURBQXVELGlCQUFpQjtBQUN0RztBQUNBO0FBQ0EsNkNBQTZDLFNBQVM7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGNBQWM7QUFDM0IsZUFBZSxlQUFlLHVEQUF1RCxpQkFBaUI7QUFDdEc7QUFDQTtBQUNBLDhDQUE4QyxTQUFTO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxjQUFjO0FBQzNCLGVBQWUsZUFBZSx1REFBdUQsaUJBQWlCO0FBQ3RHO0FBQ0E7QUFDQSw2Q0FBNkMsU0FBUztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QscUJBQXFCLHFCQUFxQjtBQUM1RixpRUFBaUUseUJBQXlCLDJDQUFXO0FBQ3JHO0FBQ0E7QUFDQSxtREFBbUQsS0FBSyxXQUFXO0FBQ25FO0FBQ0EsS0FBSztBQUNMO0FBQ0EsbURBQW1EO0FBQ25EO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQ7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdELEtBQUssV0FBVztBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxFQUFFO0FBQzFDO0FBQ0Esa0JBQWtCLCtDQUErQztBQUNqRTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsRUFBRTtBQUMxQztBQUNBLDhHQUE4Ryx5QkFBeUI7QUFDdkksS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxFQUFFO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxnRUFBZ0U7QUFDckc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxPQUFPO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsT0FBTztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLFFBQVE7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdUQUF3VDtBQUN4VDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFO0FBQ2hFO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0Esc0RBQXNEO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdEO0FBQ3hEO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9EO0FBQ3BEO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFEO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNklBQTZJO0FBQzdJO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RDtBQUN4RDtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiLDBEQUEwRDtBQUMxRDtBQUNBO0FBQ0EsZUFBZTtBQUNmLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxpR0FBaUc7QUFDakc7QUFDQSxhQUFhLHdQQUF3UCxtRkFBbUYsb0JBQW9CO0FBQzVXO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RDtBQUN4RDtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSx3REFBd0Q7QUFDeEQ7QUFDQSxhQUFhO0FBQ2I7QUFDQSx1Q0FBdUMsc0NBQXNDO0FBQzdFLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0VBQW9FO0FBQ3BFO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsOEVBQThFO0FBQzlFO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSx1RUFBdUUsNEJBQTRCLFVBQVU7QUFDN0csS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrRkFBa0YsNkJBQTZCLHFCQUFxQjtBQUNwSTtBQUNBLHdFQUF3RTtBQUN4RTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsMkNBQVc7QUFDL0IsNkVBQTZFO0FBQzdFO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMLHlEQUF5RDtBQUN6RDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1QsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBO0FBQ0Esa0dBQWtHO0FBQ2xHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRCxtQ0FBbUMsbUJBQW1CLDJDQUFXO0FBQzVIO0FBQ0E7QUFDQSxLQUFLLG1FQUFtRTtBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RDtBQUM3RDtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsMkNBQVcseUJBQXlCO0FBQzFEO0FBQ0Esc0JBQXNCLDJDQUFXLHlCQUF5QjtBQUMxRCxtSEFBbUgscUJBQXFCO0FBQ3hJO0FBQ0E7QUFDQSx1RUFBdUUsK0NBQStDLFdBQVc7QUFDakk7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLDJDQUFXO0FBQzNDO0FBQ0EsaUVBQWlFO0FBQ2pFO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQywyQ0FBVyx5RUFBeUUsMkNBQVc7QUFDL0g7QUFDQSxXQUFXO0FBQ1g7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RDtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThELGNBQWMseUJBQXlCLG1GQUFtRixhQUFhLHlCQUF5QjtBQUM5TixRQUFRO0FBQ1Isc0VBQXNFLHFCQUFxQixnQkFBZ0Isc0NBQXNDLDJDQUFXO0FBQzVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQsd0JBQXdCLHNDQUFzQywyQ0FBVztBQUN0SSxzREFBc0QsZ0JBQWdCO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZIQUE2SDtBQUM3SDtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJFQUEyRTtBQUMzRTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSwyRUFBMkU7QUFDM0U7QUFDQSxhQUFhLDRGQUE0RjtBQUN6RztBQUNBLGFBQWE7QUFDYixZQUFZO0FBQ1o7QUFDQSw0QkFBNEIsMkNBQVc7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2Qyw0QkFBNEI7QUFDekU7QUFDQSxzQkFBc0IsMkNBQVc7QUFDakM7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RDtBQUM3RDtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsMkNBQVcseUJBQXlCO0FBQzFEO0FBQ0Esc0JBQXNCLDJDQUFXLHlCQUF5QjtBQUMxRDtBQUNBLHNCQUFzQiwyQ0FBVyx5QkFBeUI7QUFDMUQsbUhBQW1ILHFCQUFxQjtBQUN4STtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RDtBQUN6RDtBQUNBLFdBQVcsSUFBSTtBQUNmO0FBQ0EsOERBQThEO0FBQzlELFFBQVE7QUFDUixrRUFBa0Usa0NBQWtDLFVBQVUsZ0JBQWdCLDJDQUFXO0FBQ3pJLGdFQUFnRSxvQkFBb0IsVUFBVTtBQUM5RjtBQUNBO0FBQ0Esb0VBQW9FLDZCQUE2QixVQUFVLCtHQUErRztBQUMxTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLG9CQUFvQjtBQUNuRDtBQUNBO0FBQ0EsbUJBQW1CLDJDQUFXO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThEO0FBQzlEO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxvQkFBb0I7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtFQUFrRTtBQUNsRSxvQkFBb0IsMkNBQVc7QUFDL0IsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsV0FBVyxxSUFBcUkscUJBQXFCLHVEQUF1RDtBQUM1TjtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3R0FBd0cscUNBQXFDLFVBQVU7QUFDdko7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThEO0FBQzlEO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RDtBQUM5RDtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSw4REFBOEQ7QUFDOUQ7QUFDQSxXQUFXLGlGQUFpRjtBQUM1RjtBQUNBLFdBQVc7QUFDWCxVQUFVO0FBQ1Ysb0VBQW9FO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLE9BQU87QUFDUDtBQUNBLDZEQUE2RCxvQkFBb0I7QUFDakYsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsa0JBQWtCLDJDQUFXLGdDQUFnQyxFQUFFO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsMkNBQVc7QUFDekI7QUFDQSxjQUFjLDJDQUFXO0FBQ3pCO0FBQ0EsY0FBYywyQ0FBVztBQUN6QjtBQUNBLGNBQWMsMkNBQVc7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxrRUFBa0UscUJBQXFCO0FBQ3ZGLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLEVBQUU7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QyxZQUFZLG1DQUFtQztBQUMvQztBQUNBLGdDQUFnQywyQ0FBVywyQkFBMkI7QUFDdEU7QUFDQTtBQUNBLFlBQVksMkNBQVcsMkJBQTJCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsMkNBQVc7QUFDM0Isd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlEO0FBQ3pEO0FBQ0Esd0RBQXdEO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVEO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLDREQUE0RCxLQUFLLHNCQUFzQjtBQUN2RjtBQUNBO0FBQ0E7QUFDQSw2REFBNkQsS0FBSyxXQUFXO0FBQzdFO0FBQ0E7QUFDQSwrREFBK0Q7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRCxnQkFBZ0IsV0FBVztBQUN0RjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsMkRBQTJELHFCQUFxQjtBQUNoRixLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixFQUFFO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RDtBQUN6RCw0REFBNEQ7QUFDNUQsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0Q7QUFDbEQsaURBQWlEO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0Q7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RDtBQUN6RDtBQUNBLHdEQUF3RDtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RDtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBLCtEQUErRDtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQsS0FBSyxXQUFXO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsS0FBSyx1QkFBdUI7QUFDdkQ7QUFDQTtBQUNBLFVBQVUsMkNBQVc7QUFDckIsa0NBQWtDLG9CQUFvQjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUVBQXFFLFdBQVc7QUFDaEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkZBQTZGLFdBQVc7QUFDeEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUdBQWlHLFdBQVcsdUpBQXVKLFdBQVc7QUFDOVEsaUZBQWlGLHFCQUFxQjtBQUN0RyxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxjQUFjLDJDQUFXO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyw4QkFBOEIsdUJBQXVCO0FBQ2hFLFNBQVM7QUFDVCx3R0FBd0csK0JBQStCO0FBQ3ZJO0FBQ0EsdUJBQXVCLDJDQUFXO0FBQ2xDLFdBQVc7QUFDWCxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2RUFBNkUsMkNBQVc7QUFDeEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrRUFBK0UsMkNBQVc7QUFDMUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyRUFBMkUsMkNBQVc7QUFDdEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4RUFBOEUsMkNBQVc7QUFDekY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLEtBQUssV0FBVztBQUNwRDtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsMkNBQVc7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLEtBQUssV0FBVztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxrQkFBa0IsV0FBVztBQUN4RTtBQUNBO0FBQ0EsS0FBSztBQUNMLG9DQUFvQyxzQkFBc0I7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdVJBQXVSLEtBQUs7QUFDNVI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBLHNHQUFzRztBQUN0RztBQUNBO0FBQ0EsY0FBYywyQ0FBVyx3QkFBd0I7QUFDakQ7QUFDQSxjQUFjLDJDQUFXLG1DQUFtQztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsMENBQVU7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsMENBQVU7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLDJDQUFXO0FBQzNCO0FBQ0EsZ0JBQWdCLDJDQUFXLDBCQUEwQixPQUFPO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQWtCRTtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQGhlbHNhL2FwcC8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQGFibHkvY2hhdC9kaXN0L2NoYXQvYWJseS1jaGF0LmpzP2YyOGEiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgaCBmcm9tIFwiYWJseVwiO1xudmFyIG90ID0gLyogQF9fUFVSRV9fICovICgoaSkgPT4gKGkuVHJhY2UgPSBcInRyYWNlXCIsIGkuRGVidWcgPSBcImRlYnVnXCIsIGkuSW5mbyA9IFwiaW5mb1wiLCBpLldhcm4gPSBcIndhcm5cIiwgaS5FcnJvciA9IFwiZXJyb3JcIiwgaS5TaWxlbnQgPSBcInNpbGVudFwiLCBpKSkob3QgfHwge30pO1xuY29uc3Qgem4gPSAoaSwgZSwgdCkgPT4ge1xuICBjb25zdCByID0gdCA/IGAsIGNvbnRleHQ6ICR7SlNPTi5zdHJpbmdpZnkodCl9YCA6IFwiXCIsIHMgPSBgWyR7KC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpKS50b0lTT1N0cmluZygpfV0gJHtlLnZhbHVlT2YoKS50b1VwcGVyQ2FzZSgpfSBhYmx5LWNoYXQ6ICR7aX0ke3J9YDtcbiAgc3dpdGNoIChlKSB7XG4gICAgY2FzZSBcInRyYWNlXCI6XG4gICAgY2FzZSBcImRlYnVnXCI6IHtcbiAgICAgIGNvbnNvbGUubG9nKHMpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNhc2UgXCJpbmZvXCI6IHtcbiAgICAgIGNvbnNvbGUuaW5mbyhzKTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjYXNlIFwid2FyblwiOiB7XG4gICAgICBjb25zb2xlLndhcm4ocyk7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgY2FzZSBcImVycm9yXCI6IHtcbiAgICAgIGNvbnNvbGUuZXJyb3Iocyk7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbn0sICRuID0gKGkpID0+IHtcbiAgY29uc3QgZSA9IGkubG9nSGFuZGxlciA/PyB6bjtcbiAgcmV0dXJuIG5ldyBXbihlLCBpLmxvZ0xldmVsKTtcbn0sIHFuID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoW1xuICBbXG4gICAgXCJ0cmFjZVwiLFxuICAgIDBcbiAgICAvKiBUcmFjZSAqL1xuICBdLFxuICBbXG4gICAgXCJkZWJ1Z1wiLFxuICAgIDFcbiAgICAvKiBEZWJ1ZyAqL1xuICBdLFxuICBbXG4gICAgXCJpbmZvXCIsXG4gICAgMlxuICAgIC8qIEluZm8gKi9cbiAgXSxcbiAgW1xuICAgIFwid2FyblwiLFxuICAgIDNcbiAgICAvKiBXYXJuICovXG4gIF0sXG4gIFtcbiAgICBcImVycm9yXCIsXG4gICAgNFxuICAgIC8qIEVycm9yICovXG4gIF0sXG4gIFtcbiAgICBcInNpbGVudFwiLFxuICAgIDVcbiAgICAvKiBTaWxlbnQgKi9cbiAgXVxuXSk7XG5jbGFzcyBXbiB7XG4gIGNvbnN0cnVjdG9yKGUsIHQpIHtcbiAgICB0aGlzLl9oYW5kbGVyID0gZTtcbiAgICBjb25zdCByID0gcW4uZ2V0KHQpO1xuICAgIGlmIChyID09PSB2b2lkIDApXG4gICAgICB0aHJvdyBuZXcgaC5FcnJvckluZm8oYEludmFsaWQgbG9nIGxldmVsOiAke3R9YCwgNWU0LCA1MDApO1xuICAgIHRoaXMuX2xldmVsTnVtYmVyID0gcjtcbiAgfVxuICB0cmFjZShlLCB0KSB7XG4gICAgdGhpcy5fd3JpdGUoZSwgXCJ0cmFjZVwiLCAwLCB0KTtcbiAgfVxuICBkZWJ1ZyhlLCB0KSB7XG4gICAgdGhpcy5fd3JpdGUoZSwgXCJkZWJ1Z1wiLCAxLCB0KTtcbiAgfVxuICBpbmZvKGUsIHQpIHtcbiAgICB0aGlzLl93cml0ZShlLCBcImluZm9cIiwgMiwgdCk7XG4gIH1cbiAgd2FybihlLCB0KSB7XG4gICAgdGhpcy5fd3JpdGUoZSwgXCJ3YXJuXCIsIDMsIHQpO1xuICB9XG4gIGVycm9yKGUsIHQpIHtcbiAgICB0aGlzLl93cml0ZShlLCBcImVycm9yXCIsIDQsIHQpO1xuICB9XG4gIF93cml0ZShlLCB0LCByLCBzKSB7XG4gICAgciA+PSB0aGlzLl9sZXZlbE51bWJlciAmJiB0aGlzLl9oYW5kbGVyKGUsIHQsIHMpO1xuICB9XG59XG5jb25zdCBVbiA9IHtcbiAgbG9nTGV2ZWw6IG90LkVycm9yXG59LCBCbiA9IChpKSA9PiAoaSA9IGkgPz8ge30sIHtcbiAgLi4uaSxcbiAgbG9nTGV2ZWw6IGkubG9nTGV2ZWwgPz8gVW4ubG9nTGV2ZWxcbn0pO1xuY2xhc3MgR24ge1xuICBjb25zdHJ1Y3RvcihlKSB7XG4gICAgdGhpcy5fc3RhdHVzID0gZTtcbiAgfVxuICBnZXQgc3RhdHVzKCkge1xuICAgIHJldHVybiB0aGlzLl9zdGF0dXM7XG4gIH1cbn1cbmNvbnN0IEhuID0gaC5SZWFsdGltZS5FdmVudEVtaXR0ZXI7XG5jbGFzcyBTIGV4dGVuZHMgSG4ge1xufVxuY29uc3QgVm4gPSA1ZTM7XG52YXIgS24gPSAvKiBAX19QVVJFX18gKi8gKChpKSA9PiAoaS5Jbml0aWFsaXplZCA9IFwiaW5pdGlhbGl6ZWRcIiwgaS5Db25uZWN0aW5nID0gXCJjb25uZWN0aW5nXCIsIGkuQ29ubmVjdGVkID0gXCJjb25uZWN0ZWRcIiwgaS5EaXNjb25uZWN0ZWQgPSBcImRpc2Nvbm5lY3RlZFwiLCBpLlN1c3BlbmRlZCA9IFwic3VzcGVuZGVkXCIsIGkuRmFpbGVkID0gXCJmYWlsZWRcIiwgaSkpKEtuIHx8IHt9KTtcbmNsYXNzIFFuIGV4dGVuZHMgUyB7XG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RzIGEgbmV3IGBEZWZhdWx0Q29ubmVjdGlvbmAgaW5zdGFuY2UuXG4gICAqIEBwYXJhbSBhYmx5IFRoZSBBYmx5IFJlYWx0aW1lIGNsaWVudC5cbiAgICogQHBhcmFtIGxvZ2dlciBUaGUgbG9nZ2VyIHRvIHVzZS5cbiAgICovXG4gIGNvbnN0cnVjdG9yKGUsIHQpIHtcbiAgICBzdXBlcigpLCB0aGlzLl9zdGF0ZSA9IFwiaW5pdGlhbGl6ZWRcIiwgdGhpcy5fbG9nZ2VyID0gdCwgdGhpcy5fc3RhdGUgPSB0aGlzLl9tYXBBYmx5U3RhdHVzVG9DaGF0KGUuY29ubmVjdGlvbi5zdGF0ZSksIHRoaXMuX2Vycm9yID0gZS5jb25uZWN0aW9uLmVycm9yUmVhc29uLCB0aGlzLl9jb25uZWN0aW9uID0gZS5jb25uZWN0aW9uLCB0aGlzLl9jb25uZWN0aW9uLm9uKChyKSA9PiB7XG4gICAgICBjb25zdCBzID0gdGhpcy5fbWFwQWJseVN0YXR1c1RvQ2hhdChyLmN1cnJlbnQpO1xuICAgICAgaWYgKHMgPT09IHRoaXMuX3N0YXRlKVxuICAgICAgICByZXR1cm47XG4gICAgICBjb25zdCBjID0ge1xuICAgICAgICBjdXJyZW50OiBzLFxuICAgICAgICBwcmV2aW91czogdGhpcy5fc3RhdGUsXG4gICAgICAgIGVycm9yOiByLnJlYXNvbixcbiAgICAgICAgcmV0cnlJbjogci5yZXRyeUluXG4gICAgICB9O1xuICAgICAgaWYgKHMgPT09IFwiZGlzY29ubmVjdGVkXCIgJiYgIXRoaXMuX3RyYW5zaWVudFRpbWVvdXQpIHtcbiAgICAgICAgdGhpcy5fdHJhbnNpZW50VGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgIHRoaXMuX3RyYW5zaWVudFRpbWVvdXQgPSB2b2lkIDAsIHRoaXMuX2FwcGx5U3RhdHVzQ2hhbmdlKGMpO1xuICAgICAgICB9LCBWbik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMuX3RyYW5zaWVudFRpbWVvdXQgJiYgKGNsZWFyVGltZW91dCh0aGlzLl90cmFuc2llbnRUaW1lb3V0KSwgdGhpcy5fdHJhbnNpZW50VGltZW91dCA9IHZvaWQgMCksIHRoaXMuX2FwcGx5U3RhdHVzQ2hhbmdlKGMpO1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBAaW5oZXJpdGRvY1xuICAgKi9cbiAgZ2V0IGN1cnJlbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3N0YXRlO1xuICB9XG4gIC8qKlxuICAgKiBAaW5oZXJpdGRvY1xuICAgKi9cbiAgZ2V0IGVycm9yKCkge1xuICAgIHJldHVybiB0aGlzLl9lcnJvcjtcbiAgfVxuICAvKipcbiAgICogQGluaGVyaXRkb2NcbiAgICovXG4gIG9uQ2hhbmdlKGUpIHtcbiAgICByZXR1cm4gdGhpcy5vbihlKSwge1xuICAgICAgb2ZmOiAoKSA9PiB7XG4gICAgICAgIHRoaXMub2ZmKGUpO1xuICAgICAgfVxuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIEBpbmhlcml0ZG9jXG4gICAqL1xuICBvZmZBbGwoKSB7XG4gICAgdGhpcy5vZmYoKTtcbiAgfVxuICBfYXBwbHlTdGF0dXNDaGFuZ2UoZSkge1xuICAgIHRoaXMuX3N0YXRlID0gZS5jdXJyZW50LCB0aGlzLl9lcnJvciA9IGUuZXJyb3IsIHRoaXMuX2xvZ2dlci5pbmZvKFwiQ29ubmVjdGlvbiBzdGF0ZSBjaGFuZ2VkXCIsIGUpLCB0aGlzLmVtaXQoZS5jdXJyZW50LCBlKTtcbiAgfVxuICBfbWFwQWJseVN0YXR1c1RvQ2hhdChlKSB7XG4gICAgc3dpdGNoIChlKSB7XG4gICAgICBjYXNlIFwiY2xvc2luZ1wiOlxuICAgICAgY2FzZSBcImNsb3NlZFwiOlxuICAgICAgICByZXR1cm4gXCJmYWlsZWRcIjtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBlO1xuICAgIH1cbiAgfVxufVxudmFyIGl0ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbmZ1bmN0aW9uIHN0KGksIGUsIHQpIHtcbiAgZm9yICh0IG9mIGkua2V5cygpKVxuICAgIGlmIChqKHQsIGUpKSByZXR1cm4gdDtcbn1cbmZ1bmN0aW9uIGooaSwgZSkge1xuICB2YXIgdCwgciwgcztcbiAgaWYgKGkgPT09IGUpIHJldHVybiAhMDtcbiAgaWYgKGkgJiYgZSAmJiAodCA9IGkuY29uc3RydWN0b3IpID09PSBlLmNvbnN0cnVjdG9yKSB7XG4gICAgaWYgKHQgPT09IERhdGUpIHJldHVybiBpLmdldFRpbWUoKSA9PT0gZS5nZXRUaW1lKCk7XG4gICAgaWYgKHQgPT09IFJlZ0V4cCkgcmV0dXJuIGkudG9TdHJpbmcoKSA9PT0gZS50b1N0cmluZygpO1xuICAgIGlmICh0ID09PSBBcnJheSkge1xuICAgICAgaWYgKChyID0gaS5sZW5ndGgpID09PSBlLmxlbmd0aClcbiAgICAgICAgZm9yICg7IHItLSAmJiBqKGlbcl0sIGVbcl0pOyApIDtcbiAgICAgIHJldHVybiByID09PSAtMTtcbiAgICB9XG4gICAgaWYgKHQgPT09IFNldCkge1xuICAgICAgaWYgKGkuc2l6ZSAhPT0gZS5zaXplKVxuICAgICAgICByZXR1cm4gITE7XG4gICAgICBmb3IgKHIgb2YgaSlcbiAgICAgICAgaWYgKHMgPSByLCBzICYmIHR5cGVvZiBzID09IFwib2JqZWN0XCIgJiYgKHMgPSBzdChlLCBzKSwgIXMpIHx8ICFlLmhhcyhzKSkgcmV0dXJuICExO1xuICAgICAgcmV0dXJuICEwO1xuICAgIH1cbiAgICBpZiAodCA9PT0gTWFwKSB7XG4gICAgICBpZiAoaS5zaXplICE9PSBlLnNpemUpXG4gICAgICAgIHJldHVybiAhMTtcbiAgICAgIGZvciAociBvZiBpKVxuICAgICAgICBpZiAocyA9IHJbMF0sIHMgJiYgdHlwZW9mIHMgPT0gXCJvYmplY3RcIiAmJiAocyA9IHN0KGUsIHMpLCAhcykgfHwgIWooclsxXSwgZS5nZXQocykpKVxuICAgICAgICAgIHJldHVybiAhMTtcbiAgICAgIHJldHVybiAhMDtcbiAgICB9XG4gICAgaWYgKHQgPT09IEFycmF5QnVmZmVyKVxuICAgICAgaSA9IG5ldyBVaW50OEFycmF5KGkpLCBlID0gbmV3IFVpbnQ4QXJyYXkoZSk7XG4gICAgZWxzZSBpZiAodCA9PT0gRGF0YVZpZXcpIHtcbiAgICAgIGlmICgociA9IGkuYnl0ZUxlbmd0aCkgPT09IGUuYnl0ZUxlbmd0aClcbiAgICAgICAgZm9yICg7IHItLSAmJiBpLmdldEludDgocikgPT09IGUuZ2V0SW50OChyKTsgKSA7XG4gICAgICByZXR1cm4gciA9PT0gLTE7XG4gICAgfVxuICAgIGlmIChBcnJheUJ1ZmZlci5pc1ZpZXcoaSkpIHtcbiAgICAgIGlmICgociA9IGkuYnl0ZUxlbmd0aCkgPT09IGUuYnl0ZUxlbmd0aClcbiAgICAgICAgZm9yICg7IHItLSAmJiBpW3JdID09PSBlW3JdOyApIDtcbiAgICAgIHJldHVybiByID09PSAtMTtcbiAgICB9XG4gICAgaWYgKCF0IHx8IHR5cGVvZiBpID09IFwib2JqZWN0XCIpIHtcbiAgICAgIHIgPSAwO1xuICAgICAgZm9yICh0IGluIGkpXG4gICAgICAgIGlmIChpdC5jYWxsKGksIHQpICYmICsrciAmJiAhaXQuY2FsbChlLCB0KSB8fCAhKHQgaW4gZSkgfHwgIWooaVt0XSwgZVt0XSkpIHJldHVybiAhMTtcbiAgICAgIHJldHVybiBPYmplY3Qua2V5cyhlKS5sZW5ndGggPT09IHI7XG4gICAgfVxuICB9XG4gIHJldHVybiBpICE9PSBpICYmIGUgIT09IGU7XG59XG5jbGFzcyAkIHtcbiAgY29uc3RydWN0b3IoZSwgdCwgciwgcykge1xuICAgIHRoaXMuc2VyaWVzSWQgPSBlLCB0aGlzLnRpbWVzdGFtcCA9IHQsIHRoaXMuY291bnRlciA9IHIsIHRoaXMuaW5kZXggPSBzO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIHRpbWVzZXJpYWwgb2JqZWN0LlxuICAgKiBAcmV0dXJucyBUaGUgdGltZXNlcmlhbCBzdHJpbmcuXG4gICAqL1xuICB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gYCR7dGhpcy5zZXJpZXNJZH1AJHt0aGlzLnRpbWVzdGFtcC50b1N0cmluZygpfS0ke3RoaXMuY291bnRlci50b1N0cmluZygpfSR7dGhpcy5pbmRleCA/IGA6JHt0aGlzLmluZGV4LnRvU3RyaW5nKCl9YCA6IFwiXCJ9YDtcbiAgfVxuICAvKipcbiAgICogQ2FsY3VsYXRlIHRoZSB0aW1lc2VyaWFsIG9iamVjdCBmcm9tIGEgdGltZXNlcmlhbCBzdHJpbmcuXG4gICAqXG4gICAqIEBwYXJhbSB0aW1lc2VyaWFsIFRoZSB0aW1lc2VyaWFsIHN0cmluZyB0byBwYXJzZS5cbiAgICogQHJldHVybnMgVGhlIHBhcnNlZCB0aW1lc2VyaWFsIG9iamVjdC5cbiAgICogQHRocm93cyB7QGxpbmsgRXJyb3JJbmZvfSBpZiB0aW1lc2VyaWFsIGlzIGludmFsaWQuXG4gICAqL1xuICBzdGF0aWMgY2FsY3VsYXRlVGltZXNlcmlhbChlKSB7XG4gICAgY29uc3QgW3QsIHJdID0gZS5zcGxpdChcIkBcIik7XG4gICAgaWYgKCF0IHx8ICFyKVxuICAgICAgdGhyb3cgbmV3IGguRXJyb3JJbmZvKFwiaW52YWxpZCB0aW1lc2VyaWFsXCIsIDVlNCwgNTAwKTtcbiAgICBjb25zdCBbcywgY10gPSByLnNwbGl0KFwiLVwiKTtcbiAgICBpZiAoIXMgfHwgIWMpXG4gICAgICB0aHJvdyBuZXcgaC5FcnJvckluZm8oXCJpbnZhbGlkIHRpbWVzZXJpYWxcIiwgNWU0LCA1MDApO1xuICAgIGNvbnN0IFt1LCBnXSA9IGMuc3BsaXQoXCI6XCIpO1xuICAgIGlmICghdSlcbiAgICAgIHRocm93IG5ldyBoLkVycm9ySW5mbyhcImludmFsaWQgdGltZXNlcmlhbFwiLCA1ZTQsIDUwMCk7XG4gICAgcmV0dXJuIG5ldyAkKHQsIE51bWJlcihzKSwgTnVtYmVyKHUpLCBnID8gTnVtYmVyKGcpIDogdm9pZCAwKTtcbiAgfVxuICAvKipcbiAgICogQ29tcGFyZXMgdGhpcyB0aW1lc2VyaWFsIHRvIHRoZSBzdXBwbGllZCB0aW1lc2VyaWFsLCByZXR1cm5pbmcgYSBudW1iZXIgaW5kaWNhdGluZyB0aGVpciByZWxhdGl2ZSBvcmRlci5cbiAgICogQHBhcmFtIHRpbWVzZXJpYWxUb0NvbXBhcmUgVGhlIHRpbWVzZXJpYWwgdG8gY29tcGFyZSBhZ2FpbnN0LiBDYW4gYmUgYSBzdHJpbmcgb3IgYSBUaW1lc2VyaWFsIG9iamVjdC5cbiAgICogQHJldHVybnMgMCBpZiB0aGUgdGltZXNlcmlhbHMgYXJlIGVxdWFsLCA8MCBpZiB0aGUgZmlyc3QgdGltZXNlcmlhbCBpcyBsZXNzIHRoYW4gdGhlIHNlY29uZCwgPjAgaWYgdGhlIGZpcnN0IHRpbWVzZXJpYWwgaXMgZ3JlYXRlciB0aGFuIHRoZSBzZWNvbmQuXG4gICAqIEB0aHJvd3Mge0BsaW5rIEVycm9ySW5mb30gaWYgY29tcGFyaXNvbiB0aW1lc2VyaWFsIGlzIGludmFsaWQuXG4gICAqL1xuICBfdGltZXNlcmlhbENvbXBhcmUoZSkge1xuICAgIGNvbnN0IHQgPSB0eXBlb2YgZSA9PSBcInN0cmluZ1wiID8gJC5jYWxjdWxhdGVUaW1lc2VyaWFsKGUpIDogZSwgciA9IHRoaXMudGltZXN0YW1wIC0gdC50aW1lc3RhbXA7XG4gICAgaWYgKHIpXG4gICAgICByZXR1cm4gcjtcbiAgICBjb25zdCBzID0gdGhpcy5jb3VudGVyIC0gdC5jb3VudGVyO1xuICAgIGlmIChzKVxuICAgICAgcmV0dXJuIHM7XG4gICAgY29uc3QgYyA9IHRoaXMuc2VyaWVzSWQgPT09IHQuc2VyaWVzSWQgPyAwIDogdGhpcy5zZXJpZXNJZCA8IHQuc2VyaWVzSWQgPyAtMSA6IDE7XG4gICAgcmV0dXJuIGMgfHwgKHRoaXMuaW5kZXggIT09IHZvaWQgMCAmJiB0LmluZGV4ICE9PSB2b2lkIDAgPyB0aGlzLmluZGV4IC0gdC5pbmRleCA6IDApO1xuICB9XG4gIC8qKlxuICAgKiBEZXRlcm1pbmVzIGlmIHRoaXMgdGltZXNlcmlhbCBvY2N1cnMgbG9naWNhbGx5IGJlZm9yZSB0aGUgZ2l2ZW4gdGltZXNlcmlhbC5cbiAgICpcbiAgICogQHBhcmFtIHRpbWVzZXJpYWwgVGhlIHRpbWVzZXJpYWwgdG8gY29tcGFyZSBhZ2FpbnN0LiBDYW4gYmUgYSBzdHJpbmcgb3IgYSBUaW1lc2VyaWFsIG9iamVjdC5cbiAgICogQHJldHVybnMgdHJ1ZSBpZiB0aGlzIHRpbWVzZXJpYWwgcHJlY2VkZXMgdGhlIGdpdmVuIHRpbWVzZXJpYWwsIGluIGdsb2JhbCBvcmRlci5cbiAgICogQHRocm93cyB7QGxpbmsgRXJyb3JJbmZvfSBpZiB0aGUgZ2l2ZW4gdGltZXNlcmlhbCBpcyBpbnZhbGlkLlxuICAgKi9cbiAgYmVmb3JlKGUpIHtcbiAgICByZXR1cm4gdGhpcy5fdGltZXNlcmlhbENvbXBhcmUoZSkgPCAwO1xuICB9XG4gIC8qKlxuICAgKiBEZXRlcm1pbmVzIGlmIHRoaXMgdGltZXNlcmlhbCBvY2N1cnMgbG9naWNhbGx5IGFmdGVyIHRoZSBnaXZlbiB0aW1lc2VyaWFsLlxuICAgKlxuICAgKiBAcGFyYW0gdGltZXNlcmlhbCBUaGUgdGltZXNlcmlhbCB0byBjb21wYXJlIGFnYWluc3QuIENhbiBiZSBhIHN0cmluZyBvciBhIFRpbWVzZXJpYWwgb2JqZWN0LlxuICAgKiBAcmV0dXJucyB0cnVlIGlmIHRoaXMgdGltZXNlcmlhbCBmb2xsb3dzIHRoZSBnaXZlbiB0aW1lc2VyaWFsLCBpbiBnbG9iYWwgb3JkZXIuXG4gICAqIEB0aHJvd3Mge0BsaW5rIEVycm9ySW5mb30gaWYgdGhlIGdpdmVuIHRpbWVzZXJpYWwgaXMgaW52YWxpZC5cbiAgICovXG4gIGFmdGVyKGUpIHtcbiAgICByZXR1cm4gdGhpcy5fdGltZXNlcmlhbENvbXBhcmUoZSkgPiAwO1xuICB9XG4gIC8qKlxuICAgKiBEZXRlcm1pbmVzIGlmIHRoaXMgdGltZXNlcmlhbCBpcyBlcXVhbCB0byB0aGUgZ2l2ZW4gdGltZXNlcmlhbC5cbiAgICogQHBhcmFtIHRpbWVzZXJpYWwgVGhlIHRpbWVzZXJpYWwgdG8gY29tcGFyZSBhZ2FpbnN0LiBDYW4gYmUgYSBzdHJpbmcgb3IgYSBUaW1lc2VyaWFsIG9iamVjdC5cbiAgICogQHJldHVybnMgdHJ1ZSBpZiB0aGlzIHRpbWVzZXJpYWwgaXMgZXF1YWwgdG8gdGhlIGdpdmVuIHRpbWVzZXJpYWwuXG4gICAqIEB0aHJvd3Mge0BsaW5rIEVycm9ySW5mb30gaWYgdGhlIGdpdmVuIHRpbWVzZXJpYWwgaXMgaW52YWxpZC5cbiAgICovXG4gIGVxdWFsKGUpIHtcbiAgICByZXR1cm4gdGhpcy5fdGltZXNlcmlhbENvbXBhcmUoZSkgPT09IDA7XG4gIH1cbn1cbmNsYXNzIGZlIHtcbiAgY29uc3RydWN0b3IoZSwgdCwgciwgcywgYywgdSwgZykge1xuICAgIHRoaXMudGltZXNlcmlhbCA9IGUsIHRoaXMuY2xpZW50SWQgPSB0LCB0aGlzLnJvb21JZCA9IHIsIHRoaXMudGV4dCA9IHMsIHRoaXMuY3JlYXRlZEF0ID0gYywgdGhpcy5tZXRhZGF0YSA9IHUsIHRoaXMuaGVhZGVycyA9IGcsIHRoaXMuX2NhbGN1bGF0ZWRUaW1lc2VyaWFsID0gJC5jYWxjdWxhdGVUaW1lc2VyaWFsKGUpLCBPYmplY3QuZnJlZXplKHRoaXMpO1xuICB9XG4gIGJlZm9yZShlKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NhbGN1bGF0ZWRUaW1lc2VyaWFsLmJlZm9yZShlLnRpbWVzZXJpYWwpO1xuICB9XG4gIGFmdGVyKGUpIHtcbiAgICByZXR1cm4gdGhpcy5fY2FsY3VsYXRlZFRpbWVzZXJpYWwuYWZ0ZXIoZS50aW1lc2VyaWFsKTtcbiAgfVxuICBlcXVhbChlKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NhbGN1bGF0ZWRUaW1lc2VyaWFsLmVxdWFsKGUudGltZXNlcmlhbCk7XG4gIH1cbn1cbmNsYXNzIFhuIHtcbiAgY29uc3RydWN0b3IoZSwgdCkge1xuICAgIHRoaXMuX2FwaVByb3RvY29sVmVyc2lvbiA9IDMsIHRoaXMuX3JlYWx0aW1lID0gZSwgdGhpcy5fbG9nZ2VyID0gdDtcbiAgfVxuICBhc3luYyBnZXRNZXNzYWdlcyhlLCB0KSB7XG4gICAgcmV0dXJuIHRoaXMuX21ha2VBdXRob3JpemVkUGFnaW5hdGVkUmVxdWVzdChcbiAgICAgIGAvY2hhdC92MS9yb29tcy8ke2V9L21lc3NhZ2VzYCxcbiAgICAgIHRcbiAgICApLnRoZW4oKHIpID0+IChyLml0ZW1zID0gci5pdGVtcy5tYXAoKHMpID0+IHtcbiAgICAgIGNvbnN0IGMgPSBzLm1ldGFkYXRhLCB1ID0gcy5oZWFkZXJzO1xuICAgICAgcmV0dXJuIG5ldyBmZShcbiAgICAgICAgcy50aW1lc2VyaWFsLFxuICAgICAgICBzLmNsaWVudElkLFxuICAgICAgICBzLnJvb21JZCxcbiAgICAgICAgcy50ZXh0LFxuICAgICAgICBuZXcgRGF0ZShzLmNyZWF0ZWRBdCksXG4gICAgICAgIGMgPz8ge30sXG4gICAgICAgIHUgPz8ge31cbiAgICAgICk7XG4gICAgfSksIHIpKTtcbiAgfVxuICBhc3luYyBzZW5kTWVzc2FnZShlLCB0KSB7XG4gICAgY29uc3QgciA9IHsgdGV4dDogdC50ZXh0IH07XG4gICAgcmV0dXJuIHQubWV0YWRhdGEgJiYgKHIubWV0YWRhdGEgPSB0Lm1ldGFkYXRhKSwgdC5oZWFkZXJzICYmIChyLmhlYWRlcnMgPSB0LmhlYWRlcnMpLCB0aGlzLl9tYWtlQXV0aG9yaXplZFJlcXVlc3QoXG4gICAgICBgL2NoYXQvdjEvcm9vbXMvJHtlfS9tZXNzYWdlc2AsXG4gICAgICBcIlBPU1RcIixcbiAgICAgIHJcbiAgICApO1xuICB9XG4gIGFzeW5jIGdldE9jY3VwYW5jeShlKSB7XG4gICAgcmV0dXJuIHRoaXMuX21ha2VBdXRob3JpemVkUmVxdWVzdChgL2NoYXQvdjEvcm9vbXMvJHtlfS9vY2N1cGFuY3lgLCBcIkdFVFwiKTtcbiAgfVxuICBhc3luYyBfbWFrZUF1dGhvcml6ZWRSZXF1ZXN0KGUsIHQsIHIpIHtcbiAgICBjb25zdCBzID0gYXdhaXQgdGhpcy5fcmVhbHRpbWUucmVxdWVzdCh0LCBlLCB0aGlzLl9hcGlQcm90b2NvbFZlcnNpb24sIHt9LCByKTtcbiAgICBpZiAoIXMuc3VjY2VzcylcbiAgICAgIHRocm93IHRoaXMuX2xvZ2dlci5lcnJvcihcIkNoYXRBcGkuX21ha2VBdXRob3JpemVkUmVxdWVzdCgpOyBmYWlsZWQgdG8gbWFrZSByZXF1ZXN0XCIsIHtcbiAgICAgICAgdXJsOiBlLFxuICAgICAgICBzdGF0dXNDb2RlOiBzLnN0YXR1c0NvZGUsXG4gICAgICAgIGVycm9yQ29kZTogcy5lcnJvckNvZGUsXG4gICAgICAgIGVycm9yTWVzc2FnZTogcy5lcnJvck1lc3NhZ2VcbiAgICAgIH0pLCBuZXcgaC5FcnJvckluZm8ocy5lcnJvck1lc3NhZ2UsIHMuZXJyb3JDb2RlLCBzLnN0YXR1c0NvZGUpO1xuICAgIHJldHVybiBzLml0ZW1zWzBdO1xuICB9XG4gIGFzeW5jIF9tYWtlQXV0aG9yaXplZFBhZ2luYXRlZFJlcXVlc3QoZSwgdCwgcikge1xuICAgIGNvbnN0IHMgPSBhd2FpdCB0aGlzLl9yZWFsdGltZS5yZXF1ZXN0KFwiR0VUXCIsIGUsIHRoaXMuX2FwaVByb3RvY29sVmVyc2lvbiwgdCwgcik7XG4gICAgaWYgKCFzLnN1Y2Nlc3MpXG4gICAgICB0aHJvdyB0aGlzLl9sb2dnZXIuZXJyb3IoXCJDaGF0QXBpLl9tYWtlQXV0aG9yaXplZFBhZ2luYXRlZFJlcXVlc3QoKTsgZmFpbGVkIHRvIG1ha2UgcmVxdWVzdFwiLCB7XG4gICAgICAgIHVybDogZSxcbiAgICAgICAgc3RhdHVzQ29kZTogcy5zdGF0dXNDb2RlLFxuICAgICAgICBlcnJvckNvZGU6IHMuZXJyb3JDb2RlLFxuICAgICAgICBlcnJvck1lc3NhZ2U6IHMuZXJyb3JNZXNzYWdlXG4gICAgICB9KSwgbmV3IGguRXJyb3JJbmZvKHMuZXJyb3JNZXNzYWdlLCBzLmVycm9yQ29kZSwgcy5zdGF0dXNDb2RlKTtcbiAgICByZXR1cm4gcztcbiAgfVxufVxudmFyIEogPSB0eXBlb2YgZ2xvYmFsVGhpcyA8IFwidVwiID8gZ2xvYmFsVGhpcyA6IHR5cGVvZiB3aW5kb3cgPCBcInVcIiA/IHdpbmRvdyA6IHR5cGVvZiBnbG9iYWwgPCBcInVcIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmIDwgXCJ1XCIgPyBzZWxmIDoge307XG5mdW5jdGlvbiBZbihpKSB7XG4gIHJldHVybiBpICYmIGkuX19lc01vZHVsZSAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoaSwgXCJkZWZhdWx0XCIpID8gaS5kZWZhdWx0IDogaTtcbn1cbnZhciBaID0geyBleHBvcnRzOiB7fSB9O1xuWi5leHBvcnRzO1xuKGZ1bmN0aW9uKGksIGUpIHtcbiAgdmFyIHQgPSAyMDAsIHIgPSBcIl9fbG9kYXNoX2hhc2hfdW5kZWZpbmVkX19cIiwgcyA9IDkwMDcxOTkyNTQ3NDA5OTEsIGMgPSBcIltvYmplY3QgQXJndW1lbnRzXVwiLCB1ID0gXCJbb2JqZWN0IEFycmF5XVwiLCBnID0gXCJbb2JqZWN0IEJvb2xlYW5dXCIsIGYgPSBcIltvYmplY3QgRGF0ZV1cIiwgeSA9IFwiW29iamVjdCBFcnJvcl1cIiwgcCA9IFwiW29iamVjdCBGdW5jdGlvbl1cIiwgUiA9IFwiW29iamVjdCBHZW5lcmF0b3JGdW5jdGlvbl1cIiwgVSA9IFwiW29iamVjdCBNYXBdXCIsIHllID0gXCJbb2JqZWN0IE51bWJlcl1cIiwgZWUgPSBcIltvYmplY3QgT2JqZWN0XVwiLCB3ZSA9IFwiW29iamVjdCBQcm9taXNlXVwiLCBiZSA9IFwiW29iamVjdCBSZWdFeHBdXCIsIEIgPSBcIltvYmplY3QgU2V0XVwiLCB2ZSA9IFwiW29iamVjdCBTdHJpbmddXCIsIFJlID0gXCJbb2JqZWN0IFN5bWJvbF1cIiwgdGUgPSBcIltvYmplY3QgV2Vha01hcF1cIiwgQWUgPSBcIltvYmplY3QgQXJyYXlCdWZmZXJdXCIsIEcgPSBcIltvYmplY3QgRGF0YVZpZXddXCIsIEVlID0gXCJbb2JqZWN0IEZsb2F0MzJBcnJheV1cIiwgSWUgPSBcIltvYmplY3QgRmxvYXQ2NEFycmF5XVwiLCBTZSA9IFwiW29iamVjdCBJbnQ4QXJyYXldXCIsIFRlID0gXCJbb2JqZWN0IEludDE2QXJyYXldXCIsIE1lID0gXCJbb2JqZWN0IEludDMyQXJyYXldXCIsIERlID0gXCJbb2JqZWN0IFVpbnQ4QXJyYXldXCIsIENlID0gXCJbb2JqZWN0IFVpbnQ4Q2xhbXBlZEFycmF5XVwiLCBQZSA9IFwiW29iamVjdCBVaW50MTZBcnJheV1cIiwgeGUgPSBcIltvYmplY3QgVWludDMyQXJyYXldXCIsIGZ0ID0gL1tcXFxcXiQuKis/KClbXFxde318XS9nLCBfdCA9IC9cXHcqJC8sIG10ID0gL15cXFtvYmplY3QgLis/Q29uc3RydWN0b3JcXF0kLywgcHQgPSAvXig/OjB8WzEtOV1cXGQqKSQvLCBfID0ge307XG4gIF9bY10gPSBfW3VdID0gX1tBZV0gPSBfW0ddID0gX1tnXSA9IF9bZl0gPSBfW0VlXSA9IF9bSWVdID0gX1tTZV0gPSBfW1RlXSA9IF9bTWVdID0gX1tVXSA9IF9beWVdID0gX1tlZV0gPSBfW2JlXSA9IF9bQl0gPSBfW3ZlXSA9IF9bUmVdID0gX1tEZV0gPSBfW0NlXSA9IF9bUGVdID0gX1t4ZV0gPSAhMCwgX1t5XSA9IF9bcF0gPSBfW3RlXSA9ICExO1xuICB2YXIgeXQgPSB0eXBlb2YgSiA9PSBcIm9iamVjdFwiICYmIEogJiYgSi5PYmplY3QgPT09IE9iamVjdCAmJiBKLCB3dCA9IHR5cGVvZiBzZWxmID09IFwib2JqZWN0XCIgJiYgc2VsZiAmJiBzZWxmLk9iamVjdCA9PT0gT2JqZWN0ICYmIHNlbGYsIEEgPSB5dCB8fCB3dCB8fCBGdW5jdGlvbihcInJldHVybiB0aGlzXCIpKCksIE9lID0gZSAmJiAhZS5ub2RlVHlwZSAmJiBlLCBGZSA9IE9lICYmICEwICYmIGkgJiYgIWkubm9kZVR5cGUgJiYgaSwgYnQgPSBGZSAmJiBGZS5leHBvcnRzID09PSBPZTtcbiAgZnVuY3Rpb24gdnQobiwgYSkge1xuICAgIHJldHVybiBuLnNldChhWzBdLCBhWzFdKSwgbjtcbiAgfVxuICBmdW5jdGlvbiBSdChuLCBhKSB7XG4gICAgcmV0dXJuIG4uYWRkKGEpLCBuO1xuICB9XG4gIGZ1bmN0aW9uIEF0KG4sIGEpIHtcbiAgICBmb3IgKHZhciBvID0gLTEsIGwgPSBuID8gbi5sZW5ndGggOiAwOyArK28gPCBsICYmIGEobltvXSwgbywgbikgIT09ICExOyApXG4gICAgICA7XG4gICAgcmV0dXJuIG47XG4gIH1cbiAgZnVuY3Rpb24gRXQobiwgYSkge1xuICAgIGZvciAodmFyIG8gPSAtMSwgbCA9IGEubGVuZ3RoLCB3ID0gbi5sZW5ndGg7ICsrbyA8IGw7IClcbiAgICAgIG5bdyArIG9dID0gYVtvXTtcbiAgICByZXR1cm4gbjtcbiAgfVxuICBmdW5jdGlvbiBMZShuLCBhLCBvLCBsKSB7XG4gICAgZm9yICh2YXIgdyA9IC0xLCBiID0gbiA/IG4ubGVuZ3RoIDogMDsgKyt3IDwgYjsgKVxuICAgICAgbyA9IGEobywgblt3XSwgdywgbik7XG4gICAgcmV0dXJuIG87XG4gIH1cbiAgZnVuY3Rpb24gSXQobiwgYSkge1xuICAgIGZvciAodmFyIG8gPSAtMSwgbCA9IEFycmF5KG4pOyArK28gPCBuOyApXG4gICAgICBsW29dID0gYShvKTtcbiAgICByZXR1cm4gbDtcbiAgfVxuICBmdW5jdGlvbiBTdChuLCBhKSB7XG4gICAgcmV0dXJuIG4gPT0gbnVsbCA/IHZvaWQgMCA6IG5bYV07XG4gIH1cbiAgZnVuY3Rpb24gamUobikge1xuICAgIHZhciBhID0gITE7XG4gICAgaWYgKG4gIT0gbnVsbCAmJiB0eXBlb2Ygbi50b1N0cmluZyAhPSBcImZ1bmN0aW9uXCIpXG4gICAgICB0cnkge1xuICAgICAgICBhID0gISEobiArIFwiXCIpO1xuICAgICAgfSBjYXRjaCB7XG4gICAgICB9XG4gICAgcmV0dXJuIGE7XG4gIH1cbiAgZnVuY3Rpb24ga2Uobikge1xuICAgIHZhciBhID0gLTEsIG8gPSBBcnJheShuLnNpemUpO1xuICAgIHJldHVybiBuLmZvckVhY2goZnVuY3Rpb24obCwgdykge1xuICAgICAgb1srK2FdID0gW3csIGxdO1xuICAgIH0pLCBvO1xuICB9XG4gIGZ1bmN0aW9uIG5lKG4sIGEpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24obykge1xuICAgICAgcmV0dXJuIG4oYShvKSk7XG4gICAgfTtcbiAgfVxuICBmdW5jdGlvbiBOZShuKSB7XG4gICAgdmFyIGEgPSAtMSwgbyA9IEFycmF5KG4uc2l6ZSk7XG4gICAgcmV0dXJuIG4uZm9yRWFjaChmdW5jdGlvbihsKSB7XG4gICAgICBvWysrYV0gPSBsO1xuICAgIH0pLCBvO1xuICB9XG4gIHZhciBUdCA9IEFycmF5LnByb3RvdHlwZSwgTXQgPSBGdW5jdGlvbi5wcm90b3R5cGUsIEggPSBPYmplY3QucHJvdG90eXBlLCByZSA9IEFbXCJfX2NvcmUtanNfc2hhcmVkX19cIl0sIHplID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIG4gPSAvW14uXSskLy5leGVjKHJlICYmIHJlLmtleXMgJiYgcmUua2V5cy5JRV9QUk9UTyB8fCBcIlwiKTtcbiAgICByZXR1cm4gbiA/IFwiU3ltYm9sKHNyYylfMS5cIiArIG4gOiBcIlwiO1xuICB9KCksICRlID0gTXQudG9TdHJpbmcsIFQgPSBILmhhc093blByb3BlcnR5LCBWID0gSC50b1N0cmluZywgRHQgPSBSZWdFeHAoXG4gICAgXCJeXCIgKyAkZS5jYWxsKFQpLnJlcGxhY2UoZnQsIFwiXFxcXCQmXCIpLnJlcGxhY2UoL2hhc093blByb3BlcnR5fChmdW5jdGlvbikuKj8oPz1cXFxcXFwoKXwgZm9yIC4rPyg/PVxcXFxcXF0pL2csIFwiJDEuKj9cIikgKyBcIiRcIlxuICApLCBxZSA9IGJ0ID8gQS5CdWZmZXIgOiB2b2lkIDAsIFdlID0gQS5TeW1ib2wsIFVlID0gQS5VaW50OEFycmF5LCBDdCA9IG5lKE9iamVjdC5nZXRQcm90b3R5cGVPZiwgT2JqZWN0KSwgUHQgPSBPYmplY3QuY3JlYXRlLCB4dCA9IEgucHJvcGVydHlJc0VudW1lcmFibGUsIE90ID0gVHQuc3BsaWNlLCBCZSA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMsIEZ0ID0gcWUgPyBxZS5pc0J1ZmZlciA6IHZvaWQgMCwgTHQgPSBuZShPYmplY3Qua2V5cywgT2JqZWN0KSwgaWUgPSBPKEEsIFwiRGF0YVZpZXdcIiksIGsgPSBPKEEsIFwiTWFwXCIpLCBzZSA9IE8oQSwgXCJQcm9taXNlXCIpLCBhZSA9IE8oQSwgXCJTZXRcIiksIG9lID0gTyhBLCBcIldlYWtNYXBcIiksIE4gPSBPKE9iamVjdCwgXCJjcmVhdGVcIiksIGp0ID0gQyhpZSksIGt0ID0gQyhrKSwgTnQgPSBDKHNlKSwgenQgPSBDKGFlKSwgJHQgPSBDKG9lKSwgR2UgPSBXZSA/IFdlLnByb3RvdHlwZSA6IHZvaWQgMCwgSGUgPSBHZSA/IEdlLnZhbHVlT2YgOiB2b2lkIDA7XG4gIGZ1bmN0aW9uIE0obikge1xuICAgIHZhciBhID0gLTEsIG8gPSBuID8gbi5sZW5ndGggOiAwO1xuICAgIGZvciAodGhpcy5jbGVhcigpOyArK2EgPCBvOyApIHtcbiAgICAgIHZhciBsID0gblthXTtcbiAgICAgIHRoaXMuc2V0KGxbMF0sIGxbMV0pO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBxdCgpIHtcbiAgICB0aGlzLl9fZGF0YV9fID0gTiA/IE4obnVsbCkgOiB7fTtcbiAgfVxuICBmdW5jdGlvbiBXdChuKSB7XG4gICAgcmV0dXJuIHRoaXMuaGFzKG4pICYmIGRlbGV0ZSB0aGlzLl9fZGF0YV9fW25dO1xuICB9XG4gIGZ1bmN0aW9uIFV0KG4pIHtcbiAgICB2YXIgYSA9IHRoaXMuX19kYXRhX187XG4gICAgaWYgKE4pIHtcbiAgICAgIHZhciBvID0gYVtuXTtcbiAgICAgIHJldHVybiBvID09PSByID8gdm9pZCAwIDogbztcbiAgICB9XG4gICAgcmV0dXJuIFQuY2FsbChhLCBuKSA/IGFbbl0gOiB2b2lkIDA7XG4gIH1cbiAgZnVuY3Rpb24gQnQobikge1xuICAgIHZhciBhID0gdGhpcy5fX2RhdGFfXztcbiAgICByZXR1cm4gTiA/IGFbbl0gIT09IHZvaWQgMCA6IFQuY2FsbChhLCBuKTtcbiAgfVxuICBmdW5jdGlvbiBHdChuLCBhKSB7XG4gICAgdmFyIG8gPSB0aGlzLl9fZGF0YV9fO1xuICAgIHJldHVybiBvW25dID0gTiAmJiBhID09PSB2b2lkIDAgPyByIDogYSwgdGhpcztcbiAgfVxuICBNLnByb3RvdHlwZS5jbGVhciA9IHF0LCBNLnByb3RvdHlwZS5kZWxldGUgPSBXdCwgTS5wcm90b3R5cGUuZ2V0ID0gVXQsIE0ucHJvdG90eXBlLmhhcyA9IEJ0LCBNLnByb3RvdHlwZS5zZXQgPSBHdDtcbiAgZnVuY3Rpb24gRShuKSB7XG4gICAgdmFyIGEgPSAtMSwgbyA9IG4gPyBuLmxlbmd0aCA6IDA7XG4gICAgZm9yICh0aGlzLmNsZWFyKCk7ICsrYSA8IG87ICkge1xuICAgICAgdmFyIGwgPSBuW2FdO1xuICAgICAgdGhpcy5zZXQobFswXSwgbFsxXSk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIEh0KCkge1xuICAgIHRoaXMuX19kYXRhX18gPSBbXTtcbiAgfVxuICBmdW5jdGlvbiBWdChuKSB7XG4gICAgdmFyIGEgPSB0aGlzLl9fZGF0YV9fLCBvID0gSyhhLCBuKTtcbiAgICBpZiAobyA8IDApXG4gICAgICByZXR1cm4gITE7XG4gICAgdmFyIGwgPSBhLmxlbmd0aCAtIDE7XG4gICAgcmV0dXJuIG8gPT0gbCA/IGEucG9wKCkgOiBPdC5jYWxsKGEsIG8sIDEpLCAhMDtcbiAgfVxuICBmdW5jdGlvbiBLdChuKSB7XG4gICAgdmFyIGEgPSB0aGlzLl9fZGF0YV9fLCBvID0gSyhhLCBuKTtcbiAgICByZXR1cm4gbyA8IDAgPyB2b2lkIDAgOiBhW29dWzFdO1xuICB9XG4gIGZ1bmN0aW9uIFF0KG4pIHtcbiAgICByZXR1cm4gSyh0aGlzLl9fZGF0YV9fLCBuKSA+IC0xO1xuICB9XG4gIGZ1bmN0aW9uIFh0KG4sIGEpIHtcbiAgICB2YXIgbyA9IHRoaXMuX19kYXRhX18sIGwgPSBLKG8sIG4pO1xuICAgIHJldHVybiBsIDwgMCA/IG8ucHVzaChbbiwgYV0pIDogb1tsXVsxXSA9IGEsIHRoaXM7XG4gIH1cbiAgRS5wcm90b3R5cGUuY2xlYXIgPSBIdCwgRS5wcm90b3R5cGUuZGVsZXRlID0gVnQsIEUucHJvdG90eXBlLmdldCA9IEt0LCBFLnByb3RvdHlwZS5oYXMgPSBRdCwgRS5wcm90b3R5cGUuc2V0ID0gWHQ7XG4gIGZ1bmN0aW9uIFAobikge1xuICAgIHZhciBhID0gLTEsIG8gPSBuID8gbi5sZW5ndGggOiAwO1xuICAgIGZvciAodGhpcy5jbGVhcigpOyArK2EgPCBvOyApIHtcbiAgICAgIHZhciBsID0gblthXTtcbiAgICAgIHRoaXMuc2V0KGxbMF0sIGxbMV0pO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBZdCgpIHtcbiAgICB0aGlzLl9fZGF0YV9fID0ge1xuICAgICAgaGFzaDogbmV3IE0oKSxcbiAgICAgIG1hcDogbmV3IChrIHx8IEUpKCksXG4gICAgICBzdHJpbmc6IG5ldyBNKClcbiAgICB9O1xuICB9XG4gIGZ1bmN0aW9uIEp0KG4pIHtcbiAgICByZXR1cm4gUSh0aGlzLCBuKS5kZWxldGUobik7XG4gIH1cbiAgZnVuY3Rpb24gWnQobikge1xuICAgIHJldHVybiBRKHRoaXMsIG4pLmdldChuKTtcbiAgfVxuICBmdW5jdGlvbiBlbihuKSB7XG4gICAgcmV0dXJuIFEodGhpcywgbikuaGFzKG4pO1xuICB9XG4gIGZ1bmN0aW9uIHRuKG4sIGEpIHtcbiAgICByZXR1cm4gUSh0aGlzLCBuKS5zZXQobiwgYSksIHRoaXM7XG4gIH1cbiAgUC5wcm90b3R5cGUuY2xlYXIgPSBZdCwgUC5wcm90b3R5cGUuZGVsZXRlID0gSnQsIFAucHJvdG90eXBlLmdldCA9IFp0LCBQLnByb3RvdHlwZS5oYXMgPSBlbiwgUC5wcm90b3R5cGUuc2V0ID0gdG47XG4gIGZ1bmN0aW9uIHgobikge1xuICAgIHRoaXMuX19kYXRhX18gPSBuZXcgRShuKTtcbiAgfVxuICBmdW5jdGlvbiBubigpIHtcbiAgICB0aGlzLl9fZGF0YV9fID0gbmV3IEUoKTtcbiAgfVxuICBmdW5jdGlvbiBybihuKSB7XG4gICAgcmV0dXJuIHRoaXMuX19kYXRhX18uZGVsZXRlKG4pO1xuICB9XG4gIGZ1bmN0aW9uIHNuKG4pIHtcbiAgICByZXR1cm4gdGhpcy5fX2RhdGFfXy5nZXQobik7XG4gIH1cbiAgZnVuY3Rpb24gYW4obikge1xuICAgIHJldHVybiB0aGlzLl9fZGF0YV9fLmhhcyhuKTtcbiAgfVxuICBmdW5jdGlvbiBvbihuLCBhKSB7XG4gICAgdmFyIG8gPSB0aGlzLl9fZGF0YV9fO1xuICAgIGlmIChvIGluc3RhbmNlb2YgRSkge1xuICAgICAgdmFyIGwgPSBvLl9fZGF0YV9fO1xuICAgICAgaWYgKCFrIHx8IGwubGVuZ3RoIDwgdCAtIDEpXG4gICAgICAgIHJldHVybiBsLnB1c2goW24sIGFdKSwgdGhpcztcbiAgICAgIG8gPSB0aGlzLl9fZGF0YV9fID0gbmV3IFAobCk7XG4gICAgfVxuICAgIHJldHVybiBvLnNldChuLCBhKSwgdGhpcztcbiAgfVxuICB4LnByb3RvdHlwZS5jbGVhciA9IG5uLCB4LnByb3RvdHlwZS5kZWxldGUgPSBybiwgeC5wcm90b3R5cGUuZ2V0ID0gc24sIHgucHJvdG90eXBlLmhhcyA9IGFuLCB4LnByb3RvdHlwZS5zZXQgPSBvbjtcbiAgZnVuY3Rpb24gY24obiwgYSkge1xuICAgIHZhciBvID0gdWUobikgfHwgeG4obikgPyBJdChuLmxlbmd0aCwgU3RyaW5nKSA6IFtdLCBsID0gby5sZW5ndGgsIHcgPSAhIWw7XG4gICAgZm9yICh2YXIgYiBpbiBuKVxuICAgICAgVC5jYWxsKG4sIGIpICYmICEodyAmJiAoYiA9PSBcImxlbmd0aFwiIHx8IE1uKGIsIGwpKSkgJiYgby5wdXNoKGIpO1xuICAgIHJldHVybiBvO1xuICB9XG4gIGZ1bmN0aW9uIFZlKG4sIGEsIG8pIHtcbiAgICB2YXIgbCA9IG5bYV07XG4gICAgKCEoVC5jYWxsKG4sIGEpICYmIFllKGwsIG8pKSB8fCBvID09PSB2b2lkIDAgJiYgIShhIGluIG4pKSAmJiAoblthXSA9IG8pO1xuICB9XG4gIGZ1bmN0aW9uIEsobiwgYSkge1xuICAgIGZvciAodmFyIG8gPSBuLmxlbmd0aDsgby0tOyApXG4gICAgICBpZiAoWWUobltvXVswXSwgYSkpXG4gICAgICAgIHJldHVybiBvO1xuICAgIHJldHVybiAtMTtcbiAgfVxuICBmdW5jdGlvbiBobihuLCBhKSB7XG4gICAgcmV0dXJuIG4gJiYgS2UoYSwgbGUoYSksIG4pO1xuICB9XG4gIGZ1bmN0aW9uIGNlKG4sIGEsIG8sIGwsIHcsIGIsIEkpIHtcbiAgICB2YXIgdjtcbiAgICBpZiAobCAmJiAodiA9IGIgPyBsKG4sIHcsIGIsIEkpIDogbChuKSksIHYgIT09IHZvaWQgMClcbiAgICAgIHJldHVybiB2O1xuICAgIGlmICghWChuKSlcbiAgICAgIHJldHVybiBuO1xuICAgIHZhciBldCA9IHVlKG4pO1xuICAgIGlmIChldCkge1xuICAgICAgaWYgKHYgPSBJbihuKSwgIWEpXG4gICAgICAgIHJldHVybiBSbihuLCB2KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIEYgPSBEKG4pLCB0dCA9IEYgPT0gcCB8fCBGID09IFI7XG4gICAgICBpZiAoRm4obikpXG4gICAgICAgIHJldHVybiBfbihuLCBhKTtcbiAgICAgIGlmIChGID09IGVlIHx8IEYgPT0gYyB8fCB0dCAmJiAhYikge1xuICAgICAgICBpZiAoamUobikpXG4gICAgICAgICAgcmV0dXJuIGIgPyBuIDoge307XG4gICAgICAgIGlmICh2ID0gU24odHQgPyB7fSA6IG4pLCAhYSlcbiAgICAgICAgICByZXR1cm4gQW4obiwgaG4odiwgbikpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKCFfW0ZdKVxuICAgICAgICAgIHJldHVybiBiID8gbiA6IHt9O1xuICAgICAgICB2ID0gVG4obiwgRiwgY2UsIGEpO1xuICAgICAgfVxuICAgIH1cbiAgICBJIHx8IChJID0gbmV3IHgoKSk7XG4gICAgdmFyIG50ID0gSS5nZXQobik7XG4gICAgaWYgKG50KVxuICAgICAgcmV0dXJuIG50O1xuICAgIGlmIChJLnNldChuLCB2KSwgIWV0KVxuICAgICAgdmFyIHJ0ID0gbyA/IEVuKG4pIDogbGUobik7XG4gICAgcmV0dXJuIEF0KHJ0IHx8IG4sIGZ1bmN0aW9uKGRlLCBZKSB7XG4gICAgICBydCAmJiAoWSA9IGRlLCBkZSA9IG5bWV0pLCBWZSh2LCBZLCBjZShkZSwgYSwgbywgbCwgWSwgbiwgSSkpO1xuICAgIH0pLCB2O1xuICB9XG4gIGZ1bmN0aW9uIHVuKG4pIHtcbiAgICByZXR1cm4gWChuKSA/IFB0KG4pIDoge307XG4gIH1cbiAgZnVuY3Rpb24gbG4obiwgYSwgbykge1xuICAgIHZhciBsID0gYShuKTtcbiAgICByZXR1cm4gdWUobikgPyBsIDogRXQobCwgbyhuKSk7XG4gIH1cbiAgZnVuY3Rpb24gZG4obikge1xuICAgIHJldHVybiBWLmNhbGwobik7XG4gIH1cbiAgZnVuY3Rpb24gZ24obikge1xuICAgIGlmICghWChuKSB8fCBDbihuKSlcbiAgICAgIHJldHVybiAhMTtcbiAgICB2YXIgYSA9IFplKG4pIHx8IGplKG4pID8gRHQgOiBtdDtcbiAgICByZXR1cm4gYS50ZXN0KEMobikpO1xuICB9XG4gIGZ1bmN0aW9uIGZuKG4pIHtcbiAgICBpZiAoIVhlKG4pKVxuICAgICAgcmV0dXJuIEx0KG4pO1xuICAgIHZhciBhID0gW107XG4gICAgZm9yICh2YXIgbyBpbiBPYmplY3QobikpXG4gICAgICBULmNhbGwobiwgbykgJiYgbyAhPSBcImNvbnN0cnVjdG9yXCIgJiYgYS5wdXNoKG8pO1xuICAgIHJldHVybiBhO1xuICB9XG4gIGZ1bmN0aW9uIF9uKG4sIGEpIHtcbiAgICBpZiAoYSlcbiAgICAgIHJldHVybiBuLnNsaWNlKCk7XG4gICAgdmFyIG8gPSBuZXcgbi5jb25zdHJ1Y3RvcihuLmxlbmd0aCk7XG4gICAgcmV0dXJuIG4uY29weShvKSwgbztcbiAgfVxuICBmdW5jdGlvbiBoZShuKSB7XG4gICAgdmFyIGEgPSBuZXcgbi5jb25zdHJ1Y3RvcihuLmJ5dGVMZW5ndGgpO1xuICAgIHJldHVybiBuZXcgVWUoYSkuc2V0KG5ldyBVZShuKSksIGE7XG4gIH1cbiAgZnVuY3Rpb24gbW4obiwgYSkge1xuICAgIHZhciBvID0gYSA/IGhlKG4uYnVmZmVyKSA6IG4uYnVmZmVyO1xuICAgIHJldHVybiBuZXcgbi5jb25zdHJ1Y3RvcihvLCBuLmJ5dGVPZmZzZXQsIG4uYnl0ZUxlbmd0aCk7XG4gIH1cbiAgZnVuY3Rpb24gcG4obiwgYSwgbykge1xuICAgIHZhciBsID0gYSA/IG8oa2UobiksICEwKSA6IGtlKG4pO1xuICAgIHJldHVybiBMZShsLCB2dCwgbmV3IG4uY29uc3RydWN0b3IoKSk7XG4gIH1cbiAgZnVuY3Rpb24geW4obikge1xuICAgIHZhciBhID0gbmV3IG4uY29uc3RydWN0b3Iobi5zb3VyY2UsIF90LmV4ZWMobikpO1xuICAgIHJldHVybiBhLmxhc3RJbmRleCA9IG4ubGFzdEluZGV4LCBhO1xuICB9XG4gIGZ1bmN0aW9uIHduKG4sIGEsIG8pIHtcbiAgICB2YXIgbCA9IGEgPyBvKE5lKG4pLCAhMCkgOiBOZShuKTtcbiAgICByZXR1cm4gTGUobCwgUnQsIG5ldyBuLmNvbnN0cnVjdG9yKCkpO1xuICB9XG4gIGZ1bmN0aW9uIGJuKG4pIHtcbiAgICByZXR1cm4gSGUgPyBPYmplY3QoSGUuY2FsbChuKSkgOiB7fTtcbiAgfVxuICBmdW5jdGlvbiB2bihuLCBhKSB7XG4gICAgdmFyIG8gPSBhID8gaGUobi5idWZmZXIpIDogbi5idWZmZXI7XG4gICAgcmV0dXJuIG5ldyBuLmNvbnN0cnVjdG9yKG8sIG4uYnl0ZU9mZnNldCwgbi5sZW5ndGgpO1xuICB9XG4gIGZ1bmN0aW9uIFJuKG4sIGEpIHtcbiAgICB2YXIgbyA9IC0xLCBsID0gbi5sZW5ndGg7XG4gICAgZm9yIChhIHx8IChhID0gQXJyYXkobCkpOyArK28gPCBsOyApXG4gICAgICBhW29dID0gbltvXTtcbiAgICByZXR1cm4gYTtcbiAgfVxuICBmdW5jdGlvbiBLZShuLCBhLCBvLCBsKSB7XG4gICAgbyB8fCAobyA9IHt9KTtcbiAgICBmb3IgKHZhciB3ID0gLTEsIGIgPSBhLmxlbmd0aDsgKyt3IDwgYjsgKSB7XG4gICAgICB2YXIgSSA9IGFbd10sIHYgPSB2b2lkIDA7XG4gICAgICBWZShvLCBJLCB2ID09PSB2b2lkIDAgPyBuW0ldIDogdik7XG4gICAgfVxuICAgIHJldHVybiBvO1xuICB9XG4gIGZ1bmN0aW9uIEFuKG4sIGEpIHtcbiAgICByZXR1cm4gS2UobiwgUWUobiksIGEpO1xuICB9XG4gIGZ1bmN0aW9uIEVuKG4pIHtcbiAgICByZXR1cm4gbG4obiwgbGUsIFFlKTtcbiAgfVxuICBmdW5jdGlvbiBRKG4sIGEpIHtcbiAgICB2YXIgbyA9IG4uX19kYXRhX187XG4gICAgcmV0dXJuIERuKGEpID8gb1t0eXBlb2YgYSA9PSBcInN0cmluZ1wiID8gXCJzdHJpbmdcIiA6IFwiaGFzaFwiXSA6IG8ubWFwO1xuICB9XG4gIGZ1bmN0aW9uIE8obiwgYSkge1xuICAgIHZhciBvID0gU3QobiwgYSk7XG4gICAgcmV0dXJuIGduKG8pID8gbyA6IHZvaWQgMDtcbiAgfVxuICB2YXIgUWUgPSBCZSA/IG5lKEJlLCBPYmplY3QpIDoga24sIEQgPSBkbjtcbiAgKGllICYmIEQobmV3IGllKG5ldyBBcnJheUJ1ZmZlcigxKSkpICE9IEcgfHwgayAmJiBEKG5ldyBrKCkpICE9IFUgfHwgc2UgJiYgRChzZS5yZXNvbHZlKCkpICE9IHdlIHx8IGFlICYmIEQobmV3IGFlKCkpICE9IEIgfHwgb2UgJiYgRChuZXcgb2UoKSkgIT0gdGUpICYmIChEID0gZnVuY3Rpb24obikge1xuICAgIHZhciBhID0gVi5jYWxsKG4pLCBvID0gYSA9PSBlZSA/IG4uY29uc3RydWN0b3IgOiB2b2lkIDAsIGwgPSBvID8gQyhvKSA6IHZvaWQgMDtcbiAgICBpZiAobClcbiAgICAgIHN3aXRjaCAobCkge1xuICAgICAgICBjYXNlIGp0OlxuICAgICAgICAgIHJldHVybiBHO1xuICAgICAgICBjYXNlIGt0OlxuICAgICAgICAgIHJldHVybiBVO1xuICAgICAgICBjYXNlIE50OlxuICAgICAgICAgIHJldHVybiB3ZTtcbiAgICAgICAgY2FzZSB6dDpcbiAgICAgICAgICByZXR1cm4gQjtcbiAgICAgICAgY2FzZSAkdDpcbiAgICAgICAgICByZXR1cm4gdGU7XG4gICAgICB9XG4gICAgcmV0dXJuIGE7XG4gIH0pO1xuICBmdW5jdGlvbiBJbihuKSB7XG4gICAgdmFyIGEgPSBuLmxlbmd0aCwgbyA9IG4uY29uc3RydWN0b3IoYSk7XG4gICAgcmV0dXJuIGEgJiYgdHlwZW9mIG5bMF0gPT0gXCJzdHJpbmdcIiAmJiBULmNhbGwobiwgXCJpbmRleFwiKSAmJiAoby5pbmRleCA9IG4uaW5kZXgsIG8uaW5wdXQgPSBuLmlucHV0KSwgbztcbiAgfVxuICBmdW5jdGlvbiBTbihuKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBuLmNvbnN0cnVjdG9yID09IFwiZnVuY3Rpb25cIiAmJiAhWGUobikgPyB1bihDdChuKSkgOiB7fTtcbiAgfVxuICBmdW5jdGlvbiBUbihuLCBhLCBvLCBsKSB7XG4gICAgdmFyIHcgPSBuLmNvbnN0cnVjdG9yO1xuICAgIHN3aXRjaCAoYSkge1xuICAgICAgY2FzZSBBZTpcbiAgICAgICAgcmV0dXJuIGhlKG4pO1xuICAgICAgY2FzZSBnOlxuICAgICAgY2FzZSBmOlxuICAgICAgICByZXR1cm4gbmV3IHcoK24pO1xuICAgICAgY2FzZSBHOlxuICAgICAgICByZXR1cm4gbW4obiwgbCk7XG4gICAgICBjYXNlIEVlOlxuICAgICAgY2FzZSBJZTpcbiAgICAgIGNhc2UgU2U6XG4gICAgICBjYXNlIFRlOlxuICAgICAgY2FzZSBNZTpcbiAgICAgIGNhc2UgRGU6XG4gICAgICBjYXNlIENlOlxuICAgICAgY2FzZSBQZTpcbiAgICAgIGNhc2UgeGU6XG4gICAgICAgIHJldHVybiB2bihuLCBsKTtcbiAgICAgIGNhc2UgVTpcbiAgICAgICAgcmV0dXJuIHBuKG4sIGwsIG8pO1xuICAgICAgY2FzZSB5ZTpcbiAgICAgIGNhc2UgdmU6XG4gICAgICAgIHJldHVybiBuZXcgdyhuKTtcbiAgICAgIGNhc2UgYmU6XG4gICAgICAgIHJldHVybiB5bihuKTtcbiAgICAgIGNhc2UgQjpcbiAgICAgICAgcmV0dXJuIHduKG4sIGwsIG8pO1xuICAgICAgY2FzZSBSZTpcbiAgICAgICAgcmV0dXJuIGJuKG4pO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBNbihuLCBhKSB7XG4gICAgcmV0dXJuIGEgPSBhID8/IHMsICEhYSAmJiAodHlwZW9mIG4gPT0gXCJudW1iZXJcIiB8fCBwdC50ZXN0KG4pKSAmJiBuID4gLTEgJiYgbiAlIDEgPT0gMCAmJiBuIDwgYTtcbiAgfVxuICBmdW5jdGlvbiBEbihuKSB7XG4gICAgdmFyIGEgPSB0eXBlb2YgbjtcbiAgICByZXR1cm4gYSA9PSBcInN0cmluZ1wiIHx8IGEgPT0gXCJudW1iZXJcIiB8fCBhID09IFwic3ltYm9sXCIgfHwgYSA9PSBcImJvb2xlYW5cIiA/IG4gIT09IFwiX19wcm90b19fXCIgOiBuID09PSBudWxsO1xuICB9XG4gIGZ1bmN0aW9uIENuKG4pIHtcbiAgICByZXR1cm4gISF6ZSAmJiB6ZSBpbiBuO1xuICB9XG4gIGZ1bmN0aW9uIFhlKG4pIHtcbiAgICB2YXIgYSA9IG4gJiYgbi5jb25zdHJ1Y3RvciwgbyA9IHR5cGVvZiBhID09IFwiZnVuY3Rpb25cIiAmJiBhLnByb3RvdHlwZSB8fCBIO1xuICAgIHJldHVybiBuID09PSBvO1xuICB9XG4gIGZ1bmN0aW9uIEMobikge1xuICAgIGlmIChuICE9IG51bGwpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiAkZS5jYWxsKG4pO1xuICAgICAgfSBjYXRjaCB7XG4gICAgICB9XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gbiArIFwiXCI7XG4gICAgICB9IGNhdGNoIHtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIFwiXCI7XG4gIH1cbiAgZnVuY3Rpb24gUG4obikge1xuICAgIHJldHVybiBjZShuLCAhMCwgITApO1xuICB9XG4gIGZ1bmN0aW9uIFllKG4sIGEpIHtcbiAgICByZXR1cm4gbiA9PT0gYSB8fCBuICE9PSBuICYmIGEgIT09IGE7XG4gIH1cbiAgZnVuY3Rpb24geG4obikge1xuICAgIHJldHVybiBPbihuKSAmJiBULmNhbGwobiwgXCJjYWxsZWVcIikgJiYgKCF4dC5jYWxsKG4sIFwiY2FsbGVlXCIpIHx8IFYuY2FsbChuKSA9PSBjKTtcbiAgfVxuICB2YXIgdWUgPSBBcnJheS5pc0FycmF5O1xuICBmdW5jdGlvbiBKZShuKSB7XG4gICAgcmV0dXJuIG4gIT0gbnVsbCAmJiBMbihuLmxlbmd0aCkgJiYgIVplKG4pO1xuICB9XG4gIGZ1bmN0aW9uIE9uKG4pIHtcbiAgICByZXR1cm4gam4obikgJiYgSmUobik7XG4gIH1cbiAgdmFyIEZuID0gRnQgfHwgTm47XG4gIGZ1bmN0aW9uIFplKG4pIHtcbiAgICB2YXIgYSA9IFgobikgPyBWLmNhbGwobikgOiBcIlwiO1xuICAgIHJldHVybiBhID09IHAgfHwgYSA9PSBSO1xuICB9XG4gIGZ1bmN0aW9uIExuKG4pIHtcbiAgICByZXR1cm4gdHlwZW9mIG4gPT0gXCJudW1iZXJcIiAmJiBuID4gLTEgJiYgbiAlIDEgPT0gMCAmJiBuIDw9IHM7XG4gIH1cbiAgZnVuY3Rpb24gWChuKSB7XG4gICAgdmFyIGEgPSB0eXBlb2YgbjtcbiAgICByZXR1cm4gISFuICYmIChhID09IFwib2JqZWN0XCIgfHwgYSA9PSBcImZ1bmN0aW9uXCIpO1xuICB9XG4gIGZ1bmN0aW9uIGpuKG4pIHtcbiAgICByZXR1cm4gISFuICYmIHR5cGVvZiBuID09IFwib2JqZWN0XCI7XG4gIH1cbiAgZnVuY3Rpb24gbGUobikge1xuICAgIHJldHVybiBKZShuKSA/IGNuKG4pIDogZm4obik7XG4gIH1cbiAgZnVuY3Rpb24ga24oKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG4gIGZ1bmN0aW9uIE5uKCkge1xuICAgIHJldHVybiAhMTtcbiAgfVxuICBpLmV4cG9ydHMgPSBQbjtcbn0pKFosIFouZXhwb3J0cyk7XG52YXIgSm4gPSBaLmV4cG9ydHM7XG5jb25zdCBabiA9IC8qIEBfX1BVUkVfXyAqLyBZbihKbik7XG52YXIgbSA9IC8qIEBfX1BVUkVfXyAqLyAoKGkpID0+IChpW2kuTWVzc2FnZXNBdHRhY2htZW50RmFpbGVkID0gMTAyMDAxXSA9IFwiTWVzc2FnZXNBdHRhY2htZW50RmFpbGVkXCIsIGlbaS5QcmVzZW5jZUF0dGFjaG1lbnRGYWlsZWQgPSAxMDIwMDJdID0gXCJQcmVzZW5jZUF0dGFjaG1lbnRGYWlsZWRcIiwgaVtpLlJlYWN0aW9uc0F0dGFjaG1lbnRGYWlsZWQgPSAxMDIwMDNdID0gXCJSZWFjdGlvbnNBdHRhY2htZW50RmFpbGVkXCIsIGlbaS5PY2N1cGFuY3lBdHRhY2htZW50RmFpbGVkID0gMTAyMDA0XSA9IFwiT2NjdXBhbmN5QXR0YWNobWVudEZhaWxlZFwiLCBpW2kuVHlwaW5nQXR0YWNobWVudEZhaWxlZCA9IDEwMjAwNV0gPSBcIlR5cGluZ0F0dGFjaG1lbnRGYWlsZWRcIiwgaVtpLk1lc3NhZ2VzRGV0YWNobWVudEZhaWxlZCA9IDEwMjA1MF0gPSBcIk1lc3NhZ2VzRGV0YWNobWVudEZhaWxlZFwiLCBpW2kuUHJlc2VuY2VEZXRhY2htZW50RmFpbGVkID0gMTAyMDUxXSA9IFwiUHJlc2VuY2VEZXRhY2htZW50RmFpbGVkXCIsIGlbaS5SZWFjdGlvbnNEZXRhY2htZW50RmFpbGVkID0gMTAyMDUyXSA9IFwiUmVhY3Rpb25zRGV0YWNobWVudEZhaWxlZFwiLCBpW2kuT2NjdXBhbmN5RGV0YWNobWVudEZhaWxlZCA9IDEwMjA1M10gPSBcIk9jY3VwYW5jeURldGFjaG1lbnRGYWlsZWRcIiwgaVtpLlR5cGluZ0RldGFjaG1lbnRGYWlsZWQgPSAxMDIwNTRdID0gXCJUeXBpbmdEZXRhY2htZW50RmFpbGVkXCIsIGlbaS5Sb29tRGlzY29udGludWl0eSA9IDEwMjEwMF0gPSBcIlJvb21EaXNjb250aW51aXR5XCIsIGlbaS5Sb29tSW5GYWlsZWRTdGF0ZSA9IDEwMjEwMV0gPSBcIlJvb21JbkZhaWxlZFN0YXRlXCIsIGlbaS5Sb29tSXNSZWxlYXNpbmcgPSAxMDIxMDJdID0gXCJSb29tSXNSZWxlYXNpbmdcIiwgaVtpLlJvb21Jc1JlbGVhc2VkID0gMTAyMTAzXSA9IFwiUm9vbUlzUmVsZWFzZWRcIiwgaVtpLlByZXZpb3VzT3BlcmF0aW9uRmFpbGVkID0gMTAyMTA0XSA9IFwiUHJldmlvdXNPcGVyYXRpb25GYWlsZWRcIiwgaVtpLlJvb21MaWZlY3ljbGVFcnJvciA9IDEwMjEwNV0gPSBcIlJvb21MaWZlY3ljbGVFcnJvclwiLCBpKSkobSB8fCB7fSk7XG5jb25zdCBEciA9IChpLCBlKSA9PiBpLmNvZGUgPT09IGUsIGdlID0gXCIwLjIuMVwiLCBlciA9IGBjaGF0LWpzLyR7Z2V9YCwgdHIgPSB7IHBhcmFtczogeyBhZ2VudDogZXIgfSB9LCBxID0gKGksIGUsIHQpID0+IHtcbiAgY29uc3QgciA9IHtcbiAgICAuLi50LFxuICAgIHBhcmFtczoge1xuICAgICAgLi4udCA9PSBudWxsID8gdm9pZCAwIDogdC5wYXJhbXMsXG4gICAgICAuLi50ci5wYXJhbXNcbiAgICB9XG4gIH07XG4gIHJldHVybiBlLmNoYW5uZWxzLmdldChpLCByKTtcbn0sIF9lID0gKGkpID0+IGAke2l9OjokY2hhdDo6JGNoYXRNZXNzYWdlc2AsIFcgPSAoKSA9PiBuZXcgUygpO1xudmFyIEwgPSAvKiBAX19QVVJFX18gKi8gKChpKSA9PiAoaS5DcmVhdGVkID0gXCJtZXNzYWdlLmNyZWF0ZWRcIiwgaSkpKEwgfHwge30pLCBuciA9IC8qIEBfX1BVUkVfXyAqLyAoKGkpID0+IChpLkVudGVyID0gXCJlbnRlclwiLCBpLkxlYXZlID0gXCJsZWF2ZVwiLCBpLlVwZGF0ZSA9IFwidXBkYXRlXCIsIGkuUHJlc2VudCA9IFwicHJlc2VudFwiLCBpKSkobnIgfHwge30pLCBjdCA9IC8qIEBfX1BVUkVfXyAqLyAoKGkpID0+IChpLkNoYW5nZWQgPSBcInR5cGluZy5jaGFuZ2VkXCIsIGkpKShjdCB8fCB7fSksIHogPSAvKiBAX19QVVJFX18gKi8gKChpKSA9PiAoaS5SZWFjdGlvbiA9IFwicm9vbVJlYWN0aW9uXCIsIGkpKSh6IHx8IHt9KTtcbmZ1bmN0aW9uIGh0KGksIGUpIHtcbiAgY29uc3QgdCA9IGU7XG4gIGlmICghaSlcbiAgICB0aHJvdyBuZXcgaC5FcnJvckluZm8oXCJyZWNlaXZlZCBpbmNvbWluZyBtZXNzYWdlIHdpdGhvdXQgcm9vbUlkXCIsIDVlNCwgNTAwKTtcbiAgaWYgKCF0LmRhdGEpXG4gICAgdGhyb3cgbmV3IGguRXJyb3JJbmZvKFwicmVjZWl2ZWQgaW5jb21pbmcgbWVzc2FnZSB3aXRob3V0IGRhdGFcIiwgNWU0LCA1MDApO1xuICBpZiAoIXQuY2xpZW50SWQpXG4gICAgdGhyb3cgbmV3IGguRXJyb3JJbmZvKFwicmVjZWl2ZWQgaW5jb21pbmcgbWVzc2FnZSB3aXRob3V0IGNsaWVudElkXCIsIDVlNCwgNTAwKTtcbiAgaWYgKCF0LnRpbWVzdGFtcClcbiAgICB0aHJvdyBuZXcgaC5FcnJvckluZm8oXCJyZWNlaXZlZCBpbmNvbWluZyBtZXNzYWdlIHdpdGhvdXQgdGltZXN0YW1wXCIsIDVlNCwgNTAwKTtcbiAgaWYgKHQuZGF0YS50ZXh0ID09PSB2b2lkIDApXG4gICAgdGhyb3cgbmV3IGguRXJyb3JJbmZvKFwicmVjZWl2ZWQgaW5jb21pbmcgbWVzc2FnZSB3aXRob3V0IHRleHRcIiwgNWU0LCA1MDApO1xuICBpZiAoIXQuZXh0cmFzKVxuICAgIHRocm93IG5ldyBoLkVycm9ySW5mbyhcInJlY2VpdmVkIGluY29taW5nIG1lc3NhZ2Ugd2l0aG91dCBleHRyYXNcIiwgNWU0LCA1MDApO1xuICBpZiAoIXQuZXh0cmFzLnRpbWVzZXJpYWwpXG4gICAgdGhyb3cgbmV3IGguRXJyb3JJbmZvKFwicmVjZWl2ZWQgaW5jb21pbmcgbWVzc2FnZSB3aXRob3V0IHRpbWVzZXJpYWxcIiwgNWU0LCA1MDApO1xuICByZXR1cm4gbmV3IGZlKFxuICAgIHQuZXh0cmFzLnRpbWVzZXJpYWwsXG4gICAgdC5jbGllbnRJZCxcbiAgICBpLFxuICAgIHQuZGF0YS50ZXh0LFxuICAgIG5ldyBEYXRlKHQudGltZXN0YW1wKSxcbiAgICB0LmRhdGEubWV0YWRhdGEgPz8ge30sXG4gICAgdC5leHRyYXMuaGVhZGVycyA/PyB7fVxuICApO1xufVxuY29uc3QgbWUgPSAoaSkgPT4ge1xuICBjb25zdCBlID0gaS5jaGFubmVsLnN1YnNjcmlwdGlvbnM7XG4gIGx0KGUsIGkubGlzdGVuZXIsIGkuZXZlbnRzKTtcbn0sIHV0ID0gKGkpID0+IHtcbiAgY29uc3QgZSA9IGkuY2hhbm5lbC5wcmVzZW5jZS5zdWJzY3JpcHRpb25zO1xuICBsdChlLCBpLmxpc3RlbmVyLCBpLmV2ZW50cyk7XG59LCBsdCA9IChpLCBlLCB0KSA9PiB7XG4gIGlmICh0KSB7XG4gICAgaS5vbih0LCBlKTtcbiAgICByZXR1cm47XG4gIH1cbiAgaS5vbihlKTtcbn07XG5jbGFzcyByciBleHRlbmRzIFMge1xuICAvKipcbiAgICogQ29uc3RydWN0cyBhIG5ldyBgRGVmYXVsdE1lc3NhZ2VzYCBpbnN0YW5jZS5cbiAgICogQHBhcmFtIHJvb21JZCBUaGUgdW5pcXVlIGlkZW50aWZpZXIgb2YgdGhlIHJvb20uXG4gICAqIEBwYXJhbSByZWFsdGltZSBBbiBpbnN0YW5jZSBvZiB0aGUgQWJseSBSZWFsdGltZSBjbGllbnQuXG4gICAqIEBwYXJhbSBjaGF0QXBpIEFuIGluc3RhbmNlIG9mIHRoZSBDaGF0QXBpLlxuICAgKiBAcGFyYW0gY2xpZW50SWQgVGhlIGNsaWVudCBJRCBvZiB0aGUgdXNlci5cbiAgICogQHBhcmFtIGxvZ2dlciBBbiBpbnN0YW5jZSBvZiB0aGUgTG9nZ2VyLlxuICAgKiBAcGFyYW0gaW5pdEFmdGVyIEEgcHJvbWlzZSB0aGF0IGlzIGF3YWl0ZWQgYmVmb3JlIGNyZWF0aW5nIGFueSBjaGFubmVscy5cbiAgICovXG4gIGNvbnN0cnVjdG9yKGUsIHQsIHIsIHMsIGMsIHUpIHtcbiAgICBzdXBlcigpLCB0aGlzLl9kaXNjb250aW51aXR5RW1pdHRlciA9IFcoKSwgdGhpcy5fcm9vbUlkID0gZSwgdGhpcy5fY2hhbm5lbCA9IHUudGhlbigoKSA9PiB0aGlzLl9tYWtlQ2hhbm5lbChlLCB0KSksIHRoaXMuX2NoYW5uZWwuY2F0Y2goKGcpID0+IHtcbiAgICAgIGMuZGVidWcoXCJNZXNzYWdlczogY2hhbm5lbCBpbml0aWFsaXphdGlvbiBjYW5jZWxlZFwiLCB7IHJvb21JZDogZSwgZXJyb3I6IGcgfSk7XG4gICAgfSksIHRoaXMuX2NoYXRBcGkgPSByLCB0aGlzLl9jbGllbnRJZCA9IHMsIHRoaXMuX2xvZ2dlciA9IGMsIHRoaXMuX2xpc3RlbmVyU3Vic2NyaXB0aW9uUG9pbnRzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlcyB0aGUgcmVhbHRpbWUgY2hhbm5lbCBmb3IgbWVzc2FnZXMuIENhbGxlZCBhZnRlciBpbml0QWZ0ZXIgaXMgcmVzb2x2ZWQuXG4gICAqL1xuICBfbWFrZUNoYW5uZWwoZSwgdCkge1xuICAgIGNvbnN0IHIgPSBxKF9lKGUpLCB0KTtcbiAgICByZXR1cm4gbWUoe1xuICAgICAgbGlzdGVuZXI6IHRoaXMuX3Byb2Nlc3NFdmVudC5iaW5kKHRoaXMpLFxuICAgICAgZXZlbnRzOiBbTC5DcmVhdGVkXSxcbiAgICAgIGNoYW5uZWw6IHJcbiAgICB9KSwgci5vbihcImF0dGFjaGVkXCIsIChzKSA9PiB7XG4gICAgICB0aGlzLl9oYW5kbGVBdHRhY2gocy5yZXN1bWVkKTtcbiAgICB9KSwgci5vbihcInVwZGF0ZVwiLCAocykgPT4ge1xuICAgICAgcy5jdXJyZW50ID09PSBcImF0dGFjaGVkXCIgJiYgcy5wcmV2aW91cyA9PT0gXCJhdHRhY2hlZFwiICYmIHRoaXMuX2hhbmRsZUF0dGFjaChzLnJlc3VtZWQpO1xuICAgIH0pLCByO1xuICB9XG4gIC8qKlxuICAgKiBAaW5oZXJpdGRvYyBNZXNzYWdlc1xuICAgKi9cbiAgYXN5bmMgX2dldEJlZm9yZVN1YnNjcmlwdGlvblN0YXJ0KGUsIHQpIHtcbiAgICB0aGlzLl9sb2dnZXIudHJhY2UoXCJEZWZhdWx0U3Vic2NyaXB0aW9uTWFuYWdlci5nZXRCZWZvcmVTdWJzY3JpcHRpb25TdGFydCgpO1wiKTtcbiAgICBjb25zdCByID0gdGhpcy5fbGlzdGVuZXJTdWJzY3JpcHRpb25Qb2ludHMuZ2V0KGUpO1xuICAgIGlmIChyID09PSB2b2lkIDApXG4gICAgICB0aHJvdyB0aGlzLl9sb2dnZXIuZXJyb3IoXG4gICAgICAgIFwiRGVmYXVsdFN1YnNjcmlwdGlvbk1hbmFnZXIuZ2V0QmVmb3JlU3Vic2NyaXB0aW9uU3RhcnQoKTsgbGlzdGVuZXIgaGFzIG5vdCBiZWVuIHN1YnNjcmliZWQgeWV0XCJcbiAgICAgICksIG5ldyBoLkVycm9ySW5mbyhcbiAgICAgICAgXCJjYW5ub3QgcXVlcnkgaGlzdG9yeTsgbGlzdGVuZXIgaGFzIG5vdCBiZWVuIHN1YnNjcmliZWQgeWV0XCIsXG4gICAgICAgIDRlNCxcbiAgICAgICAgNDAwXG4gICAgICApO1xuICAgIGNvbnN0IHMgPSBhd2FpdCByLCBjID0gJC5jYWxjdWxhdGVUaW1lc2VyaWFsKHMuZnJvbVNlcmlhbCk7XG4gICAgaWYgKHQuZW5kICYmIHQuZW5kID4gYy50aW1lc3RhbXApXG4gICAgICB0aHJvdyB0aGlzLl9sb2dnZXIuZXJyb3IoXG4gICAgICAgIFwiRGVmYXVsdFN1YnNjcmlwdGlvbk1hbmFnZXIuZ2V0QmVmb3JlU3Vic2NyaXB0aW9uU3RhcnQoKTsgZW5kIHRpbWUgaXMgYWZ0ZXIgdGhlIHN1YnNjcmlwdGlvbiBwb2ludCBvZiB0aGUgbGlzdGVuZXJcIixcbiAgICAgICAge1xuICAgICAgICAgIGVuZFRpbWU6IHQuZW5kLFxuICAgICAgICAgIHN1YnNjcmlwdGlvblRpbWU6IGMudGltZXN0YW1wXG4gICAgICAgIH1cbiAgICAgICksIG5ldyBoLkVycm9ySW5mbyhcbiAgICAgICAgXCJjYW5ub3QgcXVlcnkgaGlzdG9yeTsgZW5kIHRpbWUgaXMgYWZ0ZXIgdGhlIHN1YnNjcmlwdGlvbiBwb2ludCBvZiB0aGUgbGlzdGVuZXJcIixcbiAgICAgICAgNGU0LFxuICAgICAgICA0MDBcbiAgICAgICk7XG4gICAgcmV0dXJuIHRoaXMuX2NoYXRBcGkuZ2V0TWVzc2FnZXModGhpcy5fcm9vbUlkLCB7XG4gICAgICAuLi50LFxuICAgICAgZGlyZWN0aW9uOiBcImJhY2t3YXJkc1wiLFxuICAgICAgLi4uc1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBIYW5kbGUgdGhlIGNhc2Ugd2hlcmUgdGhlIGNoYW5uZWwgZXhwZXJpZW5jZXMgYSBkZXRhY2ggYW5kIHJlYXR0YWNoZXMuXG4gICAqL1xuICBfaGFuZGxlQXR0YWNoKGUpIHtcbiAgICBpZiAodGhpcy5fbG9nZ2VyLnRyYWNlKFwiRGVmYXVsdFN1YnNjcmlwdGlvbk1hbmFnZXIuaGFuZGxlQXR0YWNoKCk7XCIpLCBlKSByZXR1cm47XG4gICAgY29uc3QgdCA9IHRoaXMuX3N1YnNjcmliZUF0Q2hhbm5lbEF0dGFjaCgpO1xuICAgIGZvciAoY29uc3QgW3JdIG9mIHRoaXMuX2xpc3RlbmVyU3Vic2NyaXB0aW9uUG9pbnRzLmVudHJpZXMoKSlcbiAgICAgIHRoaXMuX2xpc3RlbmVyU3Vic2NyaXB0aW9uUG9pbnRzLnNldChyLCB0KTtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlIGEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHdpdGggdGhlIGF0dGFjaFNlcmlhbCBvZiB0aGUgY2hhbm5lbCBvciB0aGUgdGltZXNlcmlhbCBvZiB0aGUgbGF0ZXN0IG1lc3NhZ2UuXG4gICAqL1xuICBhc3luYyBfcmVzb2x2ZVN1YnNjcmlwdGlvblN0YXJ0KCkge1xuICAgIGNvbnN0IGUgPSBhd2FpdCB0aGlzLl9nZXRDaGFubmVsUHJvcGVydGllcygpO1xuICAgIGlmIChlLnN0YXRlID09PSBcImF0dGFjaGVkXCIpIHtcbiAgICAgIGlmIChlLnByb3BlcnRpZXMuY2hhbm5lbFNlcmlhbClcbiAgICAgICAgcmV0dXJuIHsgZnJvbVNlcmlhbDogZS5wcm9wZXJ0aWVzLmNoYW5uZWxTZXJpYWwgfTtcbiAgICAgIHRocm93IHRoaXMuX2xvZ2dlci5lcnJvcihcIkRlZmF1bHRTdWJzY3JpcHRpb25NYW5hZ2VyLmhhbmRsZUF0dGFjaCgpOyBjaGFubmVsU2VyaWFsIGlzIHVuZGVmaW5lZFwiKSwgbmV3IGguRXJyb3JJbmZvKFwiY2hhbm5lbCBpcyBhdHRhY2hlZCwgYnV0IGNoYW5uZWxTZXJpYWwgaXMgbm90IGRlZmluZWRcIiwgNGU0LCA0MDApO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fc3Vic2NyaWJlQXRDaGFubmVsQXR0YWNoKCk7XG4gIH1cbiAgYXN5bmMgX2dldENoYW5uZWxQcm9wZXJ0aWVzKCkge1xuICAgIHJldHVybiBhd2FpdCB0aGlzLl9jaGFubmVsO1xuICB9XG4gIGFzeW5jIF9zdWJzY3JpYmVBdENoYW5uZWxBdHRhY2goKSB7XG4gICAgY29uc3QgZSA9IGF3YWl0IHRoaXMuX2dldENoYW5uZWxQcm9wZXJ0aWVzKCk7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKCh0LCByKSA9PiB7XG4gICAgICBlLnN0YXRlID09PSBcImF0dGFjaGVkXCIgJiYgKHRoaXMuX2xvZ2dlci5kZWJ1ZyhcIk1lc3NhZ2VzLl9zdWJzY3JpYmVBdENoYW5uZWxBdHRhY2goKTsgY2hhbm5lbCBpcyBhdHRhY2hlZCBhbHJlYWR5LCB1c2luZyBhdHRhY2hTZXJpYWxcIiwge1xuICAgICAgICBhdHRhY2hTZXJpYWw6IGUucHJvcGVydGllcy5hdHRhY2hTZXJpYWxcbiAgICAgIH0pLCBlLnByb3BlcnRpZXMuYXR0YWNoU2VyaWFsID8gdCh7IGZyb21TZXJpYWw6IGUucHJvcGVydGllcy5hdHRhY2hTZXJpYWwgfSkgOiAodGhpcy5fbG9nZ2VyLmVycm9yKFwiRGVmYXVsdFN1YnNjcmlwdGlvbk1hbmFnZXIuaGFuZGxlQXR0YWNoKCk7IGF0dGFjaFNlcmlhbCBpcyB1bmRlZmluZWRcIiksIHIoXG4gICAgICAgIG5ldyBoLkVycm9ySW5mbyhcImNoYW5uZWwgaXMgYXR0YWNoZWQsIGJ1dCBhdHRhY2hTZXJpYWwgaXMgbm90IGRlZmluZWRcIiwgNGU0LCA0MDApXG4gICAgICApKSksIGUub25jZShcImF0dGFjaGVkXCIsICgpID0+IHtcbiAgICAgICAgdGhpcy5fbG9nZ2VyLmRlYnVnKFwiTWVzc2FnZXMuX3N1YnNjcmliZUF0Q2hhbm5lbEF0dGFjaCgpOyBjaGFubmVsIGlzIG5vdyBhdHRhY2hlZCwgdXNpbmcgYXR0YWNoU2VyaWFsXCIsIHtcbiAgICAgICAgICBhdHRhY2hTZXJpYWw6IGUucHJvcGVydGllcy5hdHRhY2hTZXJpYWxcbiAgICAgICAgfSksIGUucHJvcGVydGllcy5hdHRhY2hTZXJpYWwgPyB0KHsgZnJvbVNlcmlhbDogZS5wcm9wZXJ0aWVzLmF0dGFjaFNlcmlhbCB9KSA6ICh0aGlzLl9sb2dnZXIuZXJyb3IoXCJEZWZhdWx0U3Vic2NyaXB0aW9uTWFuYWdlci5oYW5kbGVBdHRhY2goKTsgYXR0YWNoU2VyaWFsIGlzIHVuZGVmaW5lZFwiKSwgcihcbiAgICAgICAgICBuZXcgaC5FcnJvckluZm8oXCJjaGFubmVsIGlzIGF0dGFjaGVkLCBidXQgYXR0YWNoU2VyaWFsIGlzIG5vdCBkZWZpbmVkXCIsIDRlNCwgNDAwKVxuICAgICAgICApKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBAaW5oZXJpdGRvYyBNZXNzYWdlc1xuICAgKi9cbiAgZ2V0IGNoYW5uZWwoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NoYW5uZWw7XG4gIH1cbiAgLyoqXG4gICAqIEBpbmhlcml0ZG9jIE1lc3NhZ2VzXG4gICAqL1xuICBhc3luYyBnZXQoZSkge1xuICAgIHJldHVybiB0aGlzLl9sb2dnZXIudHJhY2UoXCJNZXNzYWdlcy5xdWVyeSgpO1wiKSwgdGhpcy5fY2hhdEFwaS5nZXRNZXNzYWdlcyh0aGlzLl9yb29tSWQsIGUpO1xuICB9XG4gIC8qKlxuICAgKiBAaW5oZXJpdGRvYyBNZXNzYWdlc1xuICAgKiBAdGhyb3dzIHtAbGluayBFcnJvckluZm99IGlmIG1ldGFkYXRhIGRlZmluZXMgcmVzZXJ2ZWQga2V5cy5cbiAgICogQHRocm93cyB7QGxpbmsgRXJyb3JJbmZvfSBpZiBoZWFkZXJzIGRlZmluZXMgYW55IGhlYWRlcnMgcHJlZml4ZWQgd2l0aCByZXNlcnZlZCB3b3Jkcy5cbiAgICovXG4gIGFzeW5jIHNlbmQoZSkge1xuICAgIHRoaXMuX2xvZ2dlci50cmFjZShcIk1lc3NhZ2VzLnNlbmQoKTtcIik7XG4gICAgY29uc3QgeyB0ZXh0OiB0LCBtZXRhZGF0YTogciwgaGVhZGVyczogcyB9ID0gZTtcbiAgICBpZiAociAmJiByW1wiYWJseS1jaGF0XCJdICE9PSB2b2lkIDApXG4gICAgICB0aHJvdyBuZXcgaC5FcnJvckluZm8oXCJ1bmFibGUgdG8gc2VuZCBtZXNzYWdlOyBtZXRhZGF0YSBjYW5ub3QgdXNlIHJlc2VydmVkIGtleSAnYWJseS1jaGF0J1wiLCA0MDAwMSwgNDAwKTtcbiAgICBpZiAocykge1xuICAgICAgZm9yIChjb25zdCB1IG9mIE9iamVjdC5rZXlzKHMpKVxuICAgICAgICBpZiAodS5zdGFydHNXaXRoKFwiYWJseS1jaGF0XCIpKVxuICAgICAgICAgIHRocm93IG5ldyBoLkVycm9ySW5mbyhcbiAgICAgICAgICAgIFwidW5hYmxlIHRvIHNlbmQgbWVzc2FnZTsgaGVhZGVycyBjYW5ub3QgaGF2ZSBhbnkga2V5IHN0YXJ0aW5nIHdpdGggcmVzZXJ2ZWQgcHJlZml4ICdhYmx5LWNoYXQnXCIsXG4gICAgICAgICAgICA0MDAwMSxcbiAgICAgICAgICAgIDQwMFxuICAgICAgICAgICk7XG4gICAgfVxuICAgIGNvbnN0IGMgPSBhd2FpdCB0aGlzLl9jaGF0QXBpLnNlbmRNZXNzYWdlKHRoaXMuX3Jvb21JZCwgeyB0ZXh0OiB0LCBoZWFkZXJzOiBzLCBtZXRhZGF0YTogciB9KTtcbiAgICByZXR1cm4gbmV3IGZlKFxuICAgICAgYy50aW1lc2VyaWFsLFxuICAgICAgdGhpcy5fY2xpZW50SWQsXG4gICAgICB0aGlzLl9yb29tSWQsXG4gICAgICB0LFxuICAgICAgbmV3IERhdGUoYy5jcmVhdGVkQXQpLFxuICAgICAgciA/PyB7fSxcbiAgICAgIHMgPz8ge31cbiAgICApO1xuICB9XG4gIC8qKlxuICAgKiBAaW5oZXJpdGRvYyBNZXNzYWdlc1xuICAgKi9cbiAgc3Vic2NyaWJlKGUpIHtcbiAgICB0aGlzLl9sb2dnZXIudHJhY2UoXCJNZXNzYWdlcy5zdWJzY3JpYmUoKTtcIiksIHN1cGVyLm9uKFtMLkNyZWF0ZWRdLCBlKTtcbiAgICBjb25zdCB0ID0gdGhpcy5fcmVzb2x2ZVN1YnNjcmlwdGlvblN0YXJ0KCk7XG4gICAgcmV0dXJuIHQuY2F0Y2goKCkgPT4ge1xuICAgICAgdGhpcy5fbG9nZ2VyLmRlYnVnKFwiTWVzc2FnZXMuc3Vic2NyaWJlKCk7IHN1YnNjcmlwdGlvbiBwb2ludCB3YXMgbm90IHJlc29sdmVkIGJlZm9yZSB0aGUgcm9vbSB3YXMgcmVsZWFzZWRcIiwge1xuICAgICAgICByb29tSWQ6IHRoaXMuX3Jvb21JZFxuICAgICAgfSk7XG4gICAgfSksIHRoaXMuX2xpc3RlbmVyU3Vic2NyaXB0aW9uUG9pbnRzLnNldChlLCB0KSwge1xuICAgICAgdW5zdWJzY3JpYmU6ICgpID0+IHtcbiAgICAgICAgdGhpcy5fbGlzdGVuZXJTdWJzY3JpcHRpb25Qb2ludHMuZGVsZXRlKGUpLCB0aGlzLl9sb2dnZXIudHJhY2UoXCJNZXNzYWdlcy51bnN1YnNjcmliZSgpO1wiKSwgc3VwZXIub2ZmKGUpO1xuICAgICAgfSxcbiAgICAgIGdldFByZXZpb3VzTWVzc2FnZXM6IChyKSA9PiB0aGlzLl9nZXRCZWZvcmVTdWJzY3JpcHRpb25TdGFydChlLCByKVxuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIEBpbmhlcml0ZG9jIE1lc3NhZ2VzXG4gICAqL1xuICB1bnN1YnNjcmliZUFsbCgpIHtcbiAgICB0aGlzLl9sb2dnZXIudHJhY2UoXCJNZXNzYWdlcy51bnN1YnNjcmliZUFsbCgpO1wiKSwgc3VwZXIub2ZmKCksIHRoaXMuX2xpc3RlbmVyU3Vic2NyaXB0aW9uUG9pbnRzLmNsZWFyKCk7XG4gIH1cbiAgX3Byb2Nlc3NFdmVudChlKSB7XG4gICAgdGhpcy5fbG9nZ2VyLnRyYWNlKFwiTWVzc2FnZXMuX3Byb2Nlc3NFdmVudCgpO1wiLCB7XG4gICAgICBjaGFubmVsRXZlbnRNZXNzYWdlOiBlXG4gICAgfSk7XG4gICAgY29uc3QgeyBuYW1lOiB0IH0gPSBlO1xuICAgIHN3aXRjaCAodCkge1xuICAgICAgY2FzZSBMLkNyZWF0ZWQ6IHtcbiAgICAgICAgY29uc3QgciA9IHRoaXMuX3BhcnNlTmV3TWVzc2FnZShlKTtcbiAgICAgICAgaWYgKCFyKVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdGhpcy5lbWl0KEwuQ3JlYXRlZCwgeyB0eXBlOiB0LCBtZXNzYWdlOiByIH0pO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRoaXMuX2xvZ2dlci53YXJuKFwiTWVzc2FnZXMuX3Byb2Nlc3NFdmVudCgpOyByZWNlaXZlZCB1bmtub3duIGV2ZW50XCIsIHsgbmFtZTogdCB9KTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFZhbGlkYXRlIHRoZSByZWFsdGltZSBtZXNzYWdlIGFuZCBjb252ZXJ0IGl0IHRvIGEgY2hhdCBtZXNzYWdlLlxuICAgKi9cbiAgX3BhcnNlTmV3TWVzc2FnZShlKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBodCh0aGlzLl9yb29tSWQsIGUpO1xuICAgIH0gY2F0Y2ggKHQpIHtcbiAgICAgIHRoaXMuX2xvZ2dlci5lcnJvcihcImZhaWxlZCB0byBwYXJzZSBpbmNvbWluZyBtZXNzYWdlO1wiLCB7IGNoYW5uZWxFdmVudE1lc3NhZ2U6IGUsIGVycm9yOiB0IH0pO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogQGluaGVyaXRkb2MgSGFuZGxlc0Rpc2NvbnRpbnVpdHlcbiAgICovXG4gIGRpc2NvbnRpbnVpdHlEZXRlY3RlZChlKSB7XG4gICAgdGhpcy5fbG9nZ2VyLndhcm4oXCJNZXNzYWdlcy5kaXNjb250aW51aXR5RGV0ZWN0ZWQoKTtcIiwgeyByZWFzb246IGUgfSksIHRoaXMuX2Rpc2NvbnRpbnVpdHlFbWl0dGVyLmVtaXQoXCJkaXNjb250aW51aXR5XCIsIGUpO1xuICB9XG4gIC8qKlxuICAgKiBAaW5oZXJpdGRvYyBFbWl0c0Rpc2NvbnRpbnVpdGllc1xuICAgKi9cbiAgb25EaXNjb250aW51aXR5KGUpIHtcbiAgICByZXR1cm4gdGhpcy5fbG9nZ2VyLnRyYWNlKFwiTWVzc2FnZXMub25EaXNjb250aW51aXR5KCk7XCIpLCB0aGlzLl9kaXNjb250aW51aXR5RW1pdHRlci5vbihlKSwge1xuICAgICAgb2ZmOiAoKSA9PiB7XG4gICAgICAgIHRoaXMuX2Rpc2NvbnRpbnVpdHlFbWl0dGVyLm9mZihlKTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBAaW5oZXJpdGRvYyBDb250cmlidXRlc1RvUm9vbUxpZmVjeWNsZVxuICAgKi9cbiAgZ2V0IGF0dGFjaG1lbnRFcnJvckNvZGUoKSB7XG4gICAgcmV0dXJuIG0uTWVzc2FnZXNBdHRhY2htZW50RmFpbGVkO1xuICB9XG4gIC8qKlxuICAgKiBAaW5oZXJpdGRvYyBDb250cmlidXRlc1RvUm9vbUxpZmVjeWNsZVxuICAgKi9cbiAgZ2V0IGRldGFjaG1lbnRFcnJvckNvZGUoKSB7XG4gICAgcmV0dXJuIG0uTWVzc2FnZXNEZXRhY2htZW50RmFpbGVkO1xuICB9XG59XG5jbGFzcyBpciBleHRlbmRzIFMge1xuICAvKipcbiAgICogQ29uc3RydWN0cyBhIG5ldyBgRGVmYXVsdE9jY3VwYW5jeWAgaW5zdGFuY2UuXG4gICAqIEBwYXJhbSByb29tSWQgVGhlIHVuaXF1ZSBpZGVudGlmaWVyIG9mIHRoZSByb29tLlxuICAgKiBAcGFyYW0gcmVhbHRpbWUgQW4gaW5zdGFuY2Ugb2YgdGhlIEFibHkgUmVhbHRpbWUgY2xpZW50LlxuICAgKiBAcGFyYW0gY2hhdEFwaSBBbiBpbnN0YW5jZSBvZiB0aGUgQ2hhdEFwaS5cbiAgICogQHBhcmFtIGxvZ2dlciBBbiBpbnN0YW5jZSBvZiB0aGUgTG9nZ2VyLlxuICAgKiBAcGFyYW0gaW5pdEFmdGVyIEEgcHJvbWlzZSB0aGF0IGlzIGF3YWl0ZWQgYmVmb3JlIGNyZWF0aW5nIGFueSBjaGFubmVscy5cbiAgICovXG4gIGNvbnN0cnVjdG9yKGUsIHQsIHIsIHMsIGMpIHtcbiAgICBzdXBlcigpLCB0aGlzLl9kaXNjb250aW51aXR5RW1pdHRlciA9IFcoKSwgdGhpcy5fcm9vbUlkID0gZSwgdGhpcy5fY2hhbm5lbCA9IGMudGhlbigoKSA9PiB0aGlzLl9tYWtlQ2hhbm5lbChlLCB0KSksIHRoaXMuX2NoYW5uZWwuY2F0Y2goKHUpID0+IHtcbiAgICAgIHMuZGVidWcoXCJPY2N1cGFuY3k6IGNoYW5uZWwgaW5pdGlhbGl6YXRpb24gY2FuY2VsZWRcIiwgeyByb29tSWQ6IGUsIGVycm9yOiB1IH0pO1xuICAgIH0pLCB0aGlzLl9jaGF0QXBpID0gciwgdGhpcy5fbG9nZ2VyID0gcztcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlcyB0aGUgcmVhbHRpbWUgY2hhbm5lbCBmb3Igb2NjdXBhbmN5LiBDYWxsZWQgYWZ0ZXIgaW5pdEFmdGVyIGlzIHJlc29sdmVkLlxuICAgKi9cbiAgX21ha2VDaGFubmVsKGUsIHQpIHtcbiAgICBjb25zdCByID0gcShfZShlKSwgdCwgeyBwYXJhbXM6IHsgb2NjdXBhbmN5OiBcIm1ldHJpY3NcIiB9IH0pO1xuICAgIHJldHVybiBtZSh7XG4gICAgICBsaXN0ZW5lcjogdGhpcy5faW50ZXJuYWxPY2N1cGFuY3lMaXN0ZW5lci5iaW5kKHRoaXMpLFxuICAgICAgZXZlbnRzOiBbXCJbbWV0YV1vY2N1cGFuY3lcIl0sXG4gICAgICBjaGFubmVsOiByXG4gICAgfSksIHI7XG4gIH1cbiAgLyoqXG4gICAqIEBpbmhlcml0ZG9jIE9jY3VwYW5jeVxuICAgKi9cbiAgc3Vic2NyaWJlKGUpIHtcbiAgICByZXR1cm4gdGhpcy5fbG9nZ2VyLnRyYWNlKFwiT2NjdXBhbmN5LnN1YnNjcmliZSgpO1wiKSwgdGhpcy5vbihlKSwge1xuICAgICAgdW5zdWJzY3JpYmU6ICgpID0+IHtcbiAgICAgICAgdGhpcy5fbG9nZ2VyLnRyYWNlKFwiT2NjdXBhbmN5LnVuc3Vic2NyaWJlKCk7XCIpLCB0aGlzLm9mZihlKTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBAaW5oZXJpdGRvYyBPY2N1cGFuY3lcbiAgICovXG4gIHVuc3Vic2NyaWJlQWxsKCkge1xuICAgIHRoaXMuX2xvZ2dlci50cmFjZShcIk9jY3VwYW5jeS51bnN1YnNjcmliZUFsbCgpO1wiKSwgdGhpcy5vZmYoKTtcbiAgfVxuICAvKipcbiAgICogQGluaGVyaXRkb2MgT2NjdXBhbmN5XG4gICAqL1xuICBhc3luYyBnZXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2xvZ2dlci50cmFjZShcIk9jY3VwYW5jeS5nZXQoKTtcIiksIHRoaXMuX2NoYXRBcGkuZ2V0T2NjdXBhbmN5KHRoaXMuX3Jvb21JZCk7XG4gIH1cbiAgLyoqXG4gICAqIEBpbmhlcml0ZG9jIE9jY3VwYW5jeVxuICAgKi9cbiAgZ2V0IGNoYW5uZWwoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NoYW5uZWw7XG4gIH1cbiAgLyoqXG4gICAqIEFuIGludGVybmFsIGxpc3RlbmVyIHRoYXQgbGlzdGVucyBmb3Igb2NjdXBhbmN5IGV2ZW50cyBmcm9tIHRoZSB1bmRlcmx5aW5nIGNoYW5uZWwgYW5kIHRyYW5zbGF0ZXMgdGhlbSBpbnRvXG4gICAqIG9jY3VwYW5jeSBldmVudHMgZm9yIHRoZSBwdWJsaWMgQVBJLlxuICAgKi9cbiAgX2ludGVybmFsT2NjdXBhbmN5TGlzdGVuZXIoZSkge1xuICAgIGlmICh0eXBlb2YgZS5kYXRhICE9IFwib2JqZWN0XCIpIHtcbiAgICAgIHRoaXMuX2xvZ2dlci5lcnJvcihcImludmFsaWQgb2NjdXBhbmN5IGV2ZW50IHJlY2VpdmVkOyBkYXRhIGlzIG5vdCBhbiBvYmplY3RcIiwgZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHsgbWV0cmljczogdCB9ID0gZS5kYXRhO1xuICAgIGlmICh0ID09PSB2b2lkIDApIHtcbiAgICAgIHRoaXMuX2xvZ2dlci5lcnJvcihcImludmFsaWQgb2NjdXBhbmN5IGV2ZW50IHJlY2VpdmVkOyBtZXRyaWNzIGlzIG1pc3NpbmdcIiwgZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHsgY29ubmVjdGlvbnM6IHIsIHByZXNlbmNlTWVtYmVyczogcyB9ID0gdDtcbiAgICBpZiAociA9PT0gdm9pZCAwKSB7XG4gICAgICB0aGlzLl9sb2dnZXIuZXJyb3IoXCJpbnZhbGlkIG9jY3VwYW5jeSBldmVudCByZWNlaXZlZDsgY29ubmVjdGlvbnMgaXMgbWlzc2luZ1wiLCBlKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiByICE9IFwibnVtYmVyXCIgfHwgIU51bWJlci5pc0ludGVnZXIocikpIHtcbiAgICAgIHRoaXMuX2xvZ2dlci5lcnJvcihcImludmFsaWQgb2NjdXBhbmN5IGV2ZW50IHJlY2VpdmVkOyBjb25uZWN0aW9ucyBpcyBub3QgYSBudW1iZXJcIiwgZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChzID09PSB2b2lkIDApIHtcbiAgICAgIHRoaXMuX2xvZ2dlci5lcnJvcihcImludmFsaWQgb2NjdXBhbmN5IGV2ZW50IHJlY2VpdmVkOyBwcmVzZW5jZU1lbWJlcnMgaXMgbWlzc2luZ1wiLCBlKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBzICE9IFwibnVtYmVyXCIgfHwgIU51bWJlci5pc0ludGVnZXIocykpIHtcbiAgICAgIHRoaXMuX2xvZ2dlci5lcnJvcihcImludmFsaWQgb2NjdXBhbmN5IGV2ZW50IHJlY2VpdmVkOyBwcmVzZW5jZU1lbWJlcnMgaXMgbm90IGEgbnVtYmVyXCIsIGUpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmVtaXQoXCJvY2N1cGFuY3lcIiwge1xuICAgICAgY29ubmVjdGlvbnM6IHIsXG4gICAgICBwcmVzZW5jZU1lbWJlcnM6IHNcbiAgICB9KTtcbiAgfVxuICBvbkRpc2NvbnRpbnVpdHkoZSkge1xuICAgIHJldHVybiB0aGlzLl9sb2dnZXIudHJhY2UoXCJPY2N1cGFuY3kub25EaXNjb250aW51aXR5KCk7XCIpLCB0aGlzLl9kaXNjb250aW51aXR5RW1pdHRlci5vbihlKSwge1xuICAgICAgb2ZmOiAoKSA9PiB7XG4gICAgICAgIHRoaXMuX2Rpc2NvbnRpbnVpdHlFbWl0dGVyLm9mZihlKTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIGRpc2NvbnRpbnVpdHlEZXRlY3RlZChlKSB7XG4gICAgdGhpcy5fbG9nZ2VyLndhcm4oXCJPY2N1cGFuY3kuZGlzY29udGludWl0eURldGVjdGVkKCk7XCIsIHsgcmVhc29uOiBlIH0pLCB0aGlzLl9kaXNjb250aW51aXR5RW1pdHRlci5lbWl0KFwiZGlzY29udGludWl0eVwiLCBlKTtcbiAgfVxuICAvKipcbiAgICogQGluaGVyaXRkb2MgQ29udHJpYnV0ZXNUb1Jvb21MaWZlY3ljbGVcbiAgICovXG4gIGdldCBhdHRhY2htZW50RXJyb3JDb2RlKCkge1xuICAgIHJldHVybiBtLk9jY3VwYW5jeUF0dGFjaG1lbnRGYWlsZWQ7XG4gIH1cbiAgLyoqXG4gICAqIEBpbmhlcml0ZG9jIENvbnRyaWJ1dGVzVG9Sb29tTGlmZWN5Y2xlXG4gICAqL1xuICBnZXQgZGV0YWNobWVudEVycm9yQ29kZSgpIHtcbiAgICByZXR1cm4gbS5PY2N1cGFuY3lEZXRhY2htZW50RmFpbGVkO1xuICB9XG59XG5jbGFzcyBzciBleHRlbmRzIFMge1xuICAvKipcbiAgICogQ29uc3RydWN0cyBhIG5ldyBgRGVmYXVsdFByZXNlbmNlYCBpbnN0YW5jZS5cbiAgICogQHBhcmFtIHJvb21JZCBUaGUgdW5pcXVlIGlkZW50aWZpZXIgb2YgdGhlIHJvb20uXG4gICAqIEBwYXJhbSByb29tT3B0aW9ucyBUaGUgcm9vbSBvcHRpb25zIGZvciBwcmVzZW5jZS5cbiAgICogQHBhcmFtIHJlYWx0aW1lIEFuIGluc3RhbmNlIG9mIHRoZSBBYmx5IFJlYWx0aW1lIGNsaWVudC5cbiAgICogQHBhcmFtIGNsaWVudElkIFRoZSBjbGllbnQgSUQsIGF0dGFjaGVkIHRvIHByZXNlbmNlcyBtZXNzYWdlcyBhcyBhbiBpZGVudGlmaWVyIG9mIHRoZSBzZW5kZXIuXG4gICAqIEEgY2hhbm5lbCBjYW4gaGF2ZSBtdWx0aXBsZSBjb25uZWN0aW9ucyB1c2luZyB0aGUgc2FtZSBjbGllbnRJZC5cbiAgICogQHBhcmFtIGxvZ2dlciBBbiBpbnN0YW5jZSBvZiB0aGUgTG9nZ2VyLlxuICAgKiBAcGFyYW0gaW5pdEFmdGVyIEEgcHJvbWlzZSB0aGF0IGlzIGF3YWl0ZWQgYmVmb3JlIGNyZWF0aW5nIGFueSBjaGFubmVscy5cbiAgICovXG4gIGNvbnN0cnVjdG9yKGUsIHQsIHIsIHMsIGMsIHUpIHtcbiAgICBzdXBlcigpLCB0aGlzLl9kaXNjb250aW51aXR5RW1pdHRlciA9IFcoKSwgdGhpcy5zdWJzY3JpYmVUb0V2ZW50cyA9IChnKSA9PiB7XG4gICAgICB2YXIgZjtcbiAgICAgIHRyeSB7XG4gICAgICAgIHRoaXMuZW1pdChnLmFjdGlvbiwge1xuICAgICAgICAgIGFjdGlvbjogZy5hY3Rpb24sXG4gICAgICAgICAgY2xpZW50SWQ6IGcuY2xpZW50SWQsXG4gICAgICAgICAgdGltZXN0YW1wOiBnLnRpbWVzdGFtcCxcbiAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1tZW1iZXItYWNjZXNzXG4gICAgICAgICAgZGF0YTogKGYgPSBnLmRhdGEpID09IG51bGwgPyB2b2lkIDAgOiBmLnVzZXJDdXN0b21EYXRhXG4gICAgICAgIH0pO1xuICAgICAgfSBjYXRjaCAoeSkge1xuICAgICAgICB0aHJvdyB0aGlzLl9sb2dnZXIuZXJyb3IoXCJ1bmFibGUgdG8gaGFuZGxlIHByZXNlbmNlIGV2ZW50OiBub3QgYSB2YWxpZCBwcmVzZW5jZSBldmVudFwiLCB7IGFjdGlvbjogZy5hY3Rpb24gfSksIG5ldyBoLkVycm9ySW5mbyhcbiAgICAgICAgICBgdW5hYmxlIHRvIGhhbmRsZSAke2cuYWN0aW9ufSBwcmVzZW5jZSBldmVudDogbm90IGEgdmFsaWQgcHJlc2VuY2UgZXZlbnRgLFxuICAgICAgICAgIDVlNCxcbiAgICAgICAgICA1MDAsXG4gICAgICAgICAgeS5tZXNzYWdlXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfSwgdGhpcy5fY2hhbm5lbCA9IHUudGhlbigoKSA9PiB0aGlzLl9tYWtlQ2hhbm5lbChlLCB0LCByKSksIHRoaXMuX2NoYW5uZWwuY2F0Y2goKGcpID0+IHtcbiAgICAgIGMuZGVidWcoXCJQcmVzZW5jZTogY2hhbm5lbCBpbml0aWFsaXphdGlvbiBjYW5jZWxlZFwiLCB7IHJvb21JZDogZSwgZXJyb3I6IGcgfSk7XG4gICAgfSksIHRoaXMuX2NsaWVudElkID0gcywgdGhpcy5fbG9nZ2VyID0gYztcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlcyB0aGUgcmVhbHRpbWUgY2hhbm5lbCBmb3IgcHJlc2VuY2UuIENhbGxlZCBhZnRlciBpbml0QWZ0ZXIgaXMgcmVzb2x2ZWQuXG4gICAqL1xuICBfbWFrZUNoYW5uZWwoZSwgdCwgcikge1xuICAgIHZhciB1LCBnO1xuICAgIGNvbnN0IHMgPSBbXCJQVUJMSVNIXCIsIFwiU1VCU0NSSUJFXCJdO1xuICAgICgoKHUgPSB0LnByZXNlbmNlKSA9PSBudWxsID8gdm9pZCAwIDogdS5lbnRlcikgPT09IHZvaWQgMCB8fCB0LnByZXNlbmNlLmVudGVyKSAmJiBzLnB1c2goXCJQUkVTRU5DRVwiKSwgKCgoZyA9IHQucHJlc2VuY2UpID09IG51bGwgPyB2b2lkIDAgOiBnLnN1YnNjcmliZSkgPT09IHZvaWQgMCB8fCB0LnByZXNlbmNlLnN1YnNjcmliZSkgJiYgcy5wdXNoKFwiUFJFU0VOQ0VfU1VCU0NSSUJFXCIpO1xuICAgIGNvbnN0IGMgPSBxKF9lKGUpLCByLCB7IG1vZGVzOiBzIH0pO1xuICAgIHJldHVybiB1dCh7XG4gICAgICBsaXN0ZW5lcjogdGhpcy5zdWJzY3JpYmVUb0V2ZW50cy5iaW5kKHRoaXMpLFxuICAgICAgY2hhbm5lbDogY1xuICAgIH0pLCBjO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgdGhlIHVuZGVybHlpbmcgQWJseSByZWFsdGltZSBjaGFubmVsIHVzZWQgZm9yIHByZXNlbmNlIGluIHRoaXMgY2hhdCByb29tLlxuICAgKiBAcmV0dXJucyBUaGUgcmVhbHRpbWUgY2hhbm5lbC5cbiAgICovXG4gIGdldCBjaGFubmVsKCkge1xuICAgIHJldHVybiB0aGlzLl9jaGFubmVsO1xuICB9XG4gIC8qKlxuICAgKiBAaW5oZXJpdERvY1xuICAgKi9cbiAgYXN5bmMgZ2V0KGUpIHtcbiAgICByZXR1cm4gdGhpcy5fbG9nZ2VyLnRyYWNlKFwiUHJlc2VuY2UuZ2V0KClcIiwgeyBwYXJhbXM6IGUgfSksIChhd2FpdCAoYXdhaXQgdGhpcy5fY2hhbm5lbCkucHJlc2VuY2UuZ2V0KGUpKS5tYXAoKHMpID0+IHtcbiAgICAgIHZhciBjO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgY2xpZW50SWQ6IHMuY2xpZW50SWQsXG4gICAgICAgIGFjdGlvbjogcy5hY3Rpb24sXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLW1lbWJlci1hY2Nlc3NcbiAgICAgICAgZGF0YTogKGMgPSBzLmRhdGEpID09IG51bGwgPyB2b2lkIDAgOiBjLnVzZXJDdXN0b21EYXRhLFxuICAgICAgICB1cGRhdGVkQXQ6IHMudGltZXN0YW1wLFxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1hc3NpZ25tZW50XG4gICAgICAgIGV4dHJhczogcy5leHRyYXNcbiAgICAgIH07XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqL1xuICBhc3luYyBpc1VzZXJQcmVzZW50KGUpIHtcbiAgICByZXR1cm4gKGF3YWl0IChhd2FpdCB0aGlzLl9jaGFubmVsKS5wcmVzZW5jZS5nZXQoeyBjbGllbnRJZDogZSB9KSkubGVuZ3RoID4gMDtcbiAgfVxuICAvKipcbiAgICogTWV0aG9kIHRvIGpvaW4gcm9vbSBwcmVzZW5jZSwgd2lsbCBlbWl0IGFuIGVudGVyIGV2ZW50IHRvIGFsbCBzdWJzY3JpYmVycy4gUmVwZWF0IGNhbGxzIHdpbGwgdHJpZ2dlciBtb3JlIGVudGVyIGV2ZW50cy5cbiAgICogQHBhcmFtIHtQcmVzZW5jZURhdGF9IGRhdGEgLSBUaGUgdXNlcnMgZGF0YSwgYSBKU09OIHNlcmlhbGl6YWJsZSBvYmplY3QgdGhhdCB3aWxsIGJlIHNlbnQgdG8gYWxsIHN1YnNjcmliZXJzLlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTx2b2lkPn0gb3IgdXBvbiBmYWlsdXJlLCB0aGUgcHJvbWlzZSB3aWxsIGJlIHJlamVjdGVkIHdpdGggYW4ge0BsaW5rIEVycm9ySW5mb30gb2JqZWN0IHdoaWNoIGV4cGxhaW5zIHRoZSBlcnJvci5cbiAgICovXG4gIGFzeW5jIGVudGVyKGUpIHtcbiAgICB0aGlzLl9sb2dnZXIudHJhY2UoXCJQcmVzZW5jZS5lbnRlcigpXCIsIHsgZGF0YTogZSB9KTtcbiAgICBjb25zdCB0ID0ge1xuICAgICAgdXNlckN1c3RvbURhdGE6IGVcbiAgICB9O1xuICAgIHJldHVybiAoYXdhaXQgdGhpcy5fY2hhbm5lbCkucHJlc2VuY2UuZW50ZXJDbGllbnQodGhpcy5fY2xpZW50SWQsIHQpO1xuICB9XG4gIC8qKlxuICAgKiBNZXRob2QgdG8gdXBkYXRlIHJvb20gcHJlc2VuY2UsIHdpbGwgZW1pdCBhbiB1cGRhdGUgZXZlbnQgdG8gYWxsIHN1YnNjcmliZXJzLiBJZiB0aGUgdXNlciBpcyBub3QgcHJlc2VudCwgaXQgd2lsbCBiZSB0cmVhdGVkIGFzIGEgam9pbiBldmVudC5cbiAgICogQHBhcmFtIHtQcmVzZW5jZURhdGF9IGRhdGEgLSBUaGUgdXNlcnMgZGF0YSwgYSBKU09OIHNlcmlhbGl6YWJsZSBvYmplY3QgdGhhdCB3aWxsIGJlIHNlbnQgdG8gYWxsIHN1YnNjcmliZXJzLlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTx2b2lkPn0gb3IgdXBvbiBmYWlsdXJlLCB0aGUgcHJvbWlzZSB3aWxsIGJlIHJlamVjdGVkIHdpdGggYW4ge0BsaW5rIEVycm9ySW5mb30gb2JqZWN0IHdoaWNoIGV4cGxhaW5zIHRoZSBlcnJvci5cbiAgICovXG4gIGFzeW5jIHVwZGF0ZShlKSB7XG4gICAgdGhpcy5fbG9nZ2VyLnRyYWNlKFwiUHJlc2VuY2UudXBkYXRlKClcIiwgeyBkYXRhOiBlIH0pO1xuICAgIGNvbnN0IHQgPSB7XG4gICAgICB1c2VyQ3VzdG9tRGF0YTogZVxuICAgIH07XG4gICAgcmV0dXJuIChhd2FpdCB0aGlzLl9jaGFubmVsKS5wcmVzZW5jZS51cGRhdGVDbGllbnQodGhpcy5fY2xpZW50SWQsIHQpO1xuICB9XG4gIC8qKlxuICAgKiBNZXRob2QgdG8gbGVhdmUgcm9vbSBwcmVzZW5jZSwgd2lsbCBlbWl0IGEgbGVhdmUgZXZlbnQgdG8gYWxsIHN1YnNjcmliZXJzLiBJZiB0aGUgdXNlciBpcyBub3QgcHJlc2VudCwgaXQgd2lsbCBiZSB0cmVhdGVkIGFzIGEgbm8tb3AuXG4gICAqIEBwYXJhbSB7UHJlc2VuY2VEYXRhfSBkYXRhIC0gVGhlIHVzZXJzIGRhdGEsIGEgSlNPTiBzZXJpYWxpemFibGUgb2JqZWN0IHRoYXQgd2lsbCBiZSBzZW50IHRvIGFsbCBzdWJzY3JpYmVycy5cbiAgICogQHJldHVybnMge1Byb21pc2U8dm9pZD59IG9yIHVwb24gZmFpbHVyZSwgdGhlIHByb21pc2Ugd2lsbCBiZSByZWplY3RlZCB3aXRoIGFuIHtAbGluayBFcnJvckluZm99IG9iamVjdCB3aGljaCBleHBsYWlucyB0aGUgZXJyb3IuXG4gICAqL1xuICBhc3luYyBsZWF2ZShlKSB7XG4gICAgdGhpcy5fbG9nZ2VyLnRyYWNlKFwiUHJlc2VuY2UubGVhdmUoKVwiLCB7IGRhdGE6IGUgfSk7XG4gICAgY29uc3QgdCA9IHtcbiAgICAgIHVzZXJDdXN0b21EYXRhOiBlXG4gICAgfTtcbiAgICByZXR1cm4gKGF3YWl0IHRoaXMuX2NoYW5uZWwpLnByZXNlbmNlLmxlYXZlQ2xpZW50KHRoaXMuX2NsaWVudElkLCB0KTtcbiAgfVxuICBzdWJzY3JpYmUoZSwgdCkge1xuICAgIGlmICh0aGlzLl9sb2dnZXIudHJhY2UoXCJQcmVzZW5jZS5zdWJzY3JpYmUoKTsgbGlzdGVuZXJPckV2ZW50c1wiLCB7IGxpc3RlbmVyT3JFdmVudHM6IGUgfSksICFlICYmICF0KVxuICAgICAgdGhyb3cgdGhpcy5fbG9nZ2VyLmVycm9yKFwiY291bGQgbm90IHN1YnNjcmliZSB0byBwcmVzZW5jZTsgaW52YWxpZCBhcmd1bWVudHNcIiksIG5ldyBoLkVycm9ySW5mbyhcImNvdWxkIG5vdCBzdWJzY3JpYmUgbGlzdGVuZXI6IGludmFsaWQgYXJndW1lbnRzXCIsIDRlNCwgNDAwKTtcbiAgICByZXR1cm4gdCA/ICh0aGlzLm9uKGUsIHQpLCB7XG4gICAgICB1bnN1YnNjcmliZTogKCkgPT4ge1xuICAgICAgICB0aGlzLl9sb2dnZXIudHJhY2UoXCJQcmVzZW5jZS51bnN1YnNjcmliZSgpO1wiLCB7IGV2ZW50czogZSB9KSwgdGhpcy5vZmYodCk7XG4gICAgICB9XG4gICAgfSkgOiAodGhpcy5vbihlKSwge1xuICAgICAgdW5zdWJzY3JpYmU6ICgpID0+IHtcbiAgICAgICAgdGhpcy5fbG9nZ2VyLnRyYWNlKFwiUHJlc2VuY2UudW5zdWJzY3JpYmUoKTtcIiksIHRoaXMub2ZmKGUpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBVbnN1YnNjcmliZSBhbGwgbGlzdGVuZXJzIGZyb20gYWxsIHByZXNlbmNlIGV2ZW50cy5cbiAgICovXG4gIHVuc3Vic2NyaWJlQWxsKCkge1xuICAgIHRoaXMuX2xvZ2dlci50cmFjZShcIlByZXNlbmNlLnVuc3Vic2NyaWJlQWxsKClcIiksIHRoaXMub2ZmKCk7XG4gIH1cbiAgb25EaXNjb250aW51aXR5KGUpIHtcbiAgICByZXR1cm4gdGhpcy5fbG9nZ2VyLnRyYWNlKFwiUHJlc2VuY2Uub25EaXNjb250aW51aXR5KCk7XCIpLCB0aGlzLl9kaXNjb250aW51aXR5RW1pdHRlci5vbihlKSwge1xuICAgICAgb2ZmOiAoKSA9PiB7XG4gICAgICAgIHRoaXMuX2Rpc2NvbnRpbnVpdHlFbWl0dGVyLm9mZihlKTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIGRpc2NvbnRpbnVpdHlEZXRlY3RlZChlKSB7XG4gICAgdGhpcy5fbG9nZ2VyLndhcm4oXCJQcmVzZW5jZS5kaXNjb250aW51aXR5RGV0ZWN0ZWQoKTtcIiwgeyByZWFzb246IGUgfSksIHRoaXMuX2Rpc2NvbnRpbnVpdHlFbWl0dGVyLmVtaXQoXCJkaXNjb250aW51aXR5XCIsIGUpO1xuICB9XG4gIC8qKlxuICAgKiBAaW5oZXJpdERvYyBDb250cmlidXRlc1RvUm9vbUxpZmVjeWNsZVxuICAgKi9cbiAgZ2V0IGF0dGFjaG1lbnRFcnJvckNvZGUoKSB7XG4gICAgcmV0dXJuIG0uUHJlc2VuY2VBdHRhY2htZW50RmFpbGVkO1xuICB9XG4gIC8qKlxuICAgKiBAaW5oZXJpdERvY1xuICAgKi9cbiAgZ2V0IGRldGFjaG1lbnRFcnJvckNvZGUoKSB7XG4gICAgcmV0dXJuIG0uUHJlc2VuY2VEZXRhY2htZW50RmFpbGVkO1xuICB9XG59XG5jb25zdCBhciA9IG5ldyBFcnJvcihcInJlcXVlc3QgZm9yIGxvY2sgY2FuY2VsZWRcIik7XG52YXIgb3IgPSBmdW5jdGlvbihpLCBlLCB0LCByKSB7XG4gIGZ1bmN0aW9uIHMoYykge1xuICAgIHJldHVybiBjIGluc3RhbmNlb2YgdCA/IGMgOiBuZXcgdChmdW5jdGlvbih1KSB7XG4gICAgICB1KGMpO1xuICAgIH0pO1xuICB9XG4gIHJldHVybiBuZXcgKHQgfHwgKHQgPSBQcm9taXNlKSkoZnVuY3Rpb24oYywgdSkge1xuICAgIGZ1bmN0aW9uIGcocCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgeShyLm5leHQocCkpO1xuICAgICAgfSBjYXRjaCAoUikge1xuICAgICAgICB1KFIpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBmKHApIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHkoci50aHJvdyhwKSk7XG4gICAgICB9IGNhdGNoIChSKSB7XG4gICAgICAgIHUoUik7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHkocCkge1xuICAgICAgcC5kb25lID8gYyhwLnZhbHVlKSA6IHMocC52YWx1ZSkudGhlbihnLCBmKTtcbiAgICB9XG4gICAgeSgociA9IHIuYXBwbHkoaSwgZSB8fCBbXSkpLm5leHQoKSk7XG4gIH0pO1xufTtcbmNsYXNzIGNyIHtcbiAgY29uc3RydWN0b3IoZSwgdCA9IGFyKSB7XG4gICAgdGhpcy5fdmFsdWUgPSBlLCB0aGlzLl9jYW5jZWxFcnJvciA9IHQsIHRoaXMuX3F1ZXVlID0gW10sIHRoaXMuX3dlaWdodGVkV2FpdGVycyA9IFtdO1xuICB9XG4gIGFjcXVpcmUoZSA9IDEsIHQgPSAwKSB7XG4gICAgaWYgKGUgPD0gMClcbiAgICAgIHRocm93IG5ldyBFcnJvcihgaW52YWxpZCB3ZWlnaHQgJHtlfTogbXVzdCBiZSBwb3NpdGl2ZWApO1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgociwgcykgPT4ge1xuICAgICAgY29uc3QgYyA9IHsgcmVzb2x2ZTogciwgcmVqZWN0OiBzLCB3ZWlnaHQ6IGUsIHByaW9yaXR5OiB0IH0sIHUgPSBkdCh0aGlzLl9xdWV1ZSwgKGcpID0+IHQgPD0gZy5wcmlvcml0eSk7XG4gICAgICB1ID09PSAtMSAmJiBlIDw9IHRoaXMuX3ZhbHVlID8gdGhpcy5fZGlzcGF0Y2hJdGVtKGMpIDogdGhpcy5fcXVldWUuc3BsaWNlKHUgKyAxLCAwLCBjKTtcbiAgICB9KTtcbiAgfVxuICBydW5FeGNsdXNpdmUoZSkge1xuICAgIHJldHVybiBvcih0aGlzLCBhcmd1bWVudHMsIHZvaWQgMCwgZnVuY3Rpb24qICh0LCByID0gMSwgcyA9IDApIHtcbiAgICAgIGNvbnN0IFtjLCB1XSA9IHlpZWxkIHRoaXMuYWNxdWlyZShyLCBzKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiB5aWVsZCB0KGMpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgdSgpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIHdhaXRGb3JVbmxvY2soZSA9IDEsIHQgPSAwKSB7XG4gICAgaWYgKGUgPD0gMClcbiAgICAgIHRocm93IG5ldyBFcnJvcihgaW52YWxpZCB3ZWlnaHQgJHtlfTogbXVzdCBiZSBwb3NpdGl2ZWApO1xuICAgIHJldHVybiB0aGlzLl9jb3VsZExvY2tJbW1lZGlhdGVseShlLCB0KSA/IFByb21pc2UucmVzb2x2ZSgpIDogbmV3IFByb21pc2UoKHIpID0+IHtcbiAgICAgIHRoaXMuX3dlaWdodGVkV2FpdGVyc1tlIC0gMV0gfHwgKHRoaXMuX3dlaWdodGVkV2FpdGVyc1tlIC0gMV0gPSBbXSksIGhyKHRoaXMuX3dlaWdodGVkV2FpdGVyc1tlIC0gMV0sIHsgcmVzb2x2ZTogciwgcHJpb3JpdHk6IHQgfSk7XG4gICAgfSk7XG4gIH1cbiAgaXNMb2NrZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3ZhbHVlIDw9IDA7XG4gIH1cbiAgZ2V0VmFsdWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3ZhbHVlO1xuICB9XG4gIHNldFZhbHVlKGUpIHtcbiAgICB0aGlzLl92YWx1ZSA9IGUsIHRoaXMuX2Rpc3BhdGNoUXVldWUoKTtcbiAgfVxuICByZWxlYXNlKGUgPSAxKSB7XG4gICAgaWYgKGUgPD0gMClcbiAgICAgIHRocm93IG5ldyBFcnJvcihgaW52YWxpZCB3ZWlnaHQgJHtlfTogbXVzdCBiZSBwb3NpdGl2ZWApO1xuICAgIHRoaXMuX3ZhbHVlICs9IGUsIHRoaXMuX2Rpc3BhdGNoUXVldWUoKTtcbiAgfVxuICBjYW5jZWwoKSB7XG4gICAgdGhpcy5fcXVldWUuZm9yRWFjaCgoZSkgPT4gZS5yZWplY3QodGhpcy5fY2FuY2VsRXJyb3IpKSwgdGhpcy5fcXVldWUgPSBbXTtcbiAgfVxuICBfZGlzcGF0Y2hRdWV1ZSgpIHtcbiAgICBmb3IgKHRoaXMuX2RyYWluVW5sb2NrV2FpdGVycygpOyB0aGlzLl9xdWV1ZS5sZW5ndGggPiAwICYmIHRoaXMuX3F1ZXVlWzBdLndlaWdodCA8PSB0aGlzLl92YWx1ZTsgKVxuICAgICAgdGhpcy5fZGlzcGF0Y2hJdGVtKHRoaXMuX3F1ZXVlLnNoaWZ0KCkpLCB0aGlzLl9kcmFpblVubG9ja1dhaXRlcnMoKTtcbiAgfVxuICBfZGlzcGF0Y2hJdGVtKGUpIHtcbiAgICBjb25zdCB0ID0gdGhpcy5fdmFsdWU7XG4gICAgdGhpcy5fdmFsdWUgLT0gZS53ZWlnaHQsIGUucmVzb2x2ZShbdCwgdGhpcy5fbmV3UmVsZWFzZXIoZS53ZWlnaHQpXSk7XG4gIH1cbiAgX25ld1JlbGVhc2VyKGUpIHtcbiAgICBsZXQgdCA9ICExO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICB0IHx8ICh0ID0gITAsIHRoaXMucmVsZWFzZShlKSk7XG4gICAgfTtcbiAgfVxuICBfZHJhaW5VbmxvY2tXYWl0ZXJzKCkge1xuICAgIGlmICh0aGlzLl9xdWV1ZS5sZW5ndGggPT09IDApXG4gICAgICBmb3IgKGxldCBlID0gdGhpcy5fdmFsdWU7IGUgPiAwOyBlLS0pIHtcbiAgICAgICAgY29uc3QgdCA9IHRoaXMuX3dlaWdodGVkV2FpdGVyc1tlIC0gMV07XG4gICAgICAgIHQgJiYgKHQuZm9yRWFjaCgocikgPT4gci5yZXNvbHZlKCkpLCB0aGlzLl93ZWlnaHRlZFdhaXRlcnNbZSAtIDFdID0gW10pO1xuICAgICAgfVxuICAgIGVsc2Uge1xuICAgICAgY29uc3QgZSA9IHRoaXMuX3F1ZXVlWzBdLnByaW9yaXR5O1xuICAgICAgZm9yIChsZXQgdCA9IHRoaXMuX3ZhbHVlOyB0ID4gMDsgdC0tKSB7XG4gICAgICAgIGNvbnN0IHIgPSB0aGlzLl93ZWlnaHRlZFdhaXRlcnNbdCAtIDFdO1xuICAgICAgICBpZiAoIXIpXG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIGNvbnN0IHMgPSByLmZpbmRJbmRleCgoYykgPT4gYy5wcmlvcml0eSA8PSBlKTtcbiAgICAgICAgKHMgPT09IC0xID8gciA6IHIuc3BsaWNlKDAsIHMpKS5mb3JFYWNoKChjKSA9PiBjLnJlc29sdmUoKSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIF9jb3VsZExvY2tJbW1lZGlhdGVseShlLCB0KSB7XG4gICAgcmV0dXJuICh0aGlzLl9xdWV1ZS5sZW5ndGggPT09IDAgfHwgdGhpcy5fcXVldWVbMF0ucHJpb3JpdHkgPCB0KSAmJiBlIDw9IHRoaXMuX3ZhbHVlO1xuICB9XG59XG5mdW5jdGlvbiBocihpLCBlKSB7XG4gIGNvbnN0IHQgPSBkdChpLCAocikgPT4gZS5wcmlvcml0eSA8PSByLnByaW9yaXR5KTtcbiAgaS5zcGxpY2UodCArIDEsIDAsIGUpO1xufVxuZnVuY3Rpb24gZHQoaSwgZSkge1xuICBmb3IgKGxldCB0ID0gaS5sZW5ndGggLSAxOyB0ID49IDA7IHQtLSlcbiAgICBpZiAoZShpW3RdKSlcbiAgICAgIHJldHVybiB0O1xuICByZXR1cm4gLTE7XG59XG52YXIgdXIgPSBmdW5jdGlvbihpLCBlLCB0LCByKSB7XG4gIGZ1bmN0aW9uIHMoYykge1xuICAgIHJldHVybiBjIGluc3RhbmNlb2YgdCA/IGMgOiBuZXcgdChmdW5jdGlvbih1KSB7XG4gICAgICB1KGMpO1xuICAgIH0pO1xuICB9XG4gIHJldHVybiBuZXcgKHQgfHwgKHQgPSBQcm9taXNlKSkoZnVuY3Rpb24oYywgdSkge1xuICAgIGZ1bmN0aW9uIGcocCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgeShyLm5leHQocCkpO1xuICAgICAgfSBjYXRjaCAoUikge1xuICAgICAgICB1KFIpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBmKHApIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHkoci50aHJvdyhwKSk7XG4gICAgICB9IGNhdGNoIChSKSB7XG4gICAgICAgIHUoUik7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHkocCkge1xuICAgICAgcC5kb25lID8gYyhwLnZhbHVlKSA6IHMocC52YWx1ZSkudGhlbihnLCBmKTtcbiAgICB9XG4gICAgeSgociA9IHIuYXBwbHkoaSwgZSB8fCBbXSkpLm5leHQoKSk7XG4gIH0pO1xufTtcbmNsYXNzIGxyIHtcbiAgY29uc3RydWN0b3IoZSkge1xuICAgIHRoaXMuX3NlbWFwaG9yZSA9IG5ldyBjcigxLCBlKTtcbiAgfVxuICBhY3F1aXJlKCkge1xuICAgIHJldHVybiB1cih0aGlzLCBhcmd1bWVudHMsIHZvaWQgMCwgZnVuY3Rpb24qIChlID0gMCkge1xuICAgICAgY29uc3QgWywgdF0gPSB5aWVsZCB0aGlzLl9zZW1hcGhvcmUuYWNxdWlyZSgxLCBlKTtcbiAgICAgIHJldHVybiB0O1xuICAgIH0pO1xuICB9XG4gIHJ1bkV4Y2x1c2l2ZShlLCB0ID0gMCkge1xuICAgIHJldHVybiB0aGlzLl9zZW1hcGhvcmUucnVuRXhjbHVzaXZlKCgpID0+IGUoKSwgMSwgdCk7XG4gIH1cbiAgaXNMb2NrZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3NlbWFwaG9yZS5pc0xvY2tlZCgpO1xuICB9XG4gIHdhaXRGb3JVbmxvY2soZSA9IDApIHtcbiAgICByZXR1cm4gdGhpcy5fc2VtYXBob3JlLndhaXRGb3JVbmxvY2soMSwgZSk7XG4gIH1cbiAgcmVsZWFzZSgpIHtcbiAgICB0aGlzLl9zZW1hcGhvcmUuaXNMb2NrZWQoKSAmJiB0aGlzLl9zZW1hcGhvcmUucmVsZWFzZSgpO1xuICB9XG4gIGNhbmNlbCgpIHtcbiAgICByZXR1cm4gdGhpcy5fc2VtYXBob3JlLmNhbmNlbCgpO1xuICB9XG59XG52YXIgZCA9IC8qIEBfX1BVUkVfXyAqLyAoKGkpID0+IChpLkluaXRpYWxpemluZyA9IFwiaW5pdGlhbGl6aW5nXCIsIGkuSW5pdGlhbGl6ZWQgPSBcImluaXRpYWxpemVkXCIsIGkuQXR0YWNoaW5nID0gXCJhdHRhY2hpbmdcIiwgaS5BdHRhY2hlZCA9IFwiYXR0YWNoZWRcIiwgaS5EZXRhY2hpbmcgPSBcImRldGFjaGluZ1wiLCBpLkRldGFjaGVkID0gXCJkZXRhY2hlZFwiLCBpLlN1c3BlbmRlZCA9IFwic3VzcGVuZGVkXCIsIGkuRmFpbGVkID0gXCJmYWlsZWRcIiwgaS5SZWxlYXNpbmcgPSBcInJlbGVhc2luZ1wiLCBpLlJlbGVhc2VkID0gXCJyZWxlYXNlZFwiLCBpKSkoZCB8fCB7fSk7XG5jbGFzcyBkciBleHRlbmRzIFMge1xuICAvKipcbiAgICogQ29uc3RydWN0cyBhIG5ldyBgRGVmYXVsdFN0YXR1c2AgaW5zdGFuY2UuXG4gICAqIEBwYXJhbSBsb2dnZXIgVGhlIGxvZ2dlciB0byB1c2UuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihlKSB7XG4gICAgc3VwZXIoKSwgdGhpcy5fc3RhdGUgPSBcImluaXRpYWxpemluZ1wiLCB0aGlzLl9pbnRlcm5hbEVtaXR0ZXIgPSBuZXcgUygpLCB0aGlzLl9sb2dnZXIgPSBlLCB0aGlzLl9zdGF0ZSA9IFwiaW5pdGlhbGl6aW5nXCIsIHRoaXMuX2Vycm9yID0gdm9pZCAwO1xuICB9XG4gIC8qKlxuICAgKiBAaW5oZXJpdGRvY1xuICAgKi9cbiAgZ2V0IGN1cnJlbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3N0YXRlO1xuICB9XG4gIC8qKlxuICAgKiBAaW5oZXJpdGRvY1xuICAgKi9cbiAgZ2V0IGVycm9yKCkge1xuICAgIHJldHVybiB0aGlzLl9lcnJvcjtcbiAgfVxuICAvKipcbiAgICogQGluaGVyaXRkb2NcbiAgICovXG4gIG9uQ2hhbmdlKGUpIHtcbiAgICByZXR1cm4gdGhpcy5vbihlKSwge1xuICAgICAgb2ZmOiAoKSA9PiB7XG4gICAgICAgIHRoaXMub2ZmKGUpO1xuICAgICAgfVxuICAgIH07XG4gIH1cbiAgb25DaGFuZ2VPbmNlKGUpIHtcbiAgICB0aGlzLl9pbnRlcm5hbEVtaXR0ZXIub25jZShlKTtcbiAgfVxuICAvKipcbiAgICogQGluaGVyaXRkb2NcbiAgICovXG4gIG9mZkFsbCgpIHtcbiAgICB0aGlzLm9mZigpO1xuICB9XG4gIHNldFN0YXR1cyhlKSB7XG4gICAgY29uc3QgdCA9IHtcbiAgICAgIGN1cnJlbnQ6IGUuc3RhdHVzLFxuICAgICAgZXJyb3I6IGUuZXJyb3IsXG4gICAgICBwcmV2aW91czogdGhpcy5fc3RhdGVcbiAgICB9O1xuICAgIHRoaXMuX3N0YXRlID0gdC5jdXJyZW50LCB0aGlzLl9lcnJvciA9IHQuZXJyb3IsIHRoaXMuX2xvZ2dlci5pbmZvKFwiUm9vbSBzdGF0dXMgY2hhbmdlZFwiLCB0KSwgdGhpcy5faW50ZXJuYWxFbWl0dGVyLmVtaXQodC5jdXJyZW50LCB0KSwgdGhpcy5lbWl0KHQuY3VycmVudCwgdCk7XG4gIH1cbn1cbmNsYXNzIGdyIHtcbiAgLyoqXG4gICAqIENvbnN0cnVjdHMgYSBuZXcgYFJvb21MaWZlY3ljbGVNYW5hZ2VyYCBpbnN0YW5jZS5cbiAgICogQHBhcmFtIHN0YXR1cyBUaGUgc3RhdHVzIHRvIHVwZGF0ZS5cbiAgICogQHBhcmFtIGNvbnRyaWJ1dG9ycyBUaGUgZmVhdHVyZXMgdGhhdCBjb250cmlidXRlIHRvIHRoZSByb29tIHN0YXR1cy5cbiAgICogQHBhcmFtIGxvZ2dlciBBbiBpbnN0YW5jZSBvZiB0aGUgTG9nZ2VyLlxuICAgKiBAcGFyYW0gdHJhbnNpZW50RGV0YWNoVGltZW91dCBUaGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0byBjb25zaWRlciBhIGRldGFjaCB0byBiZSBcInRyYW5zaWVudFwiXG4gICAqL1xuICBjb25zdHJ1Y3RvcihlLCB0LCByLCBzKSB7XG4gICAgdGhpcy5fbXR4ID0gbmV3IGxyKCksIHRoaXMuX29wZXJhdGlvbkluUHJvZ3Jlc3MgPSAhMSwgdGhpcy5fcGVuZGluZ0Rpc2NvbnRpbnVpdHlFdmVudHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpLCB0aGlzLl9maXJzdEF0dGFjaGVzQ29tcGxldGVkID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKSwgdGhpcy5fcmVsZWFzZUluUHJvZ3Jlc3MgPSAhMSwgdGhpcy5fbG9nZ2VyID0gciwgdGhpcy5fY29udHJpYnV0b3JzID0gdCwgdGhpcy5fdHJhbnNpZW50RGV0YWNoVGltZW91dHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpLCB0aGlzLl9zdGF0dXMgPSBlLCB0aGlzLl9zdGF0dXMuY3VycmVudCAhPT0gZC5BdHRhY2hlZCAmJiAodGhpcy5fb3BlcmF0aW9uSW5Qcm9ncmVzcyA9ICEwKSwgdGhpcy5fc2V0dXBDb250cmlidXRvckxpc3RlbmVycyhzKTtcbiAgfVxuICAvKipcbiAgICogU2V0cyB1cCBsaXN0ZW5lcnMgZm9yIGVhY2ggY29udHJpYnV0b3IgdG8gdGhlIHJvb20gc3RhdHVzLlxuICAgKlxuICAgKiBAcGFyYW0gdHJhbnNpZW50RGV0YWNoVGltZW91dCBUaGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0byBjb25zaWRlciBhIGRldGFjaCB0byBiZSBcInRyYW5zaWVudFwiXG4gICAqL1xuICBfc2V0dXBDb250cmlidXRvckxpc3RlbmVycyhlKSB7XG4gICAgZm9yIChjb25zdCB0IG9mIHRoaXMuX2NvbnRyaWJ1dG9ycylcbiAgICAgIHQuY2hhbm5lbC5vbihbXCJ1cGRhdGVcIl0sIChyKSA9PiB7XG4gICAgICAgIGlmICghdGhpcy5fZmlyc3RBdHRhY2hlc0NvbXBsZXRlZC5oYXModCkpIHtcbiAgICAgICAgICB0aGlzLl9sb2dnZXIuZGVidWcoXCJSb29tTGlmZWN5Y2xlTWFuYWdlcigpIG9uIHVwZGF0ZTsgaWdub3JpbmcgdXBkYXRlIGV2ZW50IGZvciBmZWF0dXJlIGFzIGZpcnN0IGF0dGFjaFwiLCB7XG4gICAgICAgICAgICBjaGFubmVsOiB0LmNoYW5uZWwubmFtZSxcbiAgICAgICAgICAgIGNoYW5nZTogclxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoci5yZXN1bWVkKSB7XG4gICAgICAgICAgdGhpcy5fbG9nZ2VyLmRlYnVnKFwiUm9vbUxpZmVjeWNsZU1hbmFnZXIoKTsgdXBkYXRlIGV2ZW50IHJlY2VpdmVkIGJ1dCB3YXMgcmVzdW1lXCIpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fb3BlcmF0aW9uSW5Qcm9ncmVzcykge1xuICAgICAgICAgIGlmICh0aGlzLl9wZW5kaW5nRGlzY29udGludWl0eUV2ZW50cy5oYXModCkpIHtcbiAgICAgICAgICAgIHRoaXMuX2xvZ2dlci5kZWJ1ZyhcIlJvb21MaWZlY3ljbGVNYW5hZ2VyKCk7IHN1YnNlcXVlbnQgdXBkYXRlIGV2ZW50IGZvciBmZWF0dXJlIHJlY2VpdmVkLCBpZ25vcmluZ1wiLCB7XG4gICAgICAgICAgICAgIGNoYW5uZWw6IHQuY2hhbm5lbC5uYW1lLFxuICAgICAgICAgICAgICBjaGFuZ2U6IHJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLl9sb2dnZXIuZGVidWcoXG4gICAgICAgICAgICBcIlJvb21MaWZlY3ljbGVNYW5hZ2VyKCk7IHF1ZXVpbmcgcGVuZGluZyB1cGRhdGUgZXZlbnQgZm9yIGZlYXR1cmUgYXMgb3BlcmF0aW9uIGluIHByb2dyZXNzXCIsXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGNoYW5uZWw6IHQuY2hhbm5lbC5uYW1lLFxuICAgICAgICAgICAgICBjaGFuZ2U6IHJcbiAgICAgICAgICAgIH1cbiAgICAgICAgICApLCB0aGlzLl9wZW5kaW5nRGlzY29udGludWl0eUV2ZW50cy5zZXQodCwgci5yZWFzb24pO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9sb2dnZXIuZGVidWcoXCJSb29tTGlmZWN5Y2xlTWFuYWdlcigpOyB1cGRhdGUgZXZlbnQgcmVjZWl2ZWRcIiwge1xuICAgICAgICAgIGNoYW5uZWw6IHQuY2hhbm5lbC5uYW1lLFxuICAgICAgICAgIGNoYW5nZTogclxuICAgICAgICB9KSwgdC5jb250cmlidXRvci5kaXNjb250aW51aXR5RGV0ZWN0ZWQoci5yZWFzb24pO1xuICAgICAgfSksIHQuY2hhbm5lbC5vbihcbiAgICAgICAgW1wiaW5pdGlhbGl6ZWRcIiwgXCJhdHRhY2hpbmdcIiwgXCJhdHRhY2hlZFwiLCBcImRldGFjaGluZ1wiLCBcImRldGFjaGVkXCIsIFwic3VzcGVuZGVkXCIsIFwiZmFpbGVkXCJdLFxuICAgICAgICAocikgPT4ge1xuICAgICAgICAgIGlmICh0aGlzLl9vcGVyYXRpb25JblByb2dyZXNzKSB7XG4gICAgICAgICAgICB0aGlzLl9sb2dnZXIuZGVidWcoXG4gICAgICAgICAgICAgIFwiUm9vbUxpZmVjeWNsZU1hbmFnZXIoKSBvbiBhbGwgZXZlbnRzOyBpZ25vcmluZyBjb250cmlidXRvciBzdGF0ZSBjaGFuZ2UgZHVlIHRvIG9wZXJhdGlvbiBpbiBwcm9ncmVzc1wiLFxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgY2hhbm5lbDogdC5jaGFubmVsLm5hbWUsXG4gICAgICAgICAgICAgICAgY3VycmVudDogci5jdXJyZW50XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICksIHIuY3VycmVudCA9PT0gZC5BdHRhY2hlZCAmJiAhci5yZXN1bWVkICYmIHRoaXMuX2ZpcnN0QXR0YWNoZXNDb21wbGV0ZWQuaGFzKHQpICYmICh0aGlzLl9sb2dnZXIuZGVidWcoXCJSb29tTGlmZWN5Y2xlTWFuYWdlcigpOyByZXN1bWUgZmFpbHVyZSBkZXRlY3RlZFwiLCB7XG4gICAgICAgICAgICAgIGNoYW5uZWw6IHQuY2hhbm5lbC5uYW1lXG4gICAgICAgICAgICB9KSwgdGhpcy5fcGVuZGluZ0Rpc2NvbnRpbnVpdHlFdmVudHMuaGFzKHQpIHx8IHRoaXMuX3BlbmRpbmdEaXNjb250aW51aXR5RXZlbnRzLnNldCh0LCByLnJlYXNvbikpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoci5jdXJyZW50ID09PSBkLkZhaWxlZCkge1xuICAgICAgICAgICAgdGhpcy5fbG9nZ2VyLmRlYnVnKFwiUm9vbUxpZmVjeWNsZU1hbmFnZXIoKTsgZGV0ZWN0ZWQgY2hhbm5lbCBmYWlsdXJlXCIsIHtcbiAgICAgICAgICAgICAgY2hhbm5lbDogdC5jaGFubmVsLm5hbWVcbiAgICAgICAgICAgIH0pLCB0aGlzLl9jbGVhckFsbFRyYW5zaWVudERldGFjaFRpbWVvdXRzKCksIHRoaXMuX29wZXJhdGlvbkluUHJvZ3Jlc3MgPSAhMCwgdGhpcy5fc3RhdHVzLnNldFN0YXR1cyh7XG4gICAgICAgICAgICAgIHN0YXR1czogZC5GYWlsZWQsXG4gICAgICAgICAgICAgIGVycm9yOiByLnJlYXNvblxuICAgICAgICAgICAgfSksIHRoaXMuX2RvQ2hhbm5lbFdpbmREb3duKHQpLmNhdGNoKChzKSA9PiB7XG4gICAgICAgICAgICAgIHRoaXMuX2xvZ2dlci5lcnJvcihcIlJvb21MaWZlY3ljbGVNYW5hZ2VyKCk7IGZhaWxlZCB0byBkZXRhY2ggYWxsIGNoYW5uZWxzIGZvbGxvd2luZyBmYWlsdXJlXCIsIHtcbiAgICAgICAgICAgICAgICBjb250cmlidXRvcjogdC5jaGFubmVsLm5hbWUsXG4gICAgICAgICAgICAgICAgZXJyb3I6IHNcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHIuY3VycmVudCA9PT0gZC5BdHRhY2hlZCkge1xuICAgICAgICAgICAgdGhpcy5fdHJhbnNpZW50RGV0YWNoVGltZW91dHMuaGFzKHQpICYmICh0aGlzLl9sb2dnZXIuZGVidWcoXCJSb29tTGlmZWN5Y2xlTWFuYWdlcigpOyBkZXRlY3RlZCB0cmFuc2llbnQgZGV0YWNoXCIsIHtcbiAgICAgICAgICAgICAgY2hhbm5lbDogdC5jaGFubmVsLm5hbWVcbiAgICAgICAgICAgIH0pLCBjbGVhclRpbWVvdXQodGhpcy5fdHJhbnNpZW50RGV0YWNoVGltZW91dHMuZ2V0KHQpKSwgdGhpcy5fdHJhbnNpZW50RGV0YWNoVGltZW91dHMuZGVsZXRlKHQpKSwgdGhpcy5fc3RhdHVzLmN1cnJlbnQgIT09IGQuQXR0YWNoZWQgJiYgdGhpcy5fY29udHJpYnV0b3JzLmV2ZXJ5KChzKSA9PiBzLmNoYW5uZWwuc3RhdGUgPT09IFwiYXR0YWNoZWRcIikgJiYgKHRoaXMuX2xvZ2dlci5kZWJ1ZyhcIlJvb21MaWZlY3ljbGVNYW5hZ2VyKCk7IGFsbCBmZWF0dXJlcyBhdHRhY2hlZCwgc2V0dGluZyByb29tIHN0YXR1cyB0byBhdHRhY2hlZFwiKSwgdGhpcy5fc3RhdHVzLnNldFN0YXR1cyh7IHN0YXR1czogZC5BdHRhY2hlZCB9KSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChyLmN1cnJlbnQgPT09IGQuU3VzcGVuZGVkKSB7XG4gICAgICAgICAgICB0aGlzLl9sb2dnZXIuZGVidWcoXCJSb29tTGlmZWN5Y2xlTWFuYWdlcigpOyBkZXRlY3RlZCBjaGFubmVsIHN1c3BlbnNpb25cIiwge1xuICAgICAgICAgICAgICBjaGFubmVsOiB0LmNoYW5uZWwubmFtZVxuICAgICAgICAgICAgfSksIHRoaXMuX29uQ2hhbm5lbFN1c3BlbnNpb24odCwgci5yZWFzb24pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoci5jdXJyZW50ID09PSBkLkF0dGFjaGluZyAmJiAhdGhpcy5fdHJhbnNpZW50RGV0YWNoVGltZW91dHMuaGFzKHQpKSB7XG4gICAgICAgICAgICB0aGlzLl9sb2dnZXIuZGVidWcoXCJSb29tTGlmZWN5Y2xlTWFuYWdlcigpOyBkZXRlY3RlZCBjaGFubmVsIGRldGFjaFwiLCB7XG4gICAgICAgICAgICAgIGNoYW5uZWw6IHQuY2hhbm5lbC5uYW1lXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IHMgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgdGhpcy5fc3RhdHVzLnNldFN0YXR1cyh7IHN0YXR1czogZC5BdHRhY2hpbmcsIGVycm9yOiByLnJlYXNvbiB9KSwgdGhpcy5fdHJhbnNpZW50RGV0YWNoVGltZW91dHMuZGVsZXRlKHQpLCBjbGVhclRpbWVvdXQocyk7XG4gICAgICAgICAgICB9LCBlKTtcbiAgICAgICAgICAgIHRoaXMuX3RyYW5zaWVudERldGFjaFRpbWVvdXRzLnNldCh0LCBzKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICk7XG4gIH1cbiAgLyoqXG4gICAqIF9vbkNoYW5uZWxTdXNwZW5zaW9uIGlzIGNhbGxlZCB3aGVuIGEgY29udHJpYnV0aW5nIGNoYW5uZWwgZW50ZXJzIHRoZSBzdXNwZW5kZWQgc3RhdGUsIHdoaWNoIG1lYW5zXG4gICAqIHRoYXQgdGhlIHJvb20gaXMgYWxzbyBzdXNwZW5kZWQgYW5kIHdlIHNob3VsZCB3aW5kLWRvd24gY2hhbm5lbHMgdW50aWwgdGhpbmdzIHJlY292ZXIuXG4gICAqXG4gICAqIFdlIHRyYW5zaXRpb24gdGhlIHJvb20gc3RhdHVzIHRvIHRoZSBzdGF0dXMgb2YgdGhpcyBjb250cmlidXRvciBhbmQgcHJvdmlkZSB0aGUgb3JpZ2luYWxcbiAgICogZXJyb3IgdGhhdCBjYXVzZWQgdGhlIGRldGFjaG1lbnQuXG4gICAqXG4gICAqIEBwYXJhbSBjb250cmlidXRvciBUaGUgY29udHJpYnV0b3IgdGhhdCBoYXMgZGV0YWNoZWQuXG4gICAqIEBwYXJhbSBkZXRhY2hFcnJvciBUaGUgZXJyb3IgdGhhdCBjYXVzZWQgdGhlIGRldGFjaG1lbnQuXG4gICAqL1xuICBfb25DaGFubmVsU3VzcGVuc2lvbihlLCB0KSB7XG4gICAgdGhpcy5fbG9nZ2VyLmRlYnVnKFwiUm9vbUxpZmVjeWNsZU1hbmFnZXIuX29uQ2hhbm5lbFN1c3BlbnNpb24oKTtcIiwge1xuICAgICAgY2hhbm5lbDogZS5jaGFubmVsLm5hbWUsXG4gICAgICBlcnJvcjogdFxuICAgIH0pLCB0aGlzLl9vcGVyYXRpb25JblByb2dyZXNzID0gITAsIHRoaXMuX2NsZWFyQWxsVHJhbnNpZW50RGV0YWNoVGltZW91dHMoKSwgdGhpcy5fbXR4LnJ1bkV4Y2x1c2l2ZShcbiAgICAgICgpID0+ICh0aGlzLl9sb2dnZXIuZXJyb3IoXCJSb29tTGlmZWN5Y2xlTWFuYWdlci5fb25DaGFubmVsU3VzcGVuc2lvbigpOyBzZXR0aW5nIHJvb20gc3RhdHVzIHRvIGNvbnRyaWJ1dG9yIHN0YXR1c1wiLCB7XG4gICAgICAgIHN0YXR1czogZS5jaGFubmVsLnN0YXRlLFxuICAgICAgICBlcnJvcjogdFxuICAgICAgfSksIHRoaXMuX3N0YXR1cy5zZXRTdGF0dXMoe1xuICAgICAgICBzdGF0dXM6IGUuY2hhbm5lbC5zdGF0ZSxcbiAgICAgICAgZXJyb3I6IHRcbiAgICAgIH0pLCB0aGlzLl9kb1JldHJ5KGUpKSxcbiAgICAgIDBcbiAgICAgIC8qIEludGVybmFsICovXG4gICAgKS5jYXRjaCgocikgPT4ge1xuICAgICAgdGhpcy5fbG9nZ2VyLmVycm9yKFwiUm9vbUxpZmVjeWNsZU1hbmFnZXIuX29uQ2hhbm5lbFN1c3BlbnNpb24oKTsgdW5leHBlY3RlZCBlcnJvciB0aHJvd25cIiwgeyBlcnJvcjogciB9KTtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogR2l2ZW4gc29tZSBjb250cmlidXRvciB0aGF0IGhhcyBlbnRlcmVkIGEgc3VzcGVuZGVkIHN0YXRlOlxuICAgKlxuICAgKiAtIFdpbmQgZG93biBhbnkgb3RoZXIgY2hhbm5lbHNcbiAgICogLSBXYWl0IGZvciBvdXIgY29udHJpYnV0b3IgdG8gcmVjb3ZlclxuICAgKiAtIEF0dGFjaCBldmVyeXRoaW5nIGVsc2VcbiAgICpcbiAgICogUmVwZWF0IHVudGlsIGVpdGhlciBvZiB0aGUgZm9sbG93aW5nIGhhcHBlbnM6XG4gICAqXG4gICAqIC0gT3VyIGNvbnRyaWJ1dG9yIHJlYXR0YWNoZXMgYW5kIHdlIGNhbiBhdHRhY2ggZXZlcnl0aGluZyBlbHNlIChyZXBlYXQgd2l0aCB0aGUgbmV4dCBjb250cmlidXRvciB0byBicmVhayBpZiBuZWNlc3NhcnkpXG4gICAqIC0gVGhlIHJvb20gZW50ZXJzIGEgZmFpbGVkIHN0YXRlXG4gICAqXG4gICAqIEBwYXJhbSBjb250cmlidXRvciBUaGUgY29udHJpYnV0b3IgdGhhdCBoYXMgZW50ZXJlZCBhIHN1c3BlbmRlZCBzdGF0ZS5cbiAgICogQHJldHVybnMgQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2hlbiB0aGUgcm9vbSBpcyBhdHRhY2hlZCwgb3IgdGhlIHJvb20gZW50ZXJzIGEgZmFpbGVkIHN0YXRlLlxuICAgKi9cbiAgYXN5bmMgX2RvUmV0cnkoZSkge1xuICAgIGNvbnN0IHQgPSAoKSA9PiAodGhpcy5fbG9nZ2VyLmRlYnVnKFwiUm9vbUxpZmVjeWNsZU1hbmFnZXIuZG9BdHRhY2hXaXRoUmV0cnkoKTtcIiksIHRoaXMuX3N0YXR1cy5zZXRTdGF0dXMoeyBzdGF0dXM6IGQuQXR0YWNoaW5nIH0pLCB0aGlzLl9kb0F0dGFjaCgpLnRoZW4oKHIpID0+IHtcbiAgICAgIHZhciBzO1xuICAgICAgaWYgKHRoaXMuX2xvZ2dlci5kZWJ1ZyhcIlJvb21MaWZlY3ljbGVNYW5hZ2VyLmRvQXR0YWNoV2l0aFJldHJ5KCk7IGF0dGFjaCByZXN1bHRcIiwge1xuICAgICAgICBzdGF0dXM6IHIuc3RhdHVzLFxuICAgICAgICBlcnJvcjogci5lcnJvcixcbiAgICAgICAgZmFpbGVkRmVhdHVyZTogKHMgPSByLmZhaWxlZEZlYXR1cmUpID09IG51bGwgPyB2b2lkIDAgOiBzLmNoYW5uZWwubmFtZVxuICAgICAgfSksIHIuc3RhdHVzID09PSBkLkZhaWxlZCkge1xuICAgICAgICB0aGlzLl9tdHgucnVuRXhjbHVzaXZlKFxuICAgICAgICAgICgpID0+IHRoaXMuX3J1bkRvd25DaGFubmVsc09uRmFpbGVkQXR0YWNoKCksXG4gICAgICAgICAgMFxuICAgICAgICAgIC8qIEludGVybmFsICovXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChyLnN0YXR1cyA9PT0gZC5TdXNwZW5kZWQpIHtcbiAgICAgICAgY29uc3QgYyA9IHIuZmFpbGVkRmVhdHVyZTtcbiAgICAgICAgaWYgKCFjKVxuICAgICAgICAgIHRocm93IG5ldyBoLkVycm9ySW5mbyhcIm5vIGZhaWxlZCBmZWF0dXJlIGluIF9kb1JldHJ5XCIsIG0uUm9vbUxpZmVjeWNsZUVycm9yLCA1MDApO1xuICAgICAgICByZXR1cm4gdGhpcy5fbG9nZ2VyLmRlYnVnKFwiUm9vbUxpZmVjeWNsZU1hbmFnZXIuZG9BdHRhY2hXaXRoUmV0cnkoKTsgZmVhdHVyZSBzdXNwZW5kZWQsIHJldHJ5aW5nIGF0dGFjaFwiLCB7XG4gICAgICAgICAgZmVhdHVyZTogYy5jaGFubmVsLm5hbWVcbiAgICAgICAgfSksIHRoaXMuX2RvUmV0cnkoYykuY2F0Y2goKTtcbiAgICAgIH1cbiAgICB9KSk7XG4gICAgdGhpcy5fbG9nZ2VyLmRlYnVnKFwiUm9vbUxpZmVjeWNsZU1hbmFnZXIuX2RvUmV0cnkoKTsgd2luZGluZyBkb3duIGNoYW5uZWxzIGV4Y2VwdCBwcm9ibGVtXCIsIHtcbiAgICAgIGNoYW5uZWw6IGUuY2hhbm5lbC5uYW1lXG4gICAgfSk7XG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IHRoaXMuX2RvQ2hhbm5lbFdpbmREb3duKGUpLmNhdGNoKCgpID0+IHtcbiAgICAgICAgaWYgKHRoaXMuX3N0YXR1cy5jdXJyZW50ID09PSBkLkZhaWxlZClcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJyb29tIGlzIGluIGEgZmFpbGVkIHN0YXRlXCIpO1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHIpID0+IHtcbiAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIHIodGhpcy5fZG9DaGFubmVsV2luZERvd24oZSkpO1xuICAgICAgICAgIH0sIDI1MCk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfSBjYXRjaCB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHJldHVybiBlLmNoYW5uZWwuc3RhdGUgPT09IGQuQXR0YWNoZWQgPyAodGhpcy5fbG9nZ2VyLmRlYnVnKFwiUm9vbUxpZmVjeWNsZU1hbmFnZXIuX2RvUmV0cnkoKTsgZmVhdHVyZSByZWF0dGFjaGVkLCByZXRyeWluZyBhdHRhY2hcIiksIHQoKSkgOiBuZXcgUHJvbWlzZSgocikgPT4ge1xuICAgICAgY29uc3QgcyA9IChjKSA9PiB7XG4gICAgICAgIGlmIChjLmN1cnJlbnQgPT09IGQuQXR0YWNoZWQpIHtcbiAgICAgICAgICBlLmNoYW5uZWwub2ZmKHMpLCByKCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjLmN1cnJlbnQgPT09IGQuRmFpbGVkKVxuICAgICAgICAgIHRocm93IGUuY2hhbm5lbC5vZmYocyksIHRoaXMuX3N0YXR1cy5zZXRTdGF0dXMoeyBzdGF0dXM6IGQuRmFpbGVkLCBlcnJvcjogYy5yZWFzb24gfSksIGMucmVhc29uID8/IG5ldyBoLkVycm9ySW5mbyhcInVua25vd24gZXJyb3IgaW4gX2RvUmV0cnlcIiwgbS5Sb29tTGlmZWN5Y2xlRXJyb3IsIDUwMCk7XG4gICAgICB9O1xuICAgICAgZS5jaGFubmVsLm9uKHMpO1xuICAgIH0pLnRoZW4oKCkgPT4gKHRoaXMuX2xvZ2dlci5kZWJ1ZyhcIlJvb21MaWZlY3ljbGVNYW5hZ2VyLl9kb1JldHJ5KCk7IGZlYXR1cmUgcmVhdHRhY2hlZCB2aWEgbGlzdGVuZXIsIHJldHJ5aW5nIGF0dGFjaFwiKSwgdCgpKSk7XG4gIH1cbiAgLyoqXG4gICAqIENsZWFycyBhbGwgdHJhbnNpZW50IGRldGFjaCB0aW1lb3V0cyAtIHVzZWQgd2hlbiBzb21lIGV2ZW50IHN1cGVyc2VkZXMgdGhlIHRyYW5zaWVudCBkZXRhY2ggc3VjaFxuICAgKiBhcyBhIGZhaWxlZCBjaGFubmVsIG9yIHN1c3BlbnNpb24uXG4gICAqL1xuICBfY2xlYXJBbGxUcmFuc2llbnREZXRhY2hUaW1lb3V0cygpIHtcbiAgICBmb3IgKGNvbnN0IGUgb2YgdGhpcy5fdHJhbnNpZW50RGV0YWNoVGltZW91dHMudmFsdWVzKCkpXG4gICAgICBjbGVhclRpbWVvdXQoZSk7XG4gICAgdGhpcy5fdHJhbnNpZW50RGV0YWNoVGltZW91dHMuY2xlYXIoKTtcbiAgfVxuICAvKipcbiAgICogVHJ5IHRvIGF0dGFjaCBhbGwgdGhlIGNoYW5uZWxzIGluIGEgcm9vbS5cbiAgICpcbiAgICogSWYgdGhlIG9wZXJhdGlvbiBzdWNjZWVkcywgdGhlIHJvb20gZW50ZXJzIHRoZSBhdHRhY2hlZCBzdGF0ZSBhbmQgdGhpcyBwcm9taXNlIHJlc29sdmVzLlxuICAgKiBJZiBhIGNoYW5uZWwgZW50ZXJzIHRoZSBzdXNwZW5kZWQgc3RhdGUsIHRoZW4gd2UgcmVqZWN0LCBidXQgd2Ugd2lsbCByZXRyeSBhZnRlciBhIHNob3J0IGRlbGF5IGFzIGlzIHRoZSBjYXNlXG4gICAqIGluIHRoZSBjb3JlIFNESy5cbiAgICogSWYgYSBjaGFubmVsIGVudGVycyB0aGUgZmFpbGVkIHN0YXRlLCB3ZSByZWplY3QgYW5kIHRoZW4gYmVnaW4gdG8gd2luZCBkb3duIHRoZSBvdGhlciBjaGFubmVscy5cbiAgICovXG4gIGF0dGFjaCgpIHtcbiAgICByZXR1cm4gdGhpcy5fbG9nZ2VyLnRyYWNlKFwiUm9vbUxpZmVjeWNsZU1hbmFnZXIuYXR0YWNoKCk7XCIpLCB0aGlzLl9tdHgucnVuRXhjbHVzaXZlKFxuICAgICAgYXN5bmMgKCkgPT4ge1xuICAgICAgICBpZiAodGhpcy5fc3RhdHVzLmN1cnJlbnQgIT09IGQuQXR0YWNoZWQpIHtcbiAgICAgICAgICBpZiAodGhpcy5fc3RhdHVzLmN1cnJlbnQgPT09IGQuUmVsZWFzZWQpXG4gICAgICAgICAgICB0aHJvdyBuZXcgaC5FcnJvckluZm8oXCJ1bmFibGUgdG8gYXR0YWNoIHJvb207IHJvb20gaXMgcmVsZWFzZWRcIiwgbS5Sb29tSXNSZWxlYXNlZCwgNTAwKTtcbiAgICAgICAgICBpZiAodGhpcy5fc3RhdHVzLmN1cnJlbnQgPT09IGQuUmVsZWFzaW5nKVxuICAgICAgICAgICAgdGhyb3cgbmV3IGguRXJyb3JJbmZvKFwidW5hYmxlIHRvIGF0dGFjaCByb29tOyByb29tIGlzIHJlbGVhc2luZ1wiLCBtLlJvb21Jc1JlbGVhc2luZywgNTAwKTtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fY2xlYXJBbGxUcmFuc2llbnREZXRhY2hUaW1lb3V0cygpLCB0aGlzLl9vcGVyYXRpb25JblByb2dyZXNzID0gITAsIHRoaXMuX3N0YXR1cy5zZXRTdGF0dXMoeyBzdGF0dXM6IGQuQXR0YWNoaW5nIH0pLCB0aGlzLl9kb0F0dGFjaCgpLnRoZW4oKGUpID0+IHtcbiAgICAgICAgICAgIHZhciB0O1xuICAgICAgICAgICAgaWYgKGUuc3RhdHVzID09PSBkLkZhaWxlZClcbiAgICAgICAgICAgICAgdGhyb3cgdGhpcy5fbG9nZ2VyLmRlYnVnKFwiUm9vbUxpZmVjeWNsZU1hbmFnZXIuYXR0YWNoKCk7IHJvb20gZW50ZXJlZCBmYWlsZWQsIHdpbmRpbmcgZG93biBjaGFubmVsc1wiLCB7IHJlc3VsdDogZSB9KSwgdGhpcy5fbXR4LnJ1bkV4Y2x1c2l2ZShcbiAgICAgICAgICAgICAgICAoKSA9PiB0aGlzLl9ydW5Eb3duQ2hhbm5lbHNPbkZhaWxlZEF0dGFjaCgpLFxuICAgICAgICAgICAgICAgIDBcbiAgICAgICAgICAgICAgICAvKiBJbnRlcm5hbCAqL1xuICAgICAgICAgICAgICApLCBlLmVycm9yID8/IG5ldyBoLkVycm9ySW5mbyhcInVua25vd24gZXJyb3IgaW4gYXR0YWNoXCIsIG0uUm9vbUxpZmVjeWNsZUVycm9yLCA1MDApO1xuICAgICAgICAgICAgaWYgKGUuc3RhdHVzID09PSBkLlN1c3BlbmRlZCkge1xuICAgICAgICAgICAgICB0aGlzLl9sb2dnZXIuZGVidWcoXCJSb29tTGlmZWN5Y2xlTWFuYWdlci5hdHRhY2goKTsgcm9vbSBlbnRlcmVkIHN1c3BlbmRlZCwgd2lsbCByZXRyeVwiLCB7XG4gICAgICAgICAgICAgICAgZXJyb3I6IGUuZXJyb3IsXG4gICAgICAgICAgICAgICAgY29udHJpYnV0b3I6ICh0ID0gZS5mYWlsZWRGZWF0dXJlKSA9PSBudWxsID8gdm9pZCAwIDogdC5jaGFubmVsLm5hbWVcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIGNvbnN0IHIgPSBlLmZhaWxlZEZlYXR1cmU7XG4gICAgICAgICAgICAgIHRocm93IHIgPyAodGhpcy5fbXR4LnJ1bkV4Y2x1c2l2ZShcbiAgICAgICAgICAgICAgICAoKSA9PiB0aGlzLl9kb1JldHJ5KHIpLmNhdGNoKCksXG4gICAgICAgICAgICAgICAgMFxuICAgICAgICAgICAgICAgIC8qIEludGVybmFsICovXG4gICAgICAgICAgICAgICksIGUuZXJyb3IgPz8gbmV3IGguRXJyb3JJbmZvKFwidW5rbm93biBlcnJvciBpbiBhdHRhY2ggdGhlbiBibG9ja1wiLCBtLlJvb21MaWZlY3ljbGVFcnJvciwgNTAwKSkgOiBuZXcgaC5FcnJvckluZm8oXCJubyBmYWlsZWQgZmVhdHVyZSBpbiBhdHRhY2hcIiwgbS5Sb29tTGlmZWN5Y2xlRXJyb3IsIDUwMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICAyXG4gICAgICAvKiBBdHRhY2hPckRldGFjaCAqL1xuICAgICk7XG4gIH1cbiAgYXN5bmMgX2RvQXR0YWNoKCkge1xuICAgIHRoaXMuX2xvZ2dlci50cmFjZShcIlJvb21MaWZlY3ljbGVNYW5hZ2VyLl9kb0F0dGFjaCgpO1wiKTtcbiAgICBjb25zdCBlID0ge1xuICAgICAgc3RhdHVzOiBkLkF0dGFjaGVkXG4gICAgfTtcbiAgICBmb3IgKGNvbnN0IHQgb2YgdGhpcy5fY29udHJpYnV0b3JzKVxuICAgICAgdHJ5IHtcbiAgICAgICAgdGhpcy5fbG9nZ2VyLmRlYnVnKFwiUm9vbUxpZmVjeWNsZU1hbmFnZXIuX2RvQXR0YWNoKCk7IGF0dGFjaGluZ1wiLCB7IGNoYW5uZWw6IHQuY2hhbm5lbC5uYW1lIH0pLCBhd2FpdCB0LmNoYW5uZWwuYXR0YWNoKCksIHRoaXMuX2xvZ2dlci5kZWJ1ZyhcIlJvb21MaWZlY3ljbGVNYW5hZ2VyLl9kb0F0dGFjaCgpOyBhdHRhY2hlZFwiLCB7IGNoYW5uZWw6IHQuY2hhbm5lbC5uYW1lIH0pLCB0aGlzLl9maXJzdEF0dGFjaGVzQ29tcGxldGVkLnNldCh0LCAhMCk7XG4gICAgICB9IGNhdGNoIChyKSB7XG4gICAgICAgIHN3aXRjaCAodGhpcy5fbG9nZ2VyLmVycm9yKFwiUm9vbUxpZmVjeWNsZU1hbmFnZXIuX2RvQXR0YWNoKCk7IGZhaWxlZCB0byBhdHRhY2hcIiwgeyBlcnJvcjogZS5lcnJvciB9KSwgZS5mYWlsZWRGZWF0dXJlID0gdCwgZS5lcnJvciA9IG5ldyBoLkVycm9ySW5mbyhcbiAgICAgICAgICBcImZhaWxlZCB0byBhdHRhY2ggZmVhdHVyZVwiLFxuICAgICAgICAgIHQuY29udHJpYnV0b3IuYXR0YWNobWVudEVycm9yQ29kZSxcbiAgICAgICAgICA1MDAsXG4gICAgICAgICAgclxuICAgICAgICApLCB0LmNoYW5uZWwuc3RhdGUpIHtcbiAgICAgICAgICBjYXNlIFwic3VzcGVuZGVkXCI6IHtcbiAgICAgICAgICAgIGUuc3RhdHVzID0gZC5TdXNwZW5kZWQ7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSBcImZhaWxlZFwiOiB7XG4gICAgICAgICAgICBlLnN0YXR1cyA9IGQuRmFpbGVkO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aGlzLl9sb2dnZXIuZXJyb3IoXCJVbmV4cGVjdGVkIGNoYW5uZWwgc3RhdGVcIiwgeyBzdGF0ZTogdC5jaGFubmVsLnN0YXRlIH0pLCBlLnN0YXR1cyA9IGQuRmFpbGVkLCBlLmVycm9yID0gbmV3IGguRXJyb3JJbmZvKFxuICAgICAgICAgICAgICBgdW5leHBlY3RlZCBjaGFubmVsIHN0YXRlIGluIGRvQXR0YWNoICR7dC5jaGFubmVsLnN0YXRlfWAsXG4gICAgICAgICAgICAgIG0uUm9vbUxpZmVjeWNsZUVycm9yLFxuICAgICAgICAgICAgICA1MDAsXG4gICAgICAgICAgICAgIGUuZXJyb3JcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX3N0YXR1cy5zZXRTdGF0dXMoZSksIGU7XG4gICAgICB9XG4gICAgdGhpcy5fc3RhdHVzLnNldFN0YXR1cyhlKSwgdGhpcy5fb3BlcmF0aW9uSW5Qcm9ncmVzcyA9ICExO1xuICAgIGZvciAoY29uc3QgW3QsIHJdIG9mIHRoaXMuX3BlbmRpbmdEaXNjb250aW51aXR5RXZlbnRzKVxuICAgICAgdC5jb250cmlidXRvci5kaXNjb250aW51aXR5RGV0ZWN0ZWQocik7XG4gICAgcmV0dXJuIHRoaXMuX3BlbmRpbmdEaXNjb250aW51aXR5RXZlbnRzLmNsZWFyKCksIGU7XG4gIH1cbiAgLyoqXG4gICAqIElmIHdlJ3ZlIGZhaWxlZCB0byBhdHRhY2gsIHRoZW4gd2UncmUgaW4gdGhlIGZhaWxlZCBzdGF0ZSBhbmQgYWxsIHRoYXQgaXMgbGVmdCB0byBkbyBpcyB0byBkZXRhY2ggYWxsIHRoZSBjaGFubmVscy5cbiAgICpcbiAgICogQHJldHVybnMgQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2hlbiBhbGwgY2hhbm5lbHMgYXJlIGRldGFjaGVkLiBXZSBkbyBub3QgdGhyb3cuXG4gICAqL1xuICBfcnVuRG93bkNoYW5uZWxzT25GYWlsZWRBdHRhY2goKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RvQ2hhbm5lbFdpbmREb3duKCkuY2F0Y2goKCkgPT4gKHRoaXMuX2xvZ2dlci5kZWJ1ZyhcIlJvb21MaWZlY3ljbGVNYW5hZ2VyLl9ydW5Eb3duQ2hhbm5lbHNPbkZhaWxlZEF0dGFjaCgpOyB3aW5kIGRvd24gZmFpbGVkLCByZXRyeWluZ1wiKSwgbmV3IFByb21pc2UoKGUpID0+IHtcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBlKHRoaXMuX3J1bkRvd25DaGFubmVsc09uRmFpbGVkQXR0YWNoKCkpO1xuICAgICAgfSwgMjUwKTtcbiAgICB9KSkpO1xuICB9XG4gIC8qKlxuICAgKiBEZXRhY2ggYWxsIGZlYXR1cmVzIGV4Y2VwdCB0aGUgb25lIGV4Y2VwdGlvbiBwcm92aWRlZC5cbiAgICogSWYgdGhlIHJvb20gaXMgaW4gYSBmYWlsZWQgc3RhdGUsIHRoZW4gYWxsIGNoYW5uZWxzIHNob3VsZCBlaXRoZXIgcmVhY2ggdGhlIGZhaWxlZCBzdGF0ZSBvciBiZSBkZXRhY2hlZC5cbiAgICpcbiAgICogQHBhcmFtIGV4Y2VwdCBUaGUgY29udHJpYnV0b3IgdG8gZXhjbHVkZSBmcm9tIHRoZSBkZXRhY2htZW50LlxuICAgKiBAcmV0dXJucyBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB3aGVuIGFsbCBjaGFubmVscyBhcmUgZGV0YWNoZWQuXG4gICAqL1xuICBfZG9DaGFubmVsV2luZERvd24oZSkge1xuICAgIHJldHVybiBQcm9taXNlLmFsbChcbiAgICAgIHRoaXMuX2NvbnRyaWJ1dG9ycy5tYXAoYXN5bmMgKHQpID0+IHtcbiAgICAgICAgaWYgKCEodCA9PT0gZSAmJiB0aGlzLl9zdGF0dXMuY3VycmVudCAhPT0gZC5GYWlsZWQpKSB7XG4gICAgICAgICAgaWYgKCh0aGlzLl9zdGF0dXMuY3VycmVudCA9PT0gZC5GYWlsZWQgfHwgdGhpcy5fc3RhdHVzLmN1cnJlbnQgPT09IGQuUmVsZWFzaW5nIHx8IHRoaXMuX3N0YXR1cy5jdXJyZW50ID09PSBkLlJlbGVhc2VkKSAmJiB0LmNoYW5uZWwuc3RhdGUgPT09IFwiZmFpbGVkXCIpIHtcbiAgICAgICAgICAgIHRoaXMuX2xvZ2dlci5kZWJ1ZyhcIlJvb21MaWZlY3ljbGVNYW5hZ2VyLl9kb0NoYW5uZWxXaW5kRG93bigpOyBpZ25vcmluZyBmYWlsZWQgY2hhbm5lbFwiLCB7XG4gICAgICAgICAgICAgIGNoYW5uZWw6IHQuY2hhbm5lbC5uYW1lXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMuX2xvZ2dlci5kZWJ1ZyhcIlJvb21MaWZlY3ljbGVNYW5hZ2VyLl9kb0NoYW5uZWxXaW5kRG93bigpOyBkZXRhY2hpbmdcIiwge1xuICAgICAgICAgICAgICBjaGFubmVsOiB0LmNoYW5uZWwubmFtZVxuICAgICAgICAgICAgfSksIGF3YWl0IHQuY2hhbm5lbC5kZXRhY2goKSwgdGhpcy5fbG9nZ2VyLmRlYnVnKFwiUm9vbUxpZmVjeWNsZU1hbmFnZXIuX2RvQ2hhbm5lbFdpbmREb3duKCk7IGRldGFjaGVkXCIsIHtcbiAgICAgICAgICAgICAgY2hhbm5lbDogdC5jaGFubmVsLm5hbWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gY2F0Y2ggKHIpIHtcbiAgICAgICAgICAgIGlmICh0LmNoYW5uZWwuc3RhdGUgPT09IFwiZmFpbGVkXCIgJiYgdGhpcy5fc3RhdHVzLmN1cnJlbnQgIT09IGQuRmFpbGVkICYmIHRoaXMuX3N0YXR1cy5jdXJyZW50ICE9PSBkLlJlbGVhc2luZyAmJiB0aGlzLl9zdGF0dXMuY3VycmVudCAhPT0gZC5SZWxlYXNlZCkge1xuICAgICAgICAgICAgICBjb25zdCBzID0gbmV3IGguRXJyb3JJbmZvKFxuICAgICAgICAgICAgICAgIFwiZmFpbGVkIHRvIGRldGFjaCBmZWF0dXJlXCIsXG4gICAgICAgICAgICAgICAgdC5jb250cmlidXRvci5kZXRhY2htZW50RXJyb3JDb2RlLFxuICAgICAgICAgICAgICAgIDUwMCxcbiAgICAgICAgICAgICAgICByXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIHRocm93IHRoaXMuX3N0YXR1cy5zZXRTdGF0dXMoeyBzdGF0dXM6IGQuRmFpbGVkLCBlcnJvcjogcyB9KSwgcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IG5ldyBoLkVycm9ySW5mbyhcImRldGFjaCBmYWlsdXJlLCByZXRyeVwiLCAtMSwgLTEsIHIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSlcbiAgICApO1xuICB9XG4gIC8qKlxuICAgKiBEZXRhY2hlcyB0aGUgcm9vbS4gSWYgdGhlIHJvb20gaXMgYWxyZWFkeSBkZXRhY2hlZCwgdGhpcyBpcyBhIG5vLW9wLlxuICAgKiBJZiBvbmUgb2YgdGhlIGNoYW5uZWxzIGZhaWxzIHRvIGRldGFjaCwgdGhlIHJvb20gc3RhdHVzIHdpbGwgYmUgc2V0IHRvIGZhaWxlZC5cbiAgICogSWYgdGhlIHJvb20gaXMgaW4gdGhlIHByb2Nlc3Mgb2YgZGV0YWNoaW5nLCB0aGlzIHdpbGwgd2FpdCBmb3IgdGhlIGRldGFjaG1lbnQgdG8gY29tcGxldGUuXG4gICAqXG4gICAqIEByZXR1cm5zIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHdoZW4gdGhlIHJvb20gaXMgZGV0YWNoZWQuXG4gICAqL1xuICBkZXRhY2goKSB7XG4gICAgcmV0dXJuIHRoaXMuX2xvZ2dlci50cmFjZShcIlJvb21MaWZlY3ljbGVNYW5hZ2VyLmRldGFjaCgpO1wiKSwgdGhpcy5fbXR4LnJ1bkV4Y2x1c2l2ZShcbiAgICAgIGFzeW5jICgpID0+IHtcbiAgICAgICAgaWYgKHRoaXMuX3N0YXR1cy5jdXJyZW50ICE9PSBkLkRldGFjaGVkKSB7XG4gICAgICAgICAgaWYgKHRoaXMuX3N0YXR1cy5jdXJyZW50ID09PSBkLlJlbGVhc2VkKVxuICAgICAgICAgICAgdGhyb3cgbmV3IGguRXJyb3JJbmZvKFwidW5hYmxlIHRvIGRldGFjaCByb29tOyByb29tIGlzIHJlbGVhc2VkXCIsIG0uUm9vbUlzUmVsZWFzZWQsIDUwMCk7XG4gICAgICAgICAgaWYgKHRoaXMuX3N0YXR1cy5jdXJyZW50ID09PSBkLlJlbGVhc2luZylcbiAgICAgICAgICAgIHRocm93IG5ldyBoLkVycm9ySW5mbyhcInVuYWJsZSB0byBkZXRhY2ggcm9vbTsgcm9vbSBpcyByZWxlYXNpbmdcIiwgbS5Sb29tSXNSZWxlYXNpbmcsIDUwMCk7XG4gICAgICAgICAgaWYgKHRoaXMuX3N0YXR1cy5jdXJyZW50ID09PSBkLkZhaWxlZClcbiAgICAgICAgICAgIHRocm93IG5ldyBoLkVycm9ySW5mbyhcInVuYWJsZSB0byBkZXRhY2ggcm9vbTsgcm9vbSBoYXMgZmFpbGVkXCIsIG0uUm9vbUluRmFpbGVkU3RhdGUsIDUwMCk7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX29wZXJhdGlvbkluUHJvZ3Jlc3MgPSAhMCwgdGhpcy5fY2xlYXJBbGxUcmFuc2llbnREZXRhY2hUaW1lb3V0cygpLCB0aGlzLl9zdGF0dXMuc2V0U3RhdHVzKHsgc3RhdHVzOiBkLkRldGFjaGluZyB9KSwgdGhpcy5fZG9EZXRhY2goKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIDJcbiAgICAgIC8qIEF0dGFjaE9yRGV0YWNoICovXG4gICAgKTtcbiAgfVxuICAvKipcbiAgICogUGVyZm9ybSBhIGRldGFjaC5cbiAgICpcbiAgICogSWYgZGV0YWNoaW5nIGEgY2hhbm5lbCBmYWlscywgd2Ugc2hvdWxkIHJldHJ5IHVudGlsIGV2ZXJ5IGNoYW5uZWwgaXMgZWl0aGVyIGluIHRoZSBkZXRhY2hlZCBzdGF0ZSwgb3IgaW4gdGhlIGZhaWxlZCBzdGF0ZS5cbiAgICovXG4gIGFzeW5jIF9kb0RldGFjaCgpIHtcbiAgICB0aGlzLl9sb2dnZXIudHJhY2UoXCJSb29tTGlmZWN5Y2xlTWFuYWdlci5fZG9EZXRhY2goKTtcIik7XG4gICAgbGV0IGUsIHQgPSAhMTtcbiAgICBmb3IgKDsgIXQ7ICkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdGhpcy5fbG9nZ2VyLmRlYnVnKFwiUm9vbUxpZmVjeWNsZU1hbmFnZXIuX2RvRGV0YWNoKCk7IGRldGFjaGluZyBhbGwgY2hhbm5lbHNcIiksIGF3YWl0IHRoaXMuX2RvQ2hhbm5lbFdpbmREb3duKCk7XG4gICAgICB9IGNhdGNoIChyKSB7XG4gICAgICAgIGlmICh0aGlzLl9sb2dnZXIuZXJyb3IoXCJSb29tTGlmZWN5Y2xlTWFuYWdlci5fZG9EZXRhY2goKTsgZmFpbGVkIHRvIGRldGFjaCBhbGwgY2hhbm5lbHNcIiwgeyBlcnJvcjogciB9KSwgciBpbnN0YW5jZW9mIGguRXJyb3JJbmZvICYmIHIuY29kZSA9PT0gLTEpIHtcbiAgICAgICAgICB0aGlzLl9sb2dnZXIuZGVidWcoXCJSb29tTGlmZWN5Y2xlTWFuYWdlci5fZG9EZXRhY2goKTsgcmV0cnlpbmcgZGV0YWNoXCIsIHsgZXJyb3I6IHIgfSksIGF3YWl0IG5ldyBQcm9taXNlKChzKSA9PiBzZXRUaW1lb3V0KHMsIDI1MCkpO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGUgfHwgKHRoaXMuX2xvZ2dlci5kZWJ1ZyhcIlJvb21MaWZlY3ljbGVNYW5hZ2VyLl9kb0RldGFjaCgpOyBjaGFubmVsIGZhaWxlZCBvbiBkZXRhY2hcIiwgeyBlcnJvcjogciB9KSwgZSA9IHIpLCBhd2FpdCBuZXcgUHJvbWlzZSgocykgPT4gc2V0VGltZW91dChzLCAyNTApKSwgdGhpcy5fbG9nZ2VyLmRlYnVnKFwiUm9vbUxpZmVjeWNsZU1hbmFnZXIuX2RvRGV0YWNoKCk7IHJldHJ5aW5nIGRldGFjaCBhZnRlciBmYWlsZWQgY2hhbm5lbFwiKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICB0ID0gITA7XG4gICAgfVxuICAgIGlmICh0aGlzLl9zdGF0dXMuY3VycmVudCAhPT0gZC5GYWlsZWQpIHtcbiAgICAgIHRoaXMuX3N0YXR1cy5zZXRTdGF0dXMoeyBzdGF0dXM6IGQuRGV0YWNoZWQgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRocm93IGUgPz8gbmV3IGguRXJyb3JJbmZvKFwidW5rbm93biBlcnJvciBpbiBfZG9EZXRhY2hcIiwgbS5Sb29tTGlmZWN5Y2xlRXJyb3IsIDUwMCk7XG4gIH1cbiAgLyoqXG4gICAqIFJlbGVhc2VzIHRoZSByb29tLiBJZiB0aGUgcm9vbSBpcyBhbHJlYWR5IHJlbGVhc2VkLCB0aGlzIGlzIGEgbm8tb3AuXG4gICAqIEFueSBjaGFubmVsIHRoYXQgZGV0YWNoZXMgaW50byB0aGUgZmFpbGVkIHN0YXRlIGlzIG9rLiBCdXQgYW55IGNoYW5uZWwgdGhhdCBmYWlscyB0byBkZXRhY2hcbiAgICogd2lsbCBjYXVzZSB0aGUgcm9vbSBzdGF0dXMgdG8gYmUgc2V0IHRvIGZhaWxlZC5cbiAgICpcbiAgICogQHJldHVybnMgUmV0dXJucyBhIHByb21pc2UgdGhhdCByZXNvbHZlcyB3aGVuIHRoZSByb29tIGlzIHJlbGVhc2VkLiBJZiBhIGNoYW5uZWwgZGV0YWNoZXMgaW50byBhIG5vbi10ZXJtaW5hdGVkXG4gICAqIHN0YXRlIChlLmcuIGF0dGFjaGVkKSwgdGhlIHByb21pc2Ugd2lsbCByZWplY3QuXG4gICAqL1xuICByZWxlYXNlKCkge1xuICAgIHJldHVybiB0aGlzLl9sb2dnZXIudHJhY2UoXCJSb29tTGlmZWN5Y2xlTWFuYWdlci5yZWxlYXNlKCk7XCIpLCB0aGlzLl9tdHgucnVuRXhjbHVzaXZlKFxuICAgICAgYXN5bmMgKCkgPT4ge1xuICAgICAgICBpZiAodGhpcy5fc3RhdHVzLmN1cnJlbnQgIT09IGQuUmVsZWFzZWQpIHtcbiAgICAgICAgICBpZiAodGhpcy5fc3RhdHVzLmN1cnJlbnQgPT09IGQuRGV0YWNoZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX3N0YXR1cy5zZXRTdGF0dXMoeyBzdGF0dXM6IGQuUmVsZWFzZWQgfSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0aGlzLl9yZWxlYXNlSW5Qcm9ncmVzcyA/IG5ldyBQcm9taXNlKChlLCB0KSA9PiB7XG4gICAgICAgICAgICB0aGlzLl9zdGF0dXMub25DaGFuZ2VPbmNlKChyKSA9PiB7XG4gICAgICAgICAgICAgIGlmIChyLmN1cnJlbnQgPT09IGQuUmVsZWFzZWQpIHtcbiAgICAgICAgICAgICAgICBlKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHRoaXMuX2xvZ2dlci5lcnJvcihcIlJvb21MaWZlY3ljbGVNYW5hZ2VyLnJlbGVhc2UoKTsgZXhwZWN0ZWQgYSBub24tYXR0YWNoZWQgc3RhdGVcIiwgciksIHQoXG4gICAgICAgICAgICAgICAgbmV3IGguRXJyb3JJbmZvKFxuICAgICAgICAgICAgICAgICAgXCJmYWlsZWQgdG8gcmVsZWFzZSByb29tOyBleGlzdGluZyBhdHRlbXB0IGZhaWxlZFwiLFxuICAgICAgICAgICAgICAgICAgbS5QcmV2aW91c09wZXJhdGlvbkZhaWxlZCxcbiAgICAgICAgICAgICAgICAgIDUwMCxcbiAgICAgICAgICAgICAgICAgIHIuZXJyb3JcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KSA6ICh0aGlzLl9jbGVhckFsbFRyYW5zaWVudERldGFjaFRpbWVvdXRzKCksIHRoaXMuX29wZXJhdGlvbkluUHJvZ3Jlc3MgPSAhMCwgdGhpcy5fcmVsZWFzZUluUHJvZ3Jlc3MgPSAhMCwgdGhpcy5fc3RhdHVzLnNldFN0YXR1cyh7IHN0YXR1czogZC5SZWxlYXNpbmcgfSksIHRoaXMuX2xvZ2dlci5kZWJ1ZyhcIlJvb21MaWZlY3ljbGVNYW5hZ2VyLnJlbGVhc2UoKTsgcmVsZWFzaW5nIHJvb21cIiksIHRoaXMuX3JlbGVhc2VDaGFubmVscygpKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIDFcbiAgICAgIC8qIFJlbGVhc2UgKi9cbiAgICApO1xuICB9XG4gIC8qKlxuICAgKiAgUmVsZWFzZXMgdGhlIHJvb20gYnkgZGV0YWNoaW5nIGFsbCBjaGFubmVscy4gSWYgdGhlIHJlbGVhc2Ugb3BlcmF0aW9uIGZhaWxzLCB3ZSB3YWl0XG4gICAqICBhIHNob3J0IHBlcmlvZCBhbmQgdGhlbiB0cnkgYWdhaW4uXG4gICAqL1xuICBfcmVsZWFzZUNoYW5uZWxzKCkge1xuICAgIHJldHVybiB0aGlzLl9kb1JlbGVhc2UoKS5jYXRjaCgoZSkgPT4gKHRoaXMuX2xvZ2dlci5lcnJvcihcIlJvb21MaWZlY3ljbGVNYW5hZ2VyLl9yZWxlYXNlQ2hhbm5lbHMoKTsgZmFpbGVkIHRvIHJlbGVhc2Ugcm9vbSwgcmV0cnlpbmdcIiwgeyBlcnJvcjogZSB9KSwgbmV3IFByb21pc2UoKHQpID0+IHtcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICB0KHRoaXMuX3JlbGVhc2VDaGFubmVscygpKTtcbiAgICAgIH0sIDI1MCk7XG4gICAgfSkpKTtcbiAgfVxuICAvKipcbiAgICogUGVyZm9ybXMgdGhlIHJlbGVhc2Ugb3BlcmF0aW9uLiBUaGlzIHdpbGwgZGV0YWNoIGFsbCBjaGFubmVscyBpbiB0aGUgcm9vbSB0aGF0IGFyZW4ndFxuICAgKiBhbHJlYWR5IGRldGFjaGVkIG9yIGluIHRoZSBmYWlsZWQgc3RhdGUuXG4gICAqL1xuICBfZG9SZWxlYXNlKCkge1xuICAgIHJldHVybiBQcm9taXNlLmFsbChcbiAgICAgIHRoaXMuX2NvbnRyaWJ1dG9ycy5tYXAoYXN5bmMgKGUpID0+IHtcbiAgICAgICAgaWYgKGUuY2hhbm5lbC5zdGF0ZSA9PT0gXCJmYWlsZWRcIikge1xuICAgICAgICAgIHRoaXMuX2xvZ2dlci5kZWJ1ZyhcIlJvb21MaWZlY3ljbGVNYW5hZ2VyLnJlbGVhc2UoKTsgaWdub3JpbmcgZmFpbGVkIGNoYW5uZWxcIiwge1xuICAgICAgICAgICAgY2hhbm5lbDogZS5jaGFubmVsLm5hbWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGUuY2hhbm5lbC5zdGF0ZSA9PT0gXCJkZXRhY2hlZFwiKSB7XG4gICAgICAgICAgdGhpcy5fbG9nZ2VyLmRlYnVnKFwiUm9vbUxpZmVjeWNsZU1hbmFnZXIucmVsZWFzZSgpOyBpZ25vcmluZyBkZXRhY2hlZCBjaGFubmVsXCIsIHtcbiAgICAgICAgICAgIGNoYW5uZWw6IGUuY2hhbm5lbC5uYW1lXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdGhpcy5fbG9nZ2VyLmRlYnVnKFwiUm9vbUxpZmVjeWNsZU1hbmFnZXIucmVsZWFzZSgpOyBkZXRhY2hpbmdcIiwge1xuICAgICAgICAgICAgY2hhbm5lbDogZS5jaGFubmVsLm5hbWVcbiAgICAgICAgICB9KSwgYXdhaXQgZS5jaGFubmVsLmRldGFjaCgpLCB0aGlzLl9sb2dnZXIuZGVidWcoXCJSb29tTGlmZWN5Y2xlTWFuYWdlci5yZWxlYXNlKCk7IGRldGFjaGVkXCIsIHtcbiAgICAgICAgICAgIGNoYW5uZWw6IGUuY2hhbm5lbC5uYW1lXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gY2F0Y2ggKHQpIHtcbiAgICAgICAgICB0aHJvdyB0aGlzLl9sb2dnZXIuZXJyb3IoXCJSb29tTGlmZWN5Y2xlTWFuYWdlci5yZWxlYXNlKCk7IGZhaWxlZCB0byBkZXRhY2hcIiwge1xuICAgICAgICAgICAgZXJyb3I6IHQsXG4gICAgICAgICAgICBjaGFubmVsOiBlLmNoYW5uZWwubmFtZSxcbiAgICAgICAgICAgIHN0YXRlOiBlLmNoYW5uZWwuc3RhdGVcbiAgICAgICAgICB9KSwgdDtcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICApLnRoZW4oKCkgPT4ge1xuICAgICAgdGhpcy5fcmVsZWFzZUluUHJvZ3Jlc3MgPSAhMSwgdGhpcy5fc3RhdHVzLnNldFN0YXR1cyh7IHN0YXR1czogZC5SZWxlYXNlZCB9KTtcbiAgICB9KTtcbiAgfVxufVxuY29uc3QgQ3IgPSB7XG4gIC8qKlxuICAgKiBUaGUgZGVmYXVsdCBwcmVzZW5jZSBvcHRpb25zIGZvciBhIGNoYXQgcm9vbS5cbiAgICovXG4gIHByZXNlbmNlOiB7XG4gICAgLyoqXG4gICAgICogVGhlIGNsaWVudCBzaG91bGQgYmUgYWJsZSB0byBlbnRlciBwcmVzZW5jZS5cbiAgICAgKi9cbiAgICBlbnRlcjogITAsXG4gICAgLyoqXG4gICAgICogVGhlIGNsaWVudCBzaG91bGQgYmUgYWJsZSB0byBzdWJzY3JpYmUgdG8gcHJlc2VuY2UuXG4gICAgICovXG4gICAgc3Vic2NyaWJlOiAhMFxuICB9LFxuICAvKipcbiAgICogVGhlIGRlZmF1bHQgdHlwaW5nIG9wdGlvbnMgZm9yIGEgY2hhdCByb29tLlxuICAgKi9cbiAgdHlwaW5nOiB7XG4gICAgLyoqXG4gICAgICogVGhlIGRlZmF1bHQgdGltZW91dCBmb3IgdHlwaW5nIGV2ZW50cyBpbiBtaWxsaXNlY29uZHMuXG4gICAgICovXG4gICAgdGltZW91dE1zOiAxZTRcbiAgfSxcbiAgLyoqXG4gICAqIFRoZSBkZWZhdWx0IHJlYWN0aW9ucyBvcHRpb25zIGZvciBhIGNoYXQgcm9vbS5cbiAgICovXG4gIHJlYWN0aW9uczoge30sXG4gIC8qKlxuICAgKiBUaGUgZGVmYXVsdCBvY2N1cGFuY3kgb3B0aW9ucyBmb3IgYSBjaGF0IHJvb20uXG4gICAqL1xuICBvY2N1cGFuY3k6IHt9XG59LCBmciA9IChpKSA9PiBuZXcgaC5FcnJvckluZm8oYGludmFsaWQgcm9vbSBjb25maWd1cmF0aW9uOiAke2l9YCwgNDAwMDEsIDQwMCksIF9yID0gKGkpID0+IHtcbiAgaWYgKGkudHlwaW5nICYmIGkudHlwaW5nLnRpbWVvdXRNcyA8PSAwKVxuICAgIHRocm93IGZyKFwidHlwaW5nIHRpbWVvdXQgbXVzdCBiZSBncmVhdGVyIHRoYW4gMFwiKTtcbn07XG5jbGFzcyBtciB7XG4gIGNvbnN0cnVjdG9yKGUsIHQsIHIsIHMsIGMsIHUpIHtcbiAgICB0aGlzLnR5cGUgPSBlLCB0aGlzLmNsaWVudElkID0gdCwgdGhpcy5jcmVhdGVkQXQgPSByLCB0aGlzLmlzU2VsZiA9IHMsIHRoaXMubWV0YWRhdGEgPSBjLCB0aGlzLmhlYWRlcnMgPSB1LCBPYmplY3QuZnJlZXplKHRoaXMpO1xuICB9XG59XG5mdW5jdGlvbiBndChpLCBlKSB7XG4gIHZhciByO1xuICBjb25zdCB0ID0gaTtcbiAgaWYgKCF0LmRhdGEpXG4gICAgdGhyb3cgbmV3IGguRXJyb3JJbmZvKFwicmVjZWl2ZWQgaW5jb21pbmcgbWVzc2FnZSB3aXRob3V0IGRhdGFcIiwgNWU0LCA1MDApO1xuICBpZiAoIXQuZGF0YS50eXBlIHx8IHR5cGVvZiB0LmRhdGEudHlwZSAhPSBcInN0cmluZ1wiKVxuICAgIHRocm93IG5ldyBoLkVycm9ySW5mbyhcImludmFsaWQgcmVhY3Rpb24gbWVzc2FnZSB3aXRoIG5vIHR5cGVcIiwgNWU0LCA1MDApO1xuICBpZiAoIXQuY2xpZW50SWQpXG4gICAgdGhyb3cgbmV3IGguRXJyb3JJbmZvKFwicmVjZWl2ZWQgaW5jb21pbmcgbWVzc2FnZSB3aXRob3V0IGNsaWVudElkXCIsIDVlNCwgNTAwKTtcbiAgaWYgKCF0LnRpbWVzdGFtcClcbiAgICB0aHJvdyBuZXcgaC5FcnJvckluZm8oXCJyZWNlaXZlZCBpbmNvbWluZyBtZXNzYWdlIHdpdGhvdXQgdGltZXN0YW1wXCIsIDVlNCwgNTAwKTtcbiAgcmV0dXJuIG5ldyBtcihcbiAgICB0LmRhdGEudHlwZSxcbiAgICB0LmNsaWVudElkLFxuICAgIG5ldyBEYXRlKHQudGltZXN0YW1wKSxcbiAgICBlID8gZSA9PT0gdC5jbGllbnRJZCA6ICExLFxuICAgIHQuZGF0YS5tZXRhZGF0YSA/PyB7fSxcbiAgICAoKHIgPSB0LmV4dHJhcykgPT0gbnVsbCA/IHZvaWQgMCA6IHIuaGVhZGVycykgPz8ge31cbiAgKTtcbn1cbmNsYXNzIHByIGV4dGVuZHMgUyB7XG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RzIGEgbmV3IGBEZWZhdWx0Um9vbVJlYWN0aW9uc2AgaW5zdGFuY2UuXG4gICAqIEBwYXJhbSByb29tSWQgVGhlIHVuaXF1ZSBpZGVudGlmaWVyIG9mIHRoZSByb29tLlxuICAgKiBAcGFyYW0gcmVhbHRpbWUgQW4gaW5zdGFuY2Ugb2YgdGhlIEFibHkgUmVhbHRpbWUgY2xpZW50LlxuICAgKiBAcGFyYW0gY2xpZW50SWQgVGhlIGNsaWVudCBJRCBvZiB0aGUgdXNlci5cbiAgICogQHBhcmFtIGxvZ2dlciBBbiBpbnN0YW5jZSBvZiB0aGUgTG9nZ2VyLlxuICAgKiBAcGFyYW0gaW5pdEFmdGVyIEEgcHJvbWlzZSB0aGF0IGlzIGF3YWl0ZWQgYmVmb3JlIGNyZWF0aW5nIGFueSBjaGFubmVscy5cbiAgICovXG4gIGNvbnN0cnVjdG9yKGUsIHQsIHIsIHMsIGMpIHtcbiAgICBzdXBlcigpLCB0aGlzLl9kaXNjb250aW51aXR5RW1pdHRlciA9IFcoKSwgdGhpcy5fZm9yd2FyZGVyID0gKHUpID0+IHtcbiAgICAgIGNvbnN0IGcgPSB0aGlzLl9wYXJzZU5ld1JlYWN0aW9uKHUsIHRoaXMuX2NsaWVudElkKTtcbiAgICAgIGcgJiYgdGhpcy5lbWl0KHouUmVhY3Rpb24sIGcpO1xuICAgIH0sIHRoaXMuX2NoYW5uZWwgPSBjLnRoZW4oKCkgPT4gdGhpcy5fbWFrZUNoYW5uZWwoZSwgdCkpLCB0aGlzLl9jaGFubmVsLmNhdGNoKCh1KSA9PiB7XG4gICAgICBzLmRlYnVnKFwiUm9vbVJlYWN0aW9uczogY2hhbm5lbCBpbml0aWFsaXphdGlvbiBjYW5jZWxlZFwiLCB7IHJvb21JZDogZSwgZXJyb3I6IHUgfSk7XG4gICAgfSksIHRoaXMuX2NsaWVudElkID0gciwgdGhpcy5fbG9nZ2VyID0gcztcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlcyB0aGUgcmVhbHRpbWUgY2hhbm5lbCBmb3Igcm9vbSByZWFjdGlvbnMuIENhbGxlZCBhZnRlciBpbml0QWZ0ZXIgaXMgcmVzb2x2ZWQuXG4gICAqL1xuICBfbWFrZUNoYW5uZWwoZSwgdCkge1xuICAgIGNvbnN0IHIgPSBxKGAke2V9OjokY2hhdDo6JHJlYWN0aW9uc2AsIHQpO1xuICAgIHJldHVybiBtZSh7XG4gICAgICBsaXN0ZW5lcjogdGhpcy5fZm9yd2FyZGVyLmJpbmQodGhpcyksXG4gICAgICBldmVudHM6IFt6LlJlYWN0aW9uXSxcbiAgICAgIGNoYW5uZWw6IHJcbiAgICB9KSwgcjtcbiAgfVxuICAvKipcbiAgICogQGluaGVyaXREb2MgUmVhY3Rpb25zXG4gICAqL1xuICBzZW5kKGUpIHtcbiAgICB0aGlzLl9sb2dnZXIudHJhY2UoXCJSb29tUmVhY3Rpb25zLnNlbmQoKTtcIiwgZSk7XG4gICAgY29uc3QgeyB0eXBlOiB0LCBtZXRhZGF0YTogciwgaGVhZGVyczogcyB9ID0gZTtcbiAgICBpZiAoIXQpXG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IGguRXJyb3JJbmZvKFwidW5hYmxlIHRvIHNlbmQgcmVhY3Rpb247IHR5cGUgbm90IHNldCBhbmQgaXQgaXMgcmVxdWlyZWRcIiwgNDAwMDEsIDQwMCkpO1xuICAgIGlmIChyICYmIHJbXCJhYmx5LWNoYXRcIl0gIT09IHZvaWQgMClcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChcbiAgICAgICAgbmV3IGguRXJyb3JJbmZvKFwidW5hYmxlIHRvIHNlbmQgcmVhY3Rpb247IG1ldGFkYXRhIGNhbm5vdCB1c2UgcmVzZXJ2ZWQga2V5ICdhYmx5LWNoYXQnXCIsIDQwMDAxLCA0MDApXG4gICAgICApO1xuICAgIGlmIChzKSB7XG4gICAgICBmb3IgKGNvbnN0IGcgb2YgT2JqZWN0LmtleXMocykpXG4gICAgICAgIGlmIChnLnN0YXJ0c1dpdGgoXCJhYmx5LWNoYXRcIikpXG4gICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KFxuICAgICAgICAgICAgbmV3IGguRXJyb3JJbmZvKFxuICAgICAgICAgICAgICBcInVuYWJsZSB0byBzZW5kIHJlYWN0aW9uOyBoZWFkZXJzIGNhbm5vdCBoYXZlIGFueSBrZXkgc3RhcnRpbmcgd2l0aCByZXNlcnZlZCBwcmVmaXggJ2FibHktY2hhdCdcIixcbiAgICAgICAgICAgICAgNDAwMDEsXG4gICAgICAgICAgICAgIDQwMFxuICAgICAgICAgICAgKVxuICAgICAgICAgICk7XG4gICAgfVxuICAgIGNvbnN0IGMgPSB7XG4gICAgICB0eXBlOiB0LFxuICAgICAgbWV0YWRhdGE6IHIgPz8ge31cbiAgICB9LCB1ID0ge1xuICAgICAgbmFtZTogei5SZWFjdGlvbixcbiAgICAgIGRhdGE6IGMsXG4gICAgICBleHRyYXM6IHtcbiAgICAgICAgaGVhZGVyczogcyA/PyB7fVxuICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIHRoaXMuX2NoYW5uZWwudGhlbigoZykgPT4gZy5wdWJsaXNoKHUpKTtcbiAgfVxuICAvKipcbiAgICogQGluaGVyaXREb2MgUmVhY3Rpb25zXG4gICAqL1xuICBzdWJzY3JpYmUoZSkge1xuICAgIHJldHVybiB0aGlzLl9sb2dnZXIudHJhY2UoXCJSb29tUmVhY3Rpb25zLnN1YnNjcmliZSgpO1wiKSwgdGhpcy5vbihlKSwge1xuICAgICAgdW5zdWJzY3JpYmU6ICgpID0+IHtcbiAgICAgICAgdGhpcy5fbG9nZ2VyLnRyYWNlKFwiUm9vbVJlYWN0aW9ucy51bnN1YnNjcmliZSgpO1wiKSwgdGhpcy5vZmYoZSk7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogQGluaGVyaXREb2MgUmVhY3Rpb25zXG4gICAqL1xuICB1bnN1YnNjcmliZUFsbCgpIHtcbiAgICB0aGlzLl9sb2dnZXIudHJhY2UoXCJSb29tUmVhY3Rpb25zLnVuc3Vic2NyaWJlQWxsKCk7XCIpLCB0aGlzLm9mZigpO1xuICB9XG4gIGdldCBjaGFubmVsKCkge1xuICAgIHJldHVybiB0aGlzLl9jaGFubmVsO1xuICB9XG4gIF9wYXJzZU5ld1JlYWN0aW9uKGUsIHQpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGd0KGUsIHQpO1xuICAgIH0gY2F0Y2ggKHIpIHtcbiAgICAgIHRoaXMuX2xvZ2dlci5lcnJvcihcImZhaWxlZCB0byBwYXJzZSBpbmNvbWluZyByZWFjdGlvbjtcIiwgeyBpbmJvdW5kOiBlLCBlcnJvcjogciB9KTtcbiAgICB9XG4gIH1cbiAgZGlzY29udGludWl0eURldGVjdGVkKGUpIHtcbiAgICB0aGlzLl9sb2dnZXIud2FybihcIlJvb21SZWFjdGlvbnMuZGlzY29udGludWl0eURldGVjdGVkKCk7XCIsIHsgcmVhc29uOiBlIH0pLCB0aGlzLl9kaXNjb250aW51aXR5RW1pdHRlci5lbWl0KFwiZGlzY29udGludWl0eVwiLCBlKTtcbiAgfVxuICBvbkRpc2NvbnRpbnVpdHkoZSkge1xuICAgIHJldHVybiB0aGlzLl9sb2dnZXIudHJhY2UoXCJSb29tUmVhY3Rpb25zLm9uRGlzY29udGludWl0eSgpO1wiKSwgdGhpcy5fZGlzY29udGludWl0eUVtaXR0ZXIub24oZSksIHtcbiAgICAgIG9mZjogKCkgPT4ge1xuICAgICAgICB0aGlzLl9kaXNjb250aW51aXR5RW1pdHRlci5vZmYoZSk7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogQGluaGVyaXRkb2MgQ29udHJpYnV0ZXNUb1Jvb21MaWZlY3ljbGVcbiAgICovXG4gIGdldCBhdHRhY2htZW50RXJyb3JDb2RlKCkge1xuICAgIHJldHVybiBtLlJlYWN0aW9uc0F0dGFjaG1lbnRGYWlsZWQ7XG4gIH1cbiAgLyoqXG4gICAqIEBpbmhlcml0ZG9jIENvbnRyaWJ1dGVzVG9Sb29tTGlmZWN5Y2xlXG4gICAqL1xuICBnZXQgZGV0YWNobWVudEVycm9yQ29kZSgpIHtcbiAgICByZXR1cm4gbS5SZWFjdGlvbnNEZXRhY2htZW50RmFpbGVkO1xuICB9XG59XG5jb25zdCB5ciA9IDE1MDAsIHdyID0gM2U0LCBiciA9IDU7XG5jbGFzcyB2ciBleHRlbmRzIFMge1xuICAvKipcbiAgICogQ29uc3RydWN0cyBhIG5ldyBgRGVmYXVsdFR5cGluZ2AgaW5zdGFuY2UuXG4gICAqIEBwYXJhbSByb29tSWQgVGhlIHVuaXF1ZSBpZGVudGlmaWVyIG9mIHRoZSByb29tLlxuICAgKiBAcGFyYW0gb3B0aW9ucyBUaGUgb3B0aW9ucyBmb3IgdHlwaW5nIGluIHRoZSByb29tLlxuICAgKiBAcGFyYW0gcmVhbHRpbWUgQW4gaW5zdGFuY2Ugb2YgdGhlIEFibHkgUmVhbHRpbWUgY2xpZW50LlxuICAgKiBAcGFyYW0gY2xpZW50SWQgVGhlIGNsaWVudCBJRCBvZiB0aGUgdXNlci5cbiAgICogQHBhcmFtIGxvZ2dlciBBbiBpbnN0YW5jZSBvZiB0aGUgTG9nZ2VyLlxuICAgKiBAcGFyYW0gaW5pdEFmdGVyIEEgcHJvbWlzZSB0aGF0IGlzIGF3YWl0ZWQgYmVmb3JlIGNyZWF0aW5nIGFueSBjaGFubmVscy5cbiAgICovXG4gIGNvbnN0cnVjdG9yKGUsIHQsIHIsIHMsIGMsIHUpIHtcbiAgICBzdXBlcigpLCB0aGlzLl9kaXNjb250aW51aXR5RW1pdHRlciA9IFcoKSwgdGhpcy5fcmVjZWl2ZWRFdmVudE51bWJlciA9IDAsIHRoaXMuX3RyaWdnZXJlZEV2ZW50TnVtYmVyID0gMCwgdGhpcy5fY3VycmVudGx5VHlwaW5nID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKSwgdGhpcy5fbnVtUmV0cmllcyA9IDAsIHRoaXMuX2ludGVybmFsU3Vic2NyaWJlVG9FdmVudHMgPSAoZykgPT4ge1xuICAgICAgaWYgKCFnLmNsaWVudElkKSB7XG4gICAgICAgIHRoaXMuX2xvZ2dlci5lcnJvcihcInVuYWJsZSB0byBoYW5kbGUgdHlwaW5nIGV2ZW50OyBubyBjbGllbnRJZFwiLCB7IG1lbWJlcjogZyB9KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5fcmVjZWl2ZWRFdmVudE51bWJlciArPSAxLCB0aGlzLl9yZXRyeVRpbWVvdXQgJiYgKGNsZWFyVGltZW91dCh0aGlzLl9yZXRyeVRpbWVvdXQpLCB0aGlzLl9yZXRyeVRpbWVvdXQgPSB2b2lkIDAsIHRoaXMuX251bVJldHJpZXMgPSAwKSwgdGhpcy5fZ2V0QW5kRW1pdCh0aGlzLl9yZWNlaXZlZEV2ZW50TnVtYmVyKTtcbiAgICB9LCB0aGlzLl9jbGllbnRJZCA9IHMsIHRoaXMuX2NoYW5uZWwgPSB1LnRoZW4oKCkgPT4gdGhpcy5fbWFrZUNoYW5uZWwoZSwgcikpLCB0aGlzLl9jaGFubmVsLmNhdGNoKChnKSA9PiB7XG4gICAgICBjLmRlYnVnKFwiVHlwaW5nOiBjaGFubmVsIGluaXRpYWxpemF0aW9uIGNhbmNlbGVkXCIsIHsgcm9vbUlkOiBlLCBlcnJvcjogZyB9KTtcbiAgICB9KSwgdGhpcy5fdHlwaW5nVGltZW91dE1zID0gdC50aW1lb3V0TXMsIHRoaXMuX2xvZ2dlciA9IGM7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZXMgdGhlIHJlYWx0aW1lIGNoYW5uZWwgZm9yIHR5cGluZyBpbmRpY2F0b3JzLiBDYWxsZWQgYWZ0ZXIgaW5pdEFmdGVyIGlzIHJlc29sdmVkLlxuICAgKi9cbiAgX21ha2VDaGFubmVsKGUsIHQpIHtcbiAgICBjb25zdCByID0gcShgJHtlfTo6JGNoYXQ6OiR0eXBpbmdJbmRpY2F0b3JzYCwgdCk7XG4gICAgcmV0dXJuIHV0KHtcbiAgICAgIGxpc3RlbmVyOiB0aGlzLl9pbnRlcm5hbFN1YnNjcmliZVRvRXZlbnRzLmJpbmQodGhpcyksXG4gICAgICBjaGFubmVsOiByXG4gICAgfSksIHI7XG4gIH1cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqL1xuICBnZXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NoYW5uZWwudGhlbihcbiAgICAgIChlKSA9PiBlLnByZXNlbmNlLmdldCgpLnRoZW4oKHQpID0+IG5ldyBTZXQodC5tYXAoKHIpID0+IHIuY2xpZW50SWQpKSlcbiAgICApO1xuICB9XG4gIC8qKlxuICAgKiBAaW5oZXJpdERvY1xuICAgKi9cbiAgZ2V0IGNoYW5uZWwoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NoYW5uZWw7XG4gIH1cbiAgLyoqXG4gICAqIFN0YXJ0IHRoZSB0eXBpbmcgdGltZW91dCB0aW1lci4gVGhpcyB3aWxsIGVtaXQgYSB0eXBpbmdTdG9wcGVkIGV2ZW50IGlmIHRoZSB0aW1lciBleHBpcmVzLlxuICAgKi9cbiAgX3N0YXJ0VHlwaW5nVGltZXIoKSB7XG4gICAgdGhpcy5fbG9nZ2VyLnRyYWNlKFwiRGVmYXVsdFR5cGluZy5zdGFydFR5cGluZ1RpbWVyKCk7XCIpLCB0aGlzLl90aW1lcklkID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICB0aGlzLl9sb2dnZXIuZGVidWcoXCJEZWZhdWx0VHlwaW5nLnN0YXJ0VHlwaW5nVGltZXIoKTsgdGltZW91dCBleHBpcmVkXCIpLCB0aGlzLnN0b3AoKTtcbiAgICB9LCB0aGlzLl90eXBpbmdUaW1lb3V0TXMpO1xuICB9XG4gIC8qKlxuICAgKiBAaW5oZXJpdERvY1xuICAgKi9cbiAgYXN5bmMgc3RhcnQoKSB7XG4gICAgaWYgKHRoaXMuX2xvZ2dlci50cmFjZShcIkRlZmF1bHRUeXBpbmcuc3RhcnQoKTtcIiksIHRoaXMuX3RpbWVySWQpIHtcbiAgICAgIHRoaXMuX2xvZ2dlci5kZWJ1ZyhcIkRlZmF1bHRUeXBpbmcuc3RhcnQoKTsgYWxyZWFkeSB0eXBpbmcsIHJlc2V0dGluZyB0aW1lclwiKSwgY2xlYXJUaW1lb3V0KHRoaXMuX3RpbWVySWQpLCB0aGlzLl9zdGFydFR5cGluZ1RpbWVyKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9zdGFydFR5cGluZ1RpbWVyKCksIChhd2FpdCB0aGlzLmNoYW5uZWwpLnByZXNlbmNlLmVudGVyQ2xpZW50KHRoaXMuX2NsaWVudElkKS50aGVuKCk7XG4gIH1cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqL1xuICBhc3luYyBzdG9wKCkge1xuICAgIHJldHVybiB0aGlzLl9sb2dnZXIudHJhY2UoXCJEZWZhdWx0VHlwaW5nLnN0b3AoKTtcIiksIHRoaXMuX3RpbWVySWQgJiYgKGNsZWFyVGltZW91dCh0aGlzLl90aW1lcklkKSwgdGhpcy5fdGltZXJJZCA9IHZvaWQgMCksIChhd2FpdCB0aGlzLmNoYW5uZWwpLnByZXNlbmNlLmxlYXZlQ2xpZW50KHRoaXMuX2NsaWVudElkKTtcbiAgfVxuICAvKipcbiAgICogQGluaGVyaXREb2NcbiAgICovXG4gIHN1YnNjcmliZShlKSB7XG4gICAgcmV0dXJuIHRoaXMuX2xvZ2dlci50cmFjZShcIkRlZmF1bHRUeXBpbmcuc3Vic2NyaWJlKCk7XCIpLCB0aGlzLm9uKGUpLCB7XG4gICAgICB1bnN1YnNjcmliZTogKCkgPT4ge1xuICAgICAgICB0aGlzLl9sb2dnZXIudHJhY2UoXCJEZWZhdWx0VHlwaW5nLnVuc3Vic2NyaWJlKCk7XCIpLCB0aGlzLm9mZihlKTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBAaW5oZXJpdERvY1xuICAgKi9cbiAgdW5zdWJzY3JpYmVBbGwoKSB7XG4gICAgdGhpcy5fbG9nZ2VyLnRyYWNlKFwiRGVmYXVsdFR5cGluZy51bnN1YnNjcmliZUFsbCgpO1wiKSwgdGhpcy5vZmYoKTtcbiAgfVxuICBfZ2V0QW5kRW1pdChlKSB7XG4gICAgdGhpcy5nZXQoKS50aGVuKCh0KSA9PiB7XG4gICAgICB0aGlzLl9yZXRyeVRpbWVvdXQgJiYgKGNsZWFyVGltZW91dCh0aGlzLl9yZXRyeVRpbWVvdXQpLCB0aGlzLl9yZXRyeVRpbWVvdXQgPSB2b2lkIDAsIHRoaXMuX251bVJldHJpZXMgPSAwKSwgISh0aGlzLl90cmlnZ2VyZWRFdmVudE51bWJlciA+PSBlKSAmJiAodGhpcy5fdHJpZ2dlcmVkRXZlbnROdW1iZXIgPSBlLCAhaih0aGlzLl9jdXJyZW50bHlUeXBpbmcsIHQpICYmICh0aGlzLl9jdXJyZW50bHlUeXBpbmcgPSB0LCB0aGlzLmVtaXQoY3QuQ2hhbmdlZCwge1xuICAgICAgICBjdXJyZW50bHlUeXBpbmc6IG5ldyBTZXQodClcbiAgICAgIH0pKSk7XG4gICAgfSkuY2F0Y2goKHQpID0+IHtcbiAgICAgIGNvbnN0IHIgPSB0aGlzLl9udW1SZXRyaWVzIDwgYnI7XG4gICAgICBpZiAodGhpcy5fbG9nZ2VyLmVycm9yKFwiRXJyb3IgZmV0Y2hpbmcgY3VycmVudGx5IHR5cGluZyBjbGllbnRJZHMgc2V0LlwiLCB7XG4gICAgICAgIGVycm9yOiB0LFxuICAgICAgICB3aWxsUmVhdHRlbXB0OiByXG4gICAgICB9KSwgIXIgfHwgdGhpcy5fcmV0cnlUaW1lb3V0KVxuICAgICAgICByZXR1cm47XG4gICAgICBjb25zdCBzID0gTWF0aC5taW4oXG4gICAgICAgIHdyLFxuICAgICAgICB5ciAqIE1hdGgucG93KDIsIHRoaXMuX251bVJldHJpZXMpXG4gICAgICApO1xuICAgICAgdGhpcy5fbnVtUmV0cmllcyArPSAxLCB0aGlzLl9yZXRyeVRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgdGhpcy5fcmV0cnlUaW1lb3V0ID0gdm9pZCAwLCB0aGlzLl9yZWNlaXZlZEV2ZW50TnVtYmVyKyssIHRoaXMuX2dldEFuZEVtaXQodGhpcy5fcmVjZWl2ZWRFdmVudE51bWJlcik7XG4gICAgICB9LCBzKTtcbiAgICB9KTtcbiAgfVxuICBvbkRpc2NvbnRpbnVpdHkoZSkge1xuICAgIHJldHVybiB0aGlzLl9sb2dnZXIudHJhY2UoXCJEZWZhdWx0VHlwaW5nLm9uRGlzY29udGludWl0eSgpO1wiKSwgdGhpcy5fZGlzY29udGludWl0eUVtaXR0ZXIub24oZSksIHtcbiAgICAgIG9mZjogKCkgPT4ge1xuICAgICAgICB0aGlzLl9kaXNjb250aW51aXR5RW1pdHRlci5vZmYoZSk7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuICBkaXNjb250aW51aXR5RGV0ZWN0ZWQoZSkge1xuICAgIHRoaXMuX2xvZ2dlci53YXJuKFwiRGVmYXVsdFR5cGluZy5kaXNjb250aW51aXR5RGV0ZWN0ZWQoKTtcIiwgeyByZWFzb246IGUgfSksIHRoaXMuX2Rpc2NvbnRpbnVpdHlFbWl0dGVyLmVtaXQoXCJkaXNjb250aW51aXR5XCIsIGUpO1xuICB9XG4gIGdldCB0aW1lb3V0TXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3R5cGluZ1RpbWVvdXRNcztcbiAgfVxuICAvKipcbiAgICogQGluaGVyaXRkb2MgQ29udHJpYnV0ZXNUb1Jvb21MaWZlY3ljbGVcbiAgICovXG4gIGdldCBhdHRhY2htZW50RXJyb3JDb2RlKCkge1xuICAgIHJldHVybiBtLlR5cGluZ0F0dGFjaG1lbnRGYWlsZWQ7XG4gIH1cbiAgLyoqXG4gICAqIEBpbmhlcml0ZG9jIENvbnRyaWJ1dGVzVG9Sb29tTGlmZWN5Y2xlXG4gICAqL1xuICBnZXQgZGV0YWNobWVudEVycm9yQ29kZSgpIHtcbiAgICByZXR1cm4gbS5UeXBpbmdEZXRhY2htZW50RmFpbGVkO1xuICB9XG59XG5mdW5jdGlvbiBScihpKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgoZSkgPT4ge1xuICAgIGkudGhlbigoKSA9PiB7XG4gICAgICBlKCk7XG4gICAgfSkuY2F0Y2goKCkgPT4ge1xuICAgICAgZSgpO1xuICAgIH0pO1xuICB9KTtcbn1cbmZ1bmN0aW9uIGF0KGkpIHtcbiAgbGV0IGU7XG4gIGNvbnN0IHQgPSAocykgPT4gZSA/IChlKHMpLCBlID0gdm9pZCAwLCAhMCkgOiAhMTtcbiAgcmV0dXJuIHsgcHJvbWlzZTogbmV3IFByb21pc2UoKHMsIGMpID0+IHtcbiAgICBlID0gYywgaS50aGVuKCh1KSA9PiB7XG4gICAgICBlICYmIChlID0gdm9pZCAwLCBzKHUpKTtcbiAgICB9KS5jYXRjaCgodSkgPT4ge1xuICAgICAgZSAmJiAoZSA9IHZvaWQgMCwgYyh1KSk7XG4gICAgfSk7XG4gIH0pLCByZWplY3Q6IHQgfTtcbn1cbmNsYXNzIEFyIHtcbiAgLyoqXG4gICAqIENvbnN0cnVjdHMgYSBuZXcgUm9vbSBpbnN0YW5jZS5cbiAgICpcbiAgICogQHBhcmFtIHJvb21JZCBUaGUgdW5pcXVlIGlkZW50aWZpZXIgb2YgdGhlIHJvb20uXG4gICAqIEBwYXJhbSBvcHRpb25zIFRoZSBvcHRpb25zIGZvciB0aGUgcm9vbS5cbiAgICogQHBhcmFtIHJlYWx0aW1lIEFuIGluc3RhbmNlIG9mIHRoZSBBYmx5IFJlYWx0aW1lIGNsaWVudC5cbiAgICogQHBhcmFtIGNoYXRBcGkgQW4gaW5zdGFuY2Ugb2YgdGhlIENoYXRBcGkuXG4gICAqIEBwYXJhbSBsb2dnZXIgQW4gaW5zdGFuY2Ugb2YgdGhlIExvZ2dlci5cbiAgICogQHBhcmFtIGluaXRBZnRlciBUaGUgcm9vbSB3aWxsIHdhaXQgZm9yIHRoaXMgcHJvbWlzZSB0byBmaW5pc2ggYmVmb3JlIGluaXRpYWxpemluZ1xuICAgKi9cbiAgY29uc3RydWN0b3IoZSwgdCwgciwgcywgYywgdSkge1xuICAgIF9yKHQpLCBjLmRlYnVnKFwiUm9vbSgpO1wiLCB7IHJvb21JZDogZSwgb3B0aW9uczogdCB9KSwgdGhpcy5fcm9vbUlkID0gZSwgdGhpcy5fb3B0aW9ucyA9IHQsIHRoaXMuX2NoYXRBcGkgPSBzLCB0aGlzLl9sb2dnZXIgPSBjLCB0aGlzLl9zdGF0dXMgPSBuZXcgZHIoYyk7XG4gICAgY29uc3QgZyA9IGF0KFJyKHUpKSwgZiA9IGcucHJvbWlzZTtcbiAgICB0aGlzLl9maW5hbGl6ZXIgPSAoKSA9PiAoZy5yZWplY3QoXG4gICAgICBuZXcgaC5FcnJvckluZm8oXCJSb29tIHJlbGVhc2VkIGJlZm9yZSBpbml0aWFsaXphdGlvbiBzdGFydGVkXCIsIG0uUm9vbUlzUmVsZWFzZWQsIDQwMClcbiAgICApICYmIHRoaXMuX3N0YXR1cy5zZXRTdGF0dXMoeyBzdGF0dXM6IGQuUmVsZWFzZWQgfSksIHUpLCB0aGlzLl9tZXNzYWdlcyA9IG5ldyBycihcbiAgICAgIGUsXG4gICAgICByLFxuICAgICAgdGhpcy5fY2hhdEFwaSxcbiAgICAgIHIuYXV0aC5jbGllbnRJZCxcbiAgICAgIGMsXG4gICAgICBmXG4gICAgKTtcbiAgICBjb25zdCB5ID0gW3RoaXMuX21lc3NhZ2VzXTtcbiAgICB0LnByZXNlbmNlICYmICh0aGlzLl9sb2dnZXIuZGVidWcoXCJlbmFibGluZyBwcmVzZW5jZSBvbiByb29tXCIsIHsgcm9vbUlkOiBlIH0pLCB0aGlzLl9wcmVzZW5jZSA9IG5ldyBzcihcbiAgICAgIGUsXG4gICAgICB0LFxuICAgICAgcixcbiAgICAgIHIuYXV0aC5jbGllbnRJZCxcbiAgICAgIGMsXG4gICAgICBmXG4gICAgKSwgeS5wdXNoKHRoaXMuX3ByZXNlbmNlKSksIHQudHlwaW5nICYmICh0aGlzLl9sb2dnZXIuZGVidWcoXCJlbmFibGluZyB0eXBpbmcgb24gcm9vbVwiLCB7IHJvb21JZDogZSB9KSwgdGhpcy5fdHlwaW5nID0gbmV3IHZyKFxuICAgICAgZSxcbiAgICAgIHQudHlwaW5nLFxuICAgICAgcixcbiAgICAgIHIuYXV0aC5jbGllbnRJZCxcbiAgICAgIGMsXG4gICAgICBmXG4gICAgKSwgeS5wdXNoKHRoaXMuX3R5cGluZykpLCB0LnJlYWN0aW9ucyAmJiAodGhpcy5fbG9nZ2VyLmRlYnVnKFwiZW5hYmxpbmcgcmVhY3Rpb25zIG9uIHJvb21cIiwgeyByb29tSWQ6IGUgfSksIHRoaXMuX3JlYWN0aW9ucyA9IG5ldyBwcihlLCByLCByLmF1dGguY2xpZW50SWQsIGMsIGYpLCB5LnB1c2godGhpcy5fcmVhY3Rpb25zKSksIHQub2NjdXBhbmN5ICYmICh0aGlzLl9sb2dnZXIuZGVidWcoXCJlbmFibGluZyBvY2N1cGFuY3kgb24gcm9vbVwiLCB7IHJvb21JZDogZSB9KSwgdGhpcy5fb2NjdXBhbmN5ID0gbmV3IGlyKGUsIHIsIHRoaXMuX2NoYXRBcGksIGMsIGYpLCB5LnB1c2godGhpcy5fb2NjdXBhbmN5KSksIHRoaXMuX2FzeW5jT3BzQWZ0ZXIgPSB0aGlzLl9zZXR1cEFzeW5jUm9vbUluaXQoeSwgZiwgciksIHRoaXMuX2FzeW5jT3BzQWZ0ZXIuY2F0Y2goKHApID0+IHtcbiAgICAgIHRoaXMuX2xvZ2dlci5kZWJ1ZyhcIlJvb20gaW5pdGlhbGl6YXRpb24gd2FzIHByZXZlbnRlZCBiZWZvcmUgZmluaXNoaW5nXCIsIHsgZXJyb3I6IHAsIHJvb21JZDogZSB9KTtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogUnVucyBhc3luYyByb29tIGluaXRpYWxpemF0aW9uIGFuZCB3YWl0cyBmb3IgYWxsIGZlYXR1cmVzIHRvIGZpbmlzaCBpbml0aWFsaXppbmcuIEhhbmRsZXMgY2FsbHMgdG8gcmVsZWFzZSgpXG4gICAqIGF0IGRpZmZlcmVudCBwb2ludHMgaW4gdGhlIGluaXRpYWxpemF0aW9uIHByb2Nlc3MuXG4gICAqXG4gICAqIEBwYXJhbSBmZWF0dXJlcyBBcnJheSBvZiBhbGwgZW5hYmxlZCByb29tIGZlYXR1cmVzIHRoYXQgYXJlIHRvIGJlIGluaXRpYWxpemVkIHdpdGggY2hhbm5lbHMuXG4gICAqIEBwYXJhbSBpbml0RmVhdHVyZXNBZnRlciBJbml0aWFsaXphdGlvbiBvZiBmZWF0dXJlcyBzdGFydHMgYWZ0ZXIgdGhpcyBwcm9taXNlIHJlc29sdmVzXG4gICAqIEBwYXJhbSByZWFsdGltZSBUaGUgQWJseS5SZWFsdGltZSBpbnN0YW5jZSB1c2VkIGJ5IHRoaXMgcm9vbVxuICAgKiBAcmV0dXJucyBBIHByb21pc2UgdGhhdCBpcyByZXNvbHZlZCB3aGVuIHRoZSByb29tIGlzIGluaXRpYWxpemVkIG9yIHJlamVjdGVkIGlmIHRoZSByb29tIGlzIHJlbGVhc2VkIGJlZm9yZSBpbml0aWFsaXphdGlvbiBmaW5pc2hlcy5cbiAgICovXG4gIF9zZXR1cEFzeW5jUm9vbUluaXQoZSwgdCwgcikge1xuICAgIGNvbnN0IHMgPSBhdChcbiAgICAgIHQudGhlbigoKSA9PiB7XG4gICAgICAgIGxldCBjO1xuICAgICAgICBjb25zdCB1ID0gbmV3IFByb21pc2UoKGYpID0+IHtcbiAgICAgICAgICBjID0gZjtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX2ZpbmFsaXplciA9ICgpID0+IChzLnJlamVjdChcbiAgICAgICAgICBuZXcgaC5FcnJvckluZm8oXCJSb29tIHJlbGVhc2VkIGJlZm9yZSBpbml0aWFsaXphdGlvbiBmaW5pc2hlZFwiLCBtLlJvb21Jc1JlbGVhc2VkLCA0MDApXG4gICAgICAgICksIHUudGhlbigoZikgPT4gZigpKSk7XG4gICAgICAgIGNvbnN0IGcgPSBlLm1hcCgoZikgPT4gZi5jaGFubmVsLnRoZW4oKHkpID0+ICh7XG4gICAgICAgICAgY2hhbm5lbDogeSxcbiAgICAgICAgICBjb250cmlidXRvcjogZlxuICAgICAgICB9KSkpO1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwoZykudGhlbigoZikgPT4ge1xuICAgICAgICAgIGNvbnN0IHkgPSBuZXcgZ3IodGhpcy5fc3RhdHVzLCBmLnRvUmV2ZXJzZWQoKSwgdGhpcy5fbG9nZ2VyLCA1ZTMpO1xuICAgICAgICAgIHRoaXMuX2xpZmVjeWNsZU1hbmFnZXIgPSB5O1xuICAgICAgICAgIGxldCBwID0gITE7XG4gICAgICAgICAgYygoKSA9PiBwID8gUHJvbWlzZS5yZXNvbHZlKCkgOiAocCA9ICEwLCB5LnJlbGVhc2UoKS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgUiBvZiBmKVxuICAgICAgICAgICAgICByLmNoYW5uZWxzLnJlbGVhc2UoUi5jaGFubmVsLm5hbWUpO1xuICAgICAgICAgIH0pKSksIHRoaXMuX3N0YXR1cy5zZXRTdGF0dXMoeyBzdGF0dXM6IGQuSW5pdGlhbGl6ZWQgfSk7XG4gICAgICAgIH0pLmNhdGNoKChmKSA9PiB7XG4gICAgICAgICAgdGhyb3cgYygoKSA9PiBQcm9taXNlLnJlc29sdmUoKSksIHRoaXMuX2xvZ2dlci5lcnJvcihcIlJvb20gZmVhdHVyZXMgaW5pdGlhbGl6YXRpb24gZmFpbGVkXCIsIHsgZXJyb3I6IGYsIHJvb21JZDogdGhpcy5yb29tSWQgfSksIHRoaXMuX3N0YXR1cy5zZXRTdGF0dXMoe1xuICAgICAgICAgICAgc3RhdHVzOiBkLkZhaWxlZCxcbiAgICAgICAgICAgIGVycm9yOiBuZXcgaC5FcnJvckluZm8oXCJSb29tIGZlYXR1cmVzIGluaXRpYWxpemF0aW9uIGZhaWxlZC5cIiwgNGU0LCA0MDAsIGYpXG4gICAgICAgICAgfSksIGY7XG4gICAgICAgIH0pO1xuICAgICAgfSlcbiAgICApO1xuICAgIHJldHVybiBzLnByb21pc2U7XG4gIH1cbiAgLyoqXG4gICAqIEBpbmhlcml0ZG9jIFJvb21cbiAgICovXG4gIGdldCByb29tSWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Jvb21JZDtcbiAgfVxuICAvKipcbiAgICogQGluaGVyaXREb2MgUm9vbVxuICAgKi9cbiAgb3B0aW9ucygpIHtcbiAgICByZXR1cm4gWm4odGhpcy5fb3B0aW9ucyk7XG4gIH1cbiAgLyoqXG4gICAqIEBpbmhlcml0ZG9jIFJvb21cbiAgICovXG4gIGdldCBtZXNzYWdlcygpIHtcbiAgICByZXR1cm4gdGhpcy5fbWVzc2FnZXM7XG4gIH1cbiAgLyoqXG4gICAqIEBpbmhlcml0ZG9jIFJvb21cbiAgICovXG4gIGdldCBwcmVzZW5jZSgpIHtcbiAgICBpZiAoIXRoaXMuX3ByZXNlbmNlKVxuICAgICAgdGhyb3cgdGhpcy5fbG9nZ2VyLmVycm9yKFwiUHJlc2VuY2UgaXMgbm90IGVuYWJsZWQgZm9yIHRoaXMgcm9vbVwiKSwgbmV3IGguRXJyb3JJbmZvKFwiUHJlc2VuY2UgaXMgbm90IGVuYWJsZWQgZm9yIHRoaXMgcm9vbVwiLCA0ZTQsIDQwMCk7XG4gICAgcmV0dXJuIHRoaXMuX3ByZXNlbmNlO1xuICB9XG4gIC8qKlxuICAgKiBAaW5oZXJpdGRvYyBSb29tXG4gICAqL1xuICBnZXQgcmVhY3Rpb25zKCkge1xuICAgIGlmICghdGhpcy5fcmVhY3Rpb25zKVxuICAgICAgdGhyb3cgdGhpcy5fbG9nZ2VyLmVycm9yKFwiUmVhY3Rpb25zIGFyZSBub3QgZW5hYmxlZCBmb3IgdGhpcyByb29tXCIpLCBuZXcgaC5FcnJvckluZm8oXCJSZWFjdGlvbnMgYXJlIG5vdCBlbmFibGVkIGZvciB0aGlzIHJvb21cIiwgNGU0LCA0MDApO1xuICAgIHJldHVybiB0aGlzLl9yZWFjdGlvbnM7XG4gIH1cbiAgLyoqXG4gICAqIEBpbmhlcml0ZG9jIFJvb21cbiAgICovXG4gIGdldCB0eXBpbmcoKSB7XG4gICAgaWYgKCF0aGlzLl90eXBpbmcpXG4gICAgICB0aHJvdyB0aGlzLl9sb2dnZXIuZXJyb3IoXCJUeXBpbmcgaXMgbm90IGVuYWJsZWQgZm9yIHRoaXMgcm9vbVwiKSwgbmV3IGguRXJyb3JJbmZvKFwiVHlwaW5nIGlzIG5vdCBlbmFibGVkIGZvciB0aGlzIHJvb21cIiwgNGU0LCA0MDApO1xuICAgIHJldHVybiB0aGlzLl90eXBpbmc7XG4gIH1cbiAgLyoqXG4gICAqIEBpbmhlcml0ZG9jIFJvb21cbiAgICovXG4gIGdldCBvY2N1cGFuY3koKSB7XG4gICAgaWYgKCF0aGlzLl9vY2N1cGFuY3kpXG4gICAgICB0aHJvdyB0aGlzLl9sb2dnZXIuZXJyb3IoXCJPY2N1cGFuY3kgaXMgbm90IGVuYWJsZWQgZm9yIHRoaXMgcm9vbVwiKSwgbmV3IGguRXJyb3JJbmZvKFwiT2NjdXBhbmN5IGlzIG5vdCBlbmFibGVkIGZvciB0aGlzIHJvb21cIiwgNGU0LCA0MDApO1xuICAgIHJldHVybiB0aGlzLl9vY2N1cGFuY3k7XG4gIH1cbiAgLyoqXG4gICAqIEBpbmhlcml0ZG9jIFJvb21cbiAgICovXG4gIGdldCBzdGF0dXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3N0YXR1cztcbiAgfVxuICAvKipcbiAgICogQGluaGVyaXRkb2MgUm9vbVxuICAgKi9cbiAgYXN5bmMgYXR0YWNoKCkge1xuICAgIHJldHVybiB0aGlzLl9sb2dnZXIudHJhY2UoXCJSb29tLmF0dGFjaCgpO1wiKSwgdGhpcy5fYXN5bmNPcHNBZnRlci50aGVuKCgpID0+IHtcbiAgICAgIHZhciBlO1xuICAgICAgcmV0dXJuIChlID0gdGhpcy5fbGlmZWN5Y2xlTWFuYWdlcikgPT0gbnVsbCA/IHZvaWQgMCA6IGUuYXR0YWNoKCk7XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIEBpbmhlcml0ZG9jIFJvb21cbiAgICovXG4gIGFzeW5jIGRldGFjaCgpIHtcbiAgICByZXR1cm4gdGhpcy5fbG9nZ2VyLnRyYWNlKFwiUm9vbS5kZXRhY2goKTtcIiksIHRoaXMuX2FzeW5jT3BzQWZ0ZXIudGhlbigoKSA9PiB7XG4gICAgICB2YXIgZTtcbiAgICAgIHJldHVybiAoZSA9IHRoaXMuX2xpZmVjeWNsZU1hbmFnZXIpID09IG51bGwgPyB2b2lkIDAgOiBlLmRldGFjaCgpO1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBSZWxlYXNlcyByZXNvdXJjZXMgYXNzb2NpYXRlZCB3aXRoIHRoZSByb29tLlxuICAgKiBXZSBndWFyYW50ZWUgdGhhdCB0aGlzIGRvZXMgbm90IHRocm93IGFuIGVycm9yLlxuICAgKi9cbiAgcmVsZWFzZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fbG9nZ2VyLnRyYWNlKFwiUm9vbS5yZWxlYXNlKCk7XCIpLCB0aGlzLl9maW5hbGl6ZXIoKTtcbiAgfVxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqXG4gICAqIFJldHVybnMgYSBwcm9taXNlIHRoYXQgaXMgcmVzb2x2ZWQgd2hlbiB0aGUgcm9vbSBpcyBpbml0aWFsaXplZCBvclxuICAgKiByZWplY3RlZCBpZiB0aGUgcm9vbSBnZXRzIHJlbGVhc2VkIGJlZm9yZSBpbml0aWFsaXphdGlvbi5cbiAgICovXG4gIGluaXRpYWxpemF0aW9uU3RhdHVzKCkge1xuICAgIHJldHVybiB0aGlzLl9hc3luY09wc0FmdGVyO1xuICB9XG59XG5jbGFzcyBFciB7XG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RzIGEgbmV3IFJvb21zIGluc3RhbmNlLlxuICAgKlxuICAgKiBAcGFyYW0gcmVhbHRpbWUgQW4gaW5zdGFuY2Ugb2YgdGhlIEFibHkgUmVhbHRpbWUgY2xpZW50LlxuICAgKiBAcGFyYW0gY2xpZW50T3B0aW9ucyBUaGUgY2xpZW50IG9wdGlvbnMgZnJvbSB0aGUgY2hhdCBpbnN0YW5jZS5cbiAgICogQHBhcmFtIGxvZ2dlciBBbiBpbnN0YW5jZSBvZiB0aGUgTG9nZ2VyLlxuICAgKi9cbiAgY29uc3RydWN0b3IoZSwgdCwgcikge1xuICAgIHRoaXMuX3Jvb21zID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKSwgdGhpcy5fcmVsZWFzaW5nID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKSwgdGhpcy5fcmVhbHRpbWUgPSBlLCB0aGlzLl9jaGF0QXBpID0gbmV3IFhuKGUsIHIpLCB0aGlzLl9jbGllbnRPcHRpb25zID0gdCwgdGhpcy5fbG9nZ2VyID0gcjtcbiAgfVxuICAvKipcbiAgICogQGluaGVyaXREb2NcbiAgICovXG4gIGdldChlLCB0KSB7XG4gICAgdGhpcy5fbG9nZ2VyLnRyYWNlKFwiUm9vbXMuZ2V0KCk7XCIsIHsgcm9vbUlkOiBlIH0pO1xuICAgIGNvbnN0IHIgPSB0aGlzLl9yb29tcy5nZXQoZSk7XG4gICAgaWYgKHIpIHtcbiAgICAgIGlmICghaihyLm9wdGlvbnMoKSwgdCkpXG4gICAgICAgIHRocm93IG5ldyBoLkVycm9ySW5mbyhcIlJvb20gYWxyZWFkeSBleGlzdHMgd2l0aCBkaWZmZXJlbnQgb3B0aW9uc1wiLCA0ZTQsIDQwMCk7XG4gICAgICByZXR1cm4gcjtcbiAgICB9XG4gICAgY29uc3QgcyA9IHRoaXMuX3JlbGVhc2luZy5nZXQoZSksIGMgPSBzID8gcy5wcm9taXNlIDogUHJvbWlzZS5yZXNvbHZlKCksIHUgPSBuZXcgQXIoZSwgdCwgdGhpcy5fcmVhbHRpbWUsIHRoaXMuX2NoYXRBcGksIHRoaXMuX2xvZ2dlciwgYyk7XG4gICAgcmV0dXJuIHRoaXMuX3Jvb21zLnNldChlLCB1KSwgdTtcbiAgfVxuICAvKipcbiAgICogQGluaGVyaXREb2NcbiAgICovXG4gIGdldCBjbGllbnRPcHRpb25zKCkge1xuICAgIHJldHVybiB0aGlzLl9jbGllbnRPcHRpb25zO1xuICB9XG4gIC8qKlxuICAgKiBAaW5oZXJpdERvY1xuICAgKi9cbiAgcmVsZWFzZShlKSB7XG4gICAgdGhpcy5fbG9nZ2VyLnRyYWNlKFwiUm9vbXMucmVsZWFzZSgpO1wiLCB7IHJvb21JZDogZSB9KTtcbiAgICBjb25zdCB0ID0gdGhpcy5fcm9vbXMuZ2V0KGUpLCByID0gdGhpcy5fcmVsZWFzaW5nLmdldChlKTtcbiAgICBpZiAoIXQpXG4gICAgICByZXR1cm4gciA/IHIucHJvbWlzZSA6IFByb21pc2UucmVzb2x2ZSgpO1xuICAgIHRoaXMuX3Jvb21zLmRlbGV0ZShlKTtcbiAgICBsZXQgcyA9IDA7XG4gICAgciAmJiAocyA9IHIuY291bnQgKyAxKTtcbiAgICBjb25zdCBjID0gdC5yZWxlYXNlKCkudGhlbigoKSA9PiB7XG4gICAgICB0aGlzLl9sb2dnZXIuZGVidWcoXCJSb29tcy5yZWxlYXNlKCk7IHJvb20gcmVsZWFzZWRcIiwgeyByb29tSWQ6IGUgfSk7XG4gICAgICBjb25zdCB1ID0gdGhpcy5fcmVsZWFzaW5nLmdldChlKTtcbiAgICAgIHUgJiYgdS5jb3VudCA8IHMgJiYgdGhpcy5fcmVsZWFzaW5nLmRlbGV0ZShlKTtcbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcy5fcmVsZWFzaW5nLnNldChlLCB7IGNvdW50OiBzLCBwcm9taXNlOiBjIH0pLCBjO1xuICB9XG59XG5jbGFzcyBQciB7XG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RvciBmb3IgQ2hhdFxuICAgKiBAcGFyYW0gcmVhbHRpbWUgLSBUaGUgQWJseSBSZWFsdGltZSBjbGllbnQuXG4gICAqIEBwYXJhbSBjbGllbnRPcHRpb25zIC0gVGhlIGNsaWVudCBvcHRpb25zLlxuICAgKi9cbiAgY29uc3RydWN0b3IoZSwgdCkge1xuICAgIHRoaXMuX3JlYWx0aW1lID0gZSwgdGhpcy5fY2xpZW50T3B0aW9ucyA9IEJuKHQpLCB0aGlzLl9sb2dnZXIgPSAkbih0aGlzLl9jbGllbnRPcHRpb25zKSwgdGhpcy5fY29ubmVjdGlvbiA9IG5ldyBHbihuZXcgUW4oZSwgdGhpcy5fbG9nZ2VyKSksIHRoaXMuX3Jvb21zID0gbmV3IEVyKGUsIHRoaXMuX2NsaWVudE9wdGlvbnMsIHRoaXMuX2xvZ2dlciksIHRoaXMuX2FkZEFnZW50KFwiY2hhdC1qc1wiKSwgdGhpcy5fbG9nZ2VyLnRyYWNlKGBhYmx5IGNoYXQgY2xpZW50IHZlcnNpb24gJHtnZX07IGluaXRpYWxpemVkYCk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHJvb21zIG9iamVjdCwgd2hpY2ggcHJvdmlkZXMgYWNjZXNzIHRvIGNoYXQgcm9vbXMuXG4gICAqXG4gICAqIEByZXR1cm5zIFRoZSByb29tcyBvYmplY3QuXG4gICAqL1xuICBnZXQgcm9vbXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Jvb21zO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSB1bmRlcmx5aW5nIGNvbm5lY3Rpb24gdG8gQWJseSwgd2hpY2ggY2FuIGJlIHVzZWQgdG8gbW9uaXRvciB0aGUgY2xpZW50c1xuICAgKiBjb25uZWN0aW9uIHRvIEFibHkgc2VydmVycy5cbiAgICpcbiAgICogQHJldHVybnMgVGhlIGNvbm5lY3Rpb24gb2JqZWN0LlxuICAgKi9cbiAgZ2V0IGNvbm5lY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX2Nvbm5lY3Rpb247XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGNsaWVudElkIG9mIHRoZSBjdXJyZW50IGNsaWVudC5cbiAgICpcbiAgICogQHJldHVybnMgVGhlIGNsaWVudElkLlxuICAgKi9cbiAgZ2V0IGNsaWVudElkKCkge1xuICAgIHJldHVybiB0aGlzLl9yZWFsdGltZS5hdXRoLmNsaWVudElkO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSB1bmRlcmx5aW5nIEFibHkgUmVhbHRpbWUgY2xpZW50LlxuICAgKiBAcmV0dXJucyBUaGUgQWJseSBSZWFsdGltZSBjbGllbnQuXG4gICAqL1xuICBnZXQgcmVhbHRpbWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3JlYWx0aW1lO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSByZXNvbHZlZCBjbGllbnQgb3B0aW9ucyBmb3IgdGhlIGNsaWVudCwgaW5jbHVkaW5nIGFueSBkZWZhdWx0cyB0aGF0IGhhdmUgYmVlbiBzZXQuXG4gICAqIEByZXR1cm5zIFRoZSBjbGllbnQgb3B0aW9ucy5cbiAgICovXG4gIGdldCBjbGllbnRPcHRpb25zKCkge1xuICAgIHJldHVybiB0aGlzLl9jbGllbnRPcHRpb25zO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBsb2dnZXIgaW5zdGFuY2UgZm9yIHRoZSBjbGllbnQuXG4gICAqIEBpbnRlcm5hbFxuICAgKiBAcmV0dXJucyBUaGUgbG9nZ2VyIGluc3RhbmNlLlxuICAgKi9cbiAgZ2V0IGxvZ2dlcigpIHtcbiAgICByZXR1cm4gdGhpcy5fbG9nZ2VyO1xuICB9XG4gIC8qKlxuICAgKiBBZGRzIGFkZGl0aW9uYWwgYWdlbnQgaW5mb3JtYXRpb24gdG8gdGhlIGNsaWVudC5cbiAgICogVXNlZCBpbnRlcm5hbGx5IHRvIGFkZCBSZWFjdC1zcGVjaWZpYyBhZ2VudCBpbmZvcm1hdGlvbi5cbiAgICogQHBhcmFtIGFnZW50IC0gVGhlIGFnZW50IHRvIGFkZC5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBhZGRSZWFjdEFnZW50KCkge1xuICAgIHRoaXMuX2FkZEFnZW50KFwiY2hhdC1yZWFjdFwiKTtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgYWdlbnQgc3RyaW5nIGZvciB0aGUgY2xpZW50LlxuICAgKiBAcGFyYW0gYWdlbnQgLSBUaGUgYWdlbnQgdG8gYWRkLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIF9hZGRBZ2VudChlKSB7XG4gICAgY29uc3QgdCA9IHRoaXMuX3JlYWx0aW1lO1xuICAgIHQub3B0aW9ucy5hZ2VudHMgPSB7IC4uLnQub3B0aW9ucy5hZ2VudHMgPz8gdC5vcHRpb25zLmFnZW50cywgW2VdOiBnZSB9O1xuICB9XG59XG52YXIgSXIgPSAvKiBAX19QVVJFX18gKi8gKChpKSA9PiAoaS5DaGF0TWVzc2FnZSA9IFwiY2hhdE1lc3NhZ2VcIiwgaS5SZWFjdGlvbiA9IFwicmVhY3Rpb25cIiwgaSkpKElyIHx8IHt9KTtcbmZ1bmN0aW9uIHBlKGkpIHtcbiAgaWYgKHR5cGVvZiBpICE9IFwib2JqZWN0XCIgfHwgaSA9PT0gbnVsbClcbiAgICB0aHJvdyBuZXcgaC5FcnJvckluZm8oXCJpbnZhbGlkIGVuY29kZWQgdHlwZTsgZW5jb2RlZCBpcyBub3QgdHlwZSBvYmplY3Qgb3IgaXMgbnVsbFwiLCA0ZTQsIDQwMCk7XG4gIGlmICghKFwibmFtZVwiIGluIGkpIHx8IHR5cGVvZiBpLm5hbWUgIT0gXCJzdHJpbmdcIilcbiAgICB0aHJvdyBuZXcgaC5FcnJvckluZm8oXCJpbnZhbGlkIGVuY29kZWQgaW5ib3VuZCBtZXNzYWdlOyBtZXNzYWdlIGRvZXMgbm90IGhhdmUgYSB2YWxpZCBuYW1lIGZpZWxkXCIsIDRlNCwgNDAwKTtcbn1cbmZ1bmN0aW9uIHhyKGkpIHtcbiAgcmV0dXJuIHBlKGkpLCBTcihpKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIE9yKGkpIHtcbiAgcGUoaSk7XG4gIGNvbnN0IGUgPSBhd2FpdCBoLlJlYWx0aW1lLk1lc3NhZ2UuZnJvbUVuY29kZWQoaSk7XG4gIHJldHVybiBNcihlKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIEZyKGkpIHtcbiAgcGUoaSk7XG4gIGNvbnN0IGUgPSBhd2FpdCBoLlJlYWx0aW1lLk1lc3NhZ2UuZnJvbUVuY29kZWQoaSk7XG4gIHJldHVybiBUcihlKTtcbn1cbmZ1bmN0aW9uIFNyKGkpIHtcbiAgc3dpdGNoIChpLm5hbWUpIHtcbiAgICBjYXNlIEwuQ3JlYXRlZDpcbiAgICAgIHJldHVybiBcImNoYXRNZXNzYWdlXCI7XG4gICAgY2FzZSB6LlJlYWN0aW9uOlxuICAgICAgcmV0dXJuIFwicmVhY3Rpb25cIjtcbiAgICBjYXNlIHZvaWQgMDpcbiAgICAgIHRocm93IG5ldyBoLkVycm9ySW5mbyhcInJlY2VpdmVkIGluY29taW5nIG1lc3NhZ2Ugd2l0aG91dCBldmVudCBuYW1lXCIsIDRlNCwgNDAwKTtcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IGguRXJyb3JJbmZvKGB1bmtub3duIG1lc3NhZ2UgdHlwZTogJHtpLm5hbWV9YCwgNGU0LCA0MDApO1xuICB9XG59XG5mdW5jdGlvbiBUcihpKSB7XG4gIHJldHVybiBndChpKTtcbn1cbmZ1bmN0aW9uIE1yKGkpIHtcbiAgY29uc3QgZSA9IGkuaWQuc3BsaXQoXCI6XCIpWzJdO1xuICByZXR1cm4gaHQoZSwgaSk7XG59XG5leHBvcnQge1xuICBQciBhcyBDaGF0Q2xpZW50LFxuICBJciBhcyBDaGF0RW50aXR5VHlwZSxcbiAgS24gYXMgQ29ubmVjdGlvbkxpZmVjeWNsZSxcbiAgbSBhcyBFcnJvckNvZGVzLFxuICBvdCBhcyBMb2dMZXZlbCxcbiAgTCBhcyBNZXNzYWdlRXZlbnRzLFxuICBuciBhcyBQcmVzZW5jZUV2ZW50cyxcbiAgZCBhcyBSb29tTGlmZWN5Y2xlLFxuICBDciBhcyBSb29tT3B0aW9uc0RlZmF1bHRzLFxuICBNciBhcyBjaGF0TWVzc2FnZUZyb21BYmx5TWVzc2FnZSxcbiAgT3IgYXMgY2hhdE1lc3NhZ2VGcm9tRW5jb2RlZCxcbiAgRHIgYXMgZXJyb3JJbmZvSXMsXG4gIFNyIGFzIGdldEVudGl0eVR5cGVGcm9tQWJseU1lc3NhZ2UsXG4gIHhyIGFzIGdldEVudGl0eVR5cGVGcm9tRW5jb2RlZCxcbiAgVHIgYXMgcmVhY3Rpb25Gcm9tQWJseU1lc3NhZ2UsXG4gIEZyIGFzIHJlYWN0aW9uRnJvbUVuY29kZWRcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hYmx5LWNoYXQuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../../../node_modules/@ably/chat/dist/chat/ably-chat.js\n");

/***/ }),

/***/ "(ssr)/../../../node_modules/@ably/chat/dist/react/ably-chat-react.js":
/*!**********************************************************************!*\
  !*** ../../../node_modules/@ably/chat/dist/react/ably-chat-react.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ChatClientProvider: () => (/* binding */ ue),\n/* harmony export */   ChatRoomContext: () => (/* binding */ U),\n/* harmony export */   ChatRoomProvider: () => (/* binding */ me),\n/* harmony export */   useChatClient: () => (/* binding */ V),\n/* harmony export */   useChatConnection: () => (/* binding */ M),\n/* harmony export */   useMessages: () => (/* binding */ ie),\n/* harmony export */   useOccupancy: () => (/* binding */ de),\n/* harmony export */   usePresence: () => (/* binding */ ge),\n/* harmony export */   usePresenceListener: () => (/* binding */ le),\n/* harmony export */   useRoom: () => (/* binding */ x),\n/* harmony export */   useRoomReactions: () => (/* binding */ Ie),\n/* harmony export */   useTyping: () => (/* binding */ fe)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/../../../node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var ably__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ably */ \"(ssr)/../../../node_modules/ably/build/ably-node.js\");\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react/jsx-runtime */ \"(ssr)/../../../node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react-jsx-runtime.js\");\n/* harmony import */ var _ably_chat__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @ably/chat */ \"(ssr)/../../../node_modules/@ably/chat/dist/chat/ably-chat.js\");\n\n\n\n\n\nconst U = (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)(void 0), k = Symbol.for(\"__ABLY_CHAT_CLIENT_CONTEXT__\"), B = typeof globalThis > \"u\" ? {} : globalThis;\nfunction ee() {\n  let t = B[k];\n  return t || (t = B[k] = react__WEBPACK_IMPORTED_MODULE_0__.createContext({})), t;\n}\nconst O = ee(), q = \"default\", ue = ({ children: t, client: n }) => {\n  const u = react__WEBPACK_IMPORTED_MODULE_0__.useContext(O), e = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => (n.addReactAgent(), { ...u, [q]: { client: n } }), [n, u]);\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(O.Provider, { value: e, children: t });\n}, V = () => {\n  const t = react__WEBPACK_IMPORTED_MODULE_0__.useContext(O)[q];\n  if (!t)\n    throw new ably__WEBPACK_IMPORTED_MODULE_1__.ErrorInfo(\"useChatClient hook must be used within a chat client provider\", 4e4, 400);\n  return t.client;\n}, h = (t) => {\n  const n = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(t);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    n.current = t;\n  });\n  const u = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((...e) => {\n    n.current && n.current(...e);\n  }, []);\n  return t ? u : void 0;\n}, M = (t) => {\n  const n = V();\n  n.logger.trace(\"useChatConnection();\", t);\n  const [u, e] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(n.connection.status.current), [m, r] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(n.connection.status.error), [o, d] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(n.connection);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    d(n.connection), r(n.connection.status.error), e(n.connection.status.current);\n  }, [n]);\n  const i = h(t == null ? void 0 : t.onStatusChange);\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    n.logger.debug(\"useChatConnection(); applying internal listener\");\n    const { off: c } = n.connection.status.onChange((s) => {\n      e(s.current), r(s.error);\n    });\n    return () => {\n      n.logger.debug(\"useChatConnection(); cleaning up listener\"), c();\n    };\n  }, [n.connection.status, n.logger]), (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    if (!i) return;\n    n.logger.debug(\"useChatConnection(); applying client listener\");\n    const { off: c } = n.connection.status.onChange(i);\n    return () => {\n      n.logger.debug(\"useChatConnection(); cleaning up client listener\"), c();\n    };\n  }, [n.connection.status, n.logger, i]), {\n    currentStatus: u,\n    error: m,\n    connection: o\n  };\n}, T = () => {\n  const t = V();\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => t.logger, [t]);\n};\nfunction N(t) {\n  return {\n    status: t.current,\n    error: t.error\n  };\n}\nconst x = (t) => {\n  const n = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(U), u = T();\n  if (u.trace(\"useRoom();\", { roomId: n == null ? void 0 : n.room.roomId }), !n)\n    throw u.error(\"useRoom(); must be used within a ChatRoomProvider\"), new ably__WEBPACK_IMPORTED_MODULE_1__.ErrorInfo(\"useRoom hook must be used within a ChatRoomProvider\", 4e4, 400);\n  const { currentStatus: e, error: m } = M({\n    onStatusChange: t == null ? void 0 : t.onConnectionStatusChange\n  }), r = n.room, [o, d] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(N(r.status)), i = h(t == null ? void 0 : t.onStatusChange);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    u.debug(\"useRoom(); setting up room status listener\", { roomId: r.roomId });\n    const { off: l } = r.status.onChange((f) => {\n      d(N(f));\n    });\n    return d((f) => r.status.current !== f.status || r.status.error !== f.error ? N(r.status) : f), () => {\n      u.debug(\"useRoom(); removing room status listener\", { roomId: r.roomId }), l();\n    };\n  }, [r, u]), (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    if (!i) return;\n    u.debug(\"useRoom(); applying user-provided listener\", { roomId: r.roomId });\n    const { off: l } = r.status.onChange(i);\n    return () => {\n      u.debug(\"useRoom(); removing user-provided listener\", { roomId: r.roomId }), l();\n    };\n  }, [r, i, u]);\n  const c = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(() => r.attach(), [r]), s = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(() => r.detach(), [r]);\n  return {\n    room: r,\n    attach: c,\n    detach: s,\n    roomStatus: o.status,\n    roomError: o.error,\n    connectionStatus: e,\n    connectionError: m\n  };\n}, ie = (t) => {\n  const { currentStatus: n, error: u } = M({\n    onStatusChange: t == null ? void 0 : t.onConnectionStatusChange\n  }), { room: e, roomError: m, roomStatus: r } = x({\n    onStatusChange: t == null ? void 0 : t.onRoomStatusChange\n  }), o = T();\n  o.trace(\"useMessages();\", { params: t, roomId: e.roomId });\n  const d = h(t == null ? void 0 : t.listener), i = h(t == null ? void 0 : t.onDiscontinuity), c = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((b) => e.messages.send(b), [e]), s = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((b) => e.messages.get(b), [e]), [l, f] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)();\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    if (!d) return;\n    o.debug(\"useMessages(); applying listener\", { roomId: e.roomId });\n    let b = !1;\n    const S = e.messages.subscribe(d);\n    return f(() => (o.debug(\"useMessages(); setting getPreviousMessages state\", { roomId: e.roomId }), (C) => b ? (o.debug(\"useMessages(); getPreviousMessages called after unmount\", { roomId: e.roomId }), Promise.resolve({\n      items: [],\n      hasNext: () => !1,\n      isLast: () => !0,\n      next: () => {\n      },\n      previous: () => {\n      },\n      current: () => {\n      },\n      first: () => {\n      }\n    })) : S.getPreviousMessages(C))), () => {\n      o.debug(\"useMessages(); removing listener and getPreviousMessages state\", { roomId: e.roomId }), b = !0, S.unsubscribe(), f(void 0);\n    };\n  }, [e, o, d]), (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    if (!i) return;\n    o.debug(\"useMessages(); applying onDiscontinuity listener\", { roomId: e.roomId });\n    const { off: b } = e.messages.onDiscontinuity(i);\n    return () => {\n      o.debug(\"useMessages(); removing onDiscontinuity listener\", { roomId: e.roomId }), b();\n    };\n  }, [e, o, i]), {\n    send: c,\n    get: s,\n    messages: e.messages,\n    getPreviousMessages: l,\n    connectionStatus: n,\n    connectionError: u,\n    roomStatus: r,\n    roomError: m\n  };\n}, de = (t) => {\n  const { currentStatus: n, error: u } = M({\n    onStatusChange: t == null ? void 0 : t.onConnectionStatusChange\n  }), { room: e, roomError: m, roomStatus: r } = x({\n    onStatusChange: t == null ? void 0 : t.onRoomStatusChange\n  }), o = T();\n  o.trace(\"useOccupancy();\", { params: t, roomId: e.roomId });\n  const [d, i] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)({\n    connections: 0,\n    presenceMembers: 0\n  }), c = h(t == null ? void 0 : t.listener), s = h(t == null ? void 0 : t.onDiscontinuity);\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    if (!s) return;\n    o.debug(\"useOccupancy(); applying onDiscontinuity listener\", { roomId: e.roomId });\n    const { off: l } = e.occupancy.onDiscontinuity(s);\n    return () => {\n      o.debug(\"useOccupancy(); removing onDiscontinuity listener\", { roomId: e.roomId }), l();\n    };\n  }, [e, s, o]), (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    o.debug(\"useOccupancy(); applying internal listener\", { roomId: e.roomId });\n    const { unsubscribe: l } = e.occupancy.subscribe((f) => {\n      i({\n        connections: f.connections,\n        presenceMembers: f.presenceMembers\n      });\n    });\n    return () => {\n      o.debug(\"useOccupancy(); cleaning up internal listener\", { roomId: e.roomId }), l();\n    };\n  }, [e, o]), (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    if (!c) return;\n    o.debug(\"useOccupancy(); applying listener\", { roomId: e.roomId });\n    const { unsubscribe: l } = e.occupancy.subscribe(c);\n    return () => {\n      o.debug(\"useOccupancy(); cleaning up listener\", { roomId: e.roomId }), l();\n    };\n  }, [c, e, o]), {\n    connectionStatus: n,\n    connectionError: u,\n    roomStatus: r,\n    roomError: m,\n    occupancy: e.occupancy,\n    connections: d.connections,\n    presenceMembers: d.presenceMembers\n  };\n}, H = /* @__PURE__ */ new Set([\n  _ably_chat__WEBPACK_IMPORTED_MODULE_3__.ConnectionLifecycle.Suspended,\n  _ably_chat__WEBPACK_IMPORTED_MODULE_3__.ConnectionLifecycle.Failed\n]), ge = (t) => {\n  const { currentStatus: n, error: u } = M({\n    onStatusChange: t == null ? void 0 : t.onConnectionStatusChange\n  }), { room: e, roomError: m, roomStatus: r } = x({\n    onStatusChange: t == null ? void 0 : t.onRoomStatusChange\n  }), o = T();\n  o.trace(\"usePresence();\", { params: t, roomId: e.roomId });\n  const [d, i] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(!1), [c, s] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(), l = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)({ roomStatus: r, connectionStatus: n }), f = h(t == null ? void 0 : t.onDiscontinuity), b = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(t);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    b.current = t;\n  }, [t]), (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    l.current = { roomStatus: r, connectionStatus: n };\n  }, [r, n]), (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    var D;\n    const C = r === _ably_chat__WEBPACK_IMPORTED_MODULE_3__.RoomLifecycle.Attached && !H.has(n), L = l.current.roomStatus === _ably_chat__WEBPACK_IMPORTED_MODULE_3__.RoomLifecycle.Attached && !H.has(l.current.connectionStatus);\n    if (C)\n      return e.presence.enter((D = b.current) == null ? void 0 : D.enterWithData).then(() => {\n        o.debug(\"usePresence(); entered room\", { roomId: e.roomId }), i(!0), s(void 0);\n      }).catch((I) => {\n        o.error(\"usePresence(); error entering room\", { error: I, roomId: e.roomId }), s(I);\n      }), () => {\n        var I;\n        L && e.presence.leave((I = b.current) == null ? void 0 : I.leaveWithData).then(() => {\n          o.debug(\"usePresence(); left room\", { roomId: e.roomId }), i(!1), s(void 0);\n        }).catch((v) => {\n          o.error(\"usePresence(); error leaving room\", { error: v, roomId: e.roomId }), s(v);\n        });\n      };\n  }, [e, n, r, o]), (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    if (!f) return;\n    o.debug(\"usePresence(); applying onDiscontinuity listener\", { roomId: e.roomId });\n    const { off: C } = e.presence.onDiscontinuity(f);\n    return () => {\n      o.debug(\"usePresence(); removing onDiscontinuity listener\", { roomId: e.roomId }), C();\n    };\n  }, [e, f, o]);\n  const S = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n    (C) => e.presence.update(C).then(() => {\n      i(!0), s(void 0);\n    }),\n    [e]\n  );\n  return {\n    connectionStatus: n,\n    connectionError: u,\n    roomStatus: r,\n    roomError: m,\n    update: S,\n    isPresent: d,\n    error: c,\n    presence: e.presence\n  };\n}, te = 1500, oe = 3e4, ne = 5, le = (t) => {\n  const { currentStatus: n, error: u } = M({\n    onStatusChange: t == null ? void 0 : t.onConnectionStatusChange\n  }), { room: e, roomError: m, roomStatus: r } = x({\n    onStatusChange: t == null ? void 0 : t.onRoomStatusChange\n  }), o = T();\n  o.trace(\"usePresenceListener();\", { roomId: e.roomId });\n  const d = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(0), i = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(0), c = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(), s = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(0), l = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)([]), [f, b] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]), S = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(), [C, L] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(), D = h(t == null ? void 0 : t.listener), I = h(t == null ? void 0 : t.onDiscontinuity), v = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n    (E) => {\n      o.debug(\"usePresenceListener(); setting error state\", { error: E, roomId: e.roomId }), S.current = E, L(E);\n    },\n    [o, e.roomId]\n  ), w = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(() => {\n    o.debug(\"usePresenceListener(); clearing error state\", { roomId: e.roomId }), S.current = void 0, L(void 0);\n  }, [o, e.roomId]);\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    const E = () => {\n      d.current += 1, c.current && (clearTimeout(c.current), c.current = void 0, s.current = 0), G(d.current);\n    }, G = (R) => {\n      e.presence.get({ waitForSync: !0 }).then((_) => {\n        o.debug(\"usePresenceListener(); fetched presence data\", { presenceMembers: _, roomId: e.roomId }), c.current && (clearTimeout(c.current), c.current = void 0, s.current = 0), !(i.current >= R) && (i.current = R, l.current = _, b(_), S.current && w());\n      }).catch(() => {\n        if (!(s.current < ne)) {\n          o.error(\"usePresenceListener(); failed to fetch presence data after max retries\", {\n            roomId: e.roomId\n          }), v(new ably__WEBPACK_IMPORTED_MODULE_1__.ErrorInfo(\"failed to fetch presence data after max retries\", 5e4, 500));\n          return;\n        }\n        if (c.current) {\n          o.debug(\"usePresenceListener(); waiting for retry but new event received\", { roomId: e.roomId });\n          return;\n        }\n        const Q = Math.min(\n          oe,\n          te * Math.pow(2, s.current)\n        );\n        s.current += 1, o.debug(\"usePresenceListener(); retrying to fetch presence data\", {\n          numRetries: s.current,\n          roomId: e.roomId\n        }), c.current = setTimeout(() => {\n          c.current = void 0, d.current += 1, G(d.current);\n        }, Q);\n      });\n    };\n    let A;\n    return e.presence.get({ waitForSync: !0 }).then((R) => {\n      o.debug(\"usePresenceListener(); fetched initial presence data\", { presenceMembers: R, roomId: e.roomId }), l.current = R, b(R), w();\n    }).catch((R) => {\n      const _ = R;\n      (0,_ably_chat__WEBPACK_IMPORTED_MODULE_3__.errorInfoIs)(_, _ably_chat__WEBPACK_IMPORTED_MODULE_3__.ErrorCodes.RoomIsReleased) || (o.error(\"usePresenceListener(); error fetching initial presence data\", {\n        error: R,\n        roomId: e.roomId\n      }), v(_));\n    }).finally(() => {\n      o.debug(\"usePresenceListener(); subscribing internal listener to presence events\", {\n        roomId: e.roomId\n      }), A = e.presence.subscribe(() => {\n        E();\n      }).unsubscribe;\n    }), () => {\n      A && (o.debug(\"usePresenceListener(); cleaning up internal listener\", { roomId: e.roomId }), A());\n    };\n  }, [e, v, w, o]), (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    if (!D) return;\n    const { unsubscribe: E } = e.presence.subscribe(D);\n    return o.debug(\"usePresenceListener(); applying external listener\", { roomId: e.roomId }), () => {\n      o.debug(\"usePresenceListener(); cleaning up external listener\", { roomId: e.roomId }), E();\n    };\n  }, [e, D, o]), (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    if (!I) return;\n    o.debug(\"usePresenceListener(); applying onDiscontinuity listener\", { roomId: e.roomId });\n    const { off: E } = e.presence.onDiscontinuity(I);\n    return () => {\n      o.debug(\"usePresenceListener(); removing onDiscontinuity listener\", { roomId: e.roomId }), E();\n    };\n  }, [e, I, o]), {\n    connectionStatus: n,\n    connectionError: u,\n    roomStatus: r,\n    roomError: m,\n    error: C,\n    presenceData: f,\n    presence: e.presence\n  };\n}, Ie = (t) => {\n  const { currentStatus: n, error: u } = M({\n    onStatusChange: t == null ? void 0 : t.onConnectionStatusChange\n  }), { room: e, roomError: m, roomStatus: r } = x({\n    onStatusChange: t == null ? void 0 : t.onRoomStatusChange\n  }), o = T();\n  o.trace(\"useRoomReactions();\", { params: t, roomId: e.roomId });\n  const d = h(t == null ? void 0 : t.listener), i = h(t == null ? void 0 : t.onDiscontinuity);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    if (!i) return;\n    o.debug(\"useRoomReactions(); applying onDiscontinuity listener\", { roomId: e.roomId });\n    const { off: s } = e.reactions.onDiscontinuity(i);\n    return () => {\n      o.debug(\"useRoomReactions(); removing onDiscontinuity listener\", { roomId: e.roomId }), s();\n    };\n  }, [e, i, o]), (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    if (!d) return;\n    o.debug(\"useRoomReactions(); applying listener\", { roomId: e.roomId });\n    const { unsubscribe: s } = e.reactions.subscribe(d);\n    return () => {\n      o.debug(\"useRoomReactions(); removing listener\", { roomId: e.roomId }), s();\n    };\n  }, [e, d, o]);\n  const c = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((s) => e.reactions.send(s), [e.reactions]);\n  return {\n    connectionStatus: n,\n    connectionError: u,\n    roomStatus: r,\n    roomError: m,\n    send: c,\n    reactions: e.reactions\n  };\n}, fe = (t) => {\n  const { currentStatus: n, error: u } = M({\n    onStatusChange: t == null ? void 0 : t.onConnectionStatusChange\n  }), { room: e, roomError: m, roomStatus: r } = x({\n    onStatusChange: t == null ? void 0 : t.onRoomStatusChange\n  }), o = T();\n  o.trace(\"useTyping();\", { roomId: e.roomId });\n  const [d, i] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(/* @__PURE__ */ new Set()), [c, s] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(), l = h(t == null ? void 0 : t.listener), f = h(t == null ? void 0 : t.onDiscontinuity);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    s(void 0), i((I) => I.size === 0 ? I : /* @__PURE__ */ new Set());\n    let C = !0;\n    const L = (I) => {\n      I === void 0 ? o.debug(\"useTyping(); clearing error state\", { roomId: e.roomId }) : o.error(\"useTyping(); setting error state\", { error: I, roomId: e.roomId }), s(I);\n    };\n    e.typing.get().then((I) => {\n      C && i(I);\n    }).catch((I) => {\n      const v = I;\n      !C || (0,_ably_chat__WEBPACK_IMPORTED_MODULE_3__.errorInfoIs)(v, _ably_chat__WEBPACK_IMPORTED_MODULE_3__.ErrorCodes.RoomIsReleased) || L(v);\n    });\n    const D = e.typing.subscribe((I) => {\n      L(void 0), i(I.currentlyTyping);\n    });\n    return () => {\n      o.debug(\"useTyping(); unsubscribing from typing events\", { roomId: e.roomId }), C = !1, D.unsubscribe();\n    };\n  }, [e, o]), (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    if (!f) return;\n    o.debug(\"useTyping(); applying onDiscontinuity listener\", { roomId: e.roomId });\n    const { off: C } = e.typing.onDiscontinuity(f);\n    return () => {\n      o.debug(\"useTyping(); removing onDiscontinuity listener\", { roomId: e.roomId }), C();\n    };\n  }, [e, f, o]), (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    if (!l) return;\n    o.debug(\"useTyping(); applying listener\", { roomId: e.roomId });\n    const { unsubscribe: C } = e.typing.subscribe(l);\n    return () => {\n      o.debug(\"useTyping(); removing listener\", { roomId: e.roomId }), C();\n    };\n  }, [e, l, o]);\n  const b = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(() => e.typing.start(), [e.typing]), S = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(() => e.typing.stop(), [e.typing]);\n  return {\n    connectionStatus: n,\n    connectionError: u,\n    roomStatus: r,\n    roomError: m,\n    error: c,\n    start: b,\n    stop: S,\n    currentlyTyping: d,\n    typingIndicators: e.typing\n  };\n}, me = ({\n  id: t,\n  options: n,\n  release: u = !0,\n  attach: e = !0,\n  children: m\n}) => {\n  const r = V(), o = T();\n  o.trace(\"ChatRoomProvider();\", { roomId: t, options: n, release: u, attach: e });\n  const [d, i] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)({ room: r.rooms.get(t, n) });\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    const c = r.rooms.get(t, n);\n    return i((s) => s.room === c ? s : { room: c }), e && (o.debug(\"ChatRoomProvider(); attaching room\", { roomId: t }), c.attach().catch(() => {\n    })), () => {\n      u ? (o.debug(\"ChatRoomProvider(); releasing room\", { roomId: t }), r.rooms.release(t)) : e && (o.debug(\"ChatRoomProvider(); detaching room\", { roomId: t }), c.detach().catch(() => {\n      }));\n    };\n  }, [r, t, n, u, e, o]), /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(U.Provider, { value: d, children: m });\n};\n\n//# sourceMappingURL=ably-chat-react.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0BhYmx5L2NoYXQvZGlzdC9yZWFjdC9hYmx5LWNoYXQtcmVhY3QuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUEyQjtBQUNnSDtBQUNqSDtBQUNtQjtBQUNnRTtBQUM3RyxVQUFVLG9EQUFDLDJGQUEyRjtBQUN0RztBQUNBO0FBQ0EsMEJBQTBCLGdEQUFlLEdBQUc7QUFDNUM7QUFDQSx1Q0FBdUMsd0JBQXdCO0FBQy9ELFlBQVksNkNBQVksU0FBUywwQ0FBUyw2QkFBNkIsYUFBYSxhQUFhO0FBQ2pHLHlCQUF5QixzREFBQyxlQUFlLHVCQUF1QjtBQUNoRSxDQUFDO0FBQ0QsWUFBWSw2Q0FBWTtBQUN4QjtBQUNBLGNBQWMsMkNBQVc7QUFDekI7QUFDQSxDQUFDO0FBQ0QsWUFBWSw2Q0FBQztBQUNiLEVBQUUsZ0RBQUM7QUFDSDtBQUNBLEdBQUc7QUFDSCxZQUFZLGtEQUFDO0FBQ2I7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxzQ0FBc0M7QUFDdEMsaUJBQWlCLCtDQUFDLHdDQUF3QywrQ0FBQyxzQ0FBc0MsK0NBQUM7QUFDbEcsRUFBRSxnREFBQztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0EsU0FBUyxnREFBQztBQUNWLHlDQUF5QztBQUN6QyxZQUFZLFNBQVM7QUFDckI7QUFDQSxLQUFLO0FBQ0w7QUFDQSwyQ0FBMkM7QUFDM0M7QUFDQSxHQUFHLG9DQUFvQyxnREFBQztBQUN4QztBQUNBLHlDQUF5QztBQUN6QyxZQUFZLFNBQVM7QUFDckI7QUFDQSwyQ0FBMkM7QUFDM0M7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxTQUFTLDhDQUFDO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksaURBQUM7QUFDYix5QkFBeUIsS0FBSyw0Q0FBNEM7QUFDMUUsOEJBQThCLDhDQUE4QywyQ0FBVztB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Li4vbm9kZV9tb2R1bGVzL0BhYmx5L2NoYXQvZGlzdC9yZWFjdC9hYmx5LWNoYXQtcmVhY3QuanM/NzBmMCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBqIGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IFcsIHsgY3JlYXRlQ29udGV4dCBhcyBaLCB1c2VSZWYgYXMgUCwgdXNlRWZmZWN0IGFzIGcsIHVzZUNhbGxiYWNrIGFzIGEsIHVzZVN0YXRlIGFzIHksIHVzZU1lbW8gYXMgJCwgdXNlQ29udGV4dCBhcyBwIH0gZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgKiBhcyBGIGZyb20gXCJhYmx5XCI7XG5pbXBvcnQgeyBqc3ggYXMgeiB9IGZyb20gXCJyZWFjdC9qc3gtcnVudGltZVwiO1xuaW1wb3J0IHsgQ29ubmVjdGlvbkxpZmVjeWNsZSBhcyBYLCBSb29tTGlmZWN5Y2xlIGFzIFksIGVycm9ySW5mb0lzIGFzIEosIEVycm9yQ29kZXMgYXMgSyB9IGZyb20gXCJAYWJseS9jaGF0XCI7XG5jb25zdCBVID0gWih2b2lkIDApLCBrID0gU3ltYm9sLmZvcihcIl9fQUJMWV9DSEFUX0NMSUVOVF9DT05URVhUX19cIiksIEIgPSB0eXBlb2YgZ2xvYmFsVGhpcyA+IFwidVwiID8ge30gOiBnbG9iYWxUaGlzO1xuZnVuY3Rpb24gZWUoKSB7XG4gIGxldCB0ID0gQltrXTtcbiAgcmV0dXJuIHQgfHwgKHQgPSBCW2tdID0gVy5jcmVhdGVDb250ZXh0KHt9KSksIHQ7XG59XG5jb25zdCBPID0gZWUoKSwgcSA9IFwiZGVmYXVsdFwiLCB1ZSA9ICh7IGNoaWxkcmVuOiB0LCBjbGllbnQ6IG4gfSkgPT4ge1xuICBjb25zdCB1ID0gai51c2VDb250ZXh0KE8pLCBlID0gai51c2VNZW1vKCgpID0+IChuLmFkZFJlYWN0QWdlbnQoKSwgeyAuLi51LCBbcV06IHsgY2xpZW50OiBuIH0gfSksIFtuLCB1XSk7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8geihPLlByb3ZpZGVyLCB7IHZhbHVlOiBlLCBjaGlsZHJlbjogdCB9KTtcbn0sIFYgPSAoKSA9PiB7XG4gIGNvbnN0IHQgPSBXLnVzZUNvbnRleHQoTylbcV07XG4gIGlmICghdClcbiAgICB0aHJvdyBuZXcgRi5FcnJvckluZm8oXCJ1c2VDaGF0Q2xpZW50IGhvb2sgbXVzdCBiZSB1c2VkIHdpdGhpbiBhIGNoYXQgY2xpZW50IHByb3ZpZGVyXCIsIDRlNCwgNDAwKTtcbiAgcmV0dXJuIHQuY2xpZW50O1xufSwgaCA9ICh0KSA9PiB7XG4gIGNvbnN0IG4gPSBQKHQpO1xuICBnKCgpID0+IHtcbiAgICBuLmN1cnJlbnQgPSB0O1xuICB9KTtcbiAgY29uc3QgdSA9IGEoKC4uLmUpID0+IHtcbiAgICBuLmN1cnJlbnQgJiYgbi5jdXJyZW50KC4uLmUpO1xuICB9LCBbXSk7XG4gIHJldHVybiB0ID8gdSA6IHZvaWQgMDtcbn0sIE0gPSAodCkgPT4ge1xuICBjb25zdCBuID0gVigpO1xuICBuLmxvZ2dlci50cmFjZShcInVzZUNoYXRDb25uZWN0aW9uKCk7XCIsIHQpO1xuICBjb25zdCBbdSwgZV0gPSB5KG4uY29ubmVjdGlvbi5zdGF0dXMuY3VycmVudCksIFttLCByXSA9IHkobi5jb25uZWN0aW9uLnN0YXR1cy5lcnJvciksIFtvLCBkXSA9IHkobi5jb25uZWN0aW9uKTtcbiAgZygoKSA9PiB7XG4gICAgZChuLmNvbm5lY3Rpb24pLCByKG4uY29ubmVjdGlvbi5zdGF0dXMuZXJyb3IpLCBlKG4uY29ubmVjdGlvbi5zdGF0dXMuY3VycmVudCk7XG4gIH0sIFtuXSk7XG4gIGNvbnN0IGkgPSBoKHQgPT0gbnVsbCA/IHZvaWQgMCA6IHQub25TdGF0dXNDaGFuZ2UpO1xuICByZXR1cm4gZygoKSA9PiB7XG4gICAgbi5sb2dnZXIuZGVidWcoXCJ1c2VDaGF0Q29ubmVjdGlvbigpOyBhcHBseWluZyBpbnRlcm5hbCBsaXN0ZW5lclwiKTtcbiAgICBjb25zdCB7IG9mZjogYyB9ID0gbi5jb25uZWN0aW9uLnN0YXR1cy5vbkNoYW5nZSgocykgPT4ge1xuICAgICAgZShzLmN1cnJlbnQpLCByKHMuZXJyb3IpO1xuICAgIH0pO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBuLmxvZ2dlci5kZWJ1ZyhcInVzZUNoYXRDb25uZWN0aW9uKCk7IGNsZWFuaW5nIHVwIGxpc3RlbmVyXCIpLCBjKCk7XG4gICAgfTtcbiAgfSwgW24uY29ubmVjdGlvbi5zdGF0dXMsIG4ubG9nZ2VyXSksIGcoKCkgPT4ge1xuICAgIGlmICghaSkgcmV0dXJuO1xuICAgIG4ubG9nZ2VyLmRlYnVnKFwidXNlQ2hhdENvbm5lY3Rpb24oKTsgYXBwbHlpbmcgY2xpZW50IGxpc3RlbmVyXCIpO1xuICAgIGNvbnN0IHsgb2ZmOiBjIH0gPSBuLmNvbm5lY3Rpb24uc3RhdHVzLm9uQ2hhbmdlKGkpO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBuLmxvZ2dlci5kZWJ1ZyhcInVzZUNoYXRDb25uZWN0aW9uKCk7IGNsZWFuaW5nIHVwIGNsaWVudCBsaXN0ZW5lclwiKSwgYygpO1xuICAgIH07XG4gIH0sIFtuLmNvbm5lY3Rpb24uc3RhdHVzLCBuLmxvZ2dlciwgaV0pLCB7XG4gICAgY3VycmVudFN0YXR1czogdSxcbiAgICBlcnJvcjogbSxcbiAgICBjb25uZWN0aW9uOiBvXG4gIH07XG59LCBUID0gKCkgPT4ge1xuICBjb25zdCB0ID0gVigpO1xuICByZXR1cm4gJCgoKSA9PiB0LmxvZ2dlciwgW3RdKTtcbn07XG5mdW5jdGlvbiBOKHQpIHtcbiAgcmV0dXJuIHtcbiAgICBzdGF0dXM6IHQuY3VycmVudCxcbiAgICBlcnJvcjogdC5lcnJvclxuICB9O1xufVxuY29uc3QgeCA9ICh0KSA9PiB7XG4gIGNvbnN0IG4gPSBwKFUpLCB1ID0gVCgpO1xuICBpZiAodS50cmFjZShcInVzZVJvb20oKTtcIiwgeyByb29tSWQ6IG4gPT0gbnVsbCA/IHZvaWQgMCA6IG4ucm9vbS5yb29tSWQgfSksICFuKVxuICAgIHRocm93IHUuZXJyb3IoXCJ1c2VSb29tKCk7IG11c3QgYmUgdXNlZCB3aXRoaW4gYSBDaGF0Um9vbVByb3ZpZGVyXCIpLCBuZXcgRi5FcnJvckluZm8oXCJ1c2VSb29tIGhvb2sgbXVzdCBiZSB1c2VkIHdpdGhpbiBhIENoYXRSb29tUHJvdmlkZXJcIiwgNGU0LCA0MDApO1xuICBjb25zdCB7IGN1cnJlbnRTdGF0dXM6IGUsIGVycm9yOiBtIH0gPSBNKHtcbiAgICBvblN0YXR1c0NoYW5nZTogdCA9PSBudWxsID8gdm9pZCAwIDogdC5vbkNvbm5lY3Rpb25TdGF0dXNDaGFuZ2VcbiAgfSksIHIgPSBuLnJvb20sIFtvLCBkXSA9IHkoTihyLnN0YXR1cykpLCBpID0gaCh0ID09IG51bGwgPyB2b2lkIDAgOiB0Lm9uU3RhdHVzQ2hhbmdlKTtcbiAgZygoKSA9PiB7XG4gICAgdS5kZWJ1ZyhcInVzZVJvb20oKTsgc2V0dGluZyB1cCByb29tIHN0YXR1cyBsaXN0ZW5lclwiLCB7IHJvb21JZDogci5yb29tSWQgfSk7XG4gICAgY29uc3QgeyBvZmY6IGwgfSA9IHIuc3RhdHVzLm9uQ2hhbmdlKChmKSA9PiB7XG4gICAgICBkKE4oZikpO1xuICAgIH0pO1xuICAgIHJldHVybiBkKChmKSA9PiByLnN0YXR1cy5jdXJyZW50ICE9PSBmLnN0YXR1cyB8fCByLnN0YXR1cy5lcnJvciAhPT0gZi5lcnJvciA/IE4oci5zdGF0dXMpIDogZiksICgpID0+IHtcbiAgICAgIHUuZGVidWcoXCJ1c2VSb29tKCk7IHJlbW92aW5nIHJvb20gc3RhdHVzIGxpc3RlbmVyXCIsIHsgcm9vbUlkOiByLnJvb21JZCB9KSwgbCgpO1xuICAgIH07XG4gIH0sIFtyLCB1XSksIGcoKCkgPT4ge1xuICAgIGlmICghaSkgcmV0dXJuO1xuICAgIHUuZGVidWcoXCJ1c2VSb29tKCk7IGFwcGx5aW5nIHVzZXItcHJvdmlkZWQgbGlzdGVuZXJcIiwgeyByb29tSWQ6IHIucm9vbUlkIH0pO1xuICAgIGNvbnN0IHsgb2ZmOiBsIH0gPSByLnN0YXR1cy5vbkNoYW5nZShpKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgdS5kZWJ1ZyhcInVzZVJvb20oKTsgcmVtb3ZpbmcgdXNlci1wcm92aWRlZCBsaXN0ZW5lclwiLCB7IHJvb21JZDogci5yb29tSWQgfSksIGwoKTtcbiAgICB9O1xuICB9LCBbciwgaSwgdV0pO1xuICBjb25zdCBjID0gYSgoKSA9PiByLmF0dGFjaCgpLCBbcl0pLCBzID0gYSgoKSA9PiByLmRldGFjaCgpLCBbcl0pO1xuICByZXR1cm4ge1xuICAgIHJvb206IHIsXG4gICAgYXR0YWNoOiBjLFxuICAgIGRldGFjaDogcyxcbiAgICByb29tU3RhdHVzOiBvLnN0YXR1cyxcbiAgICByb29tRXJyb3I6IG8uZXJyb3IsXG4gICAgY29ubmVjdGlvblN0YXR1czogZSxcbiAgICBjb25uZWN0aW9uRXJyb3I6IG1cbiAgfTtcbn0sIGllID0gKHQpID0+IHtcbiAgY29uc3QgeyBjdXJyZW50U3RhdHVzOiBuLCBlcnJvcjogdSB9ID0gTSh7XG4gICAgb25TdGF0dXNDaGFuZ2U6IHQgPT0gbnVsbCA/IHZvaWQgMCA6IHQub25Db25uZWN0aW9uU3RhdHVzQ2hhbmdlXG4gIH0pLCB7IHJvb206IGUsIHJvb21FcnJvcjogbSwgcm9vbVN0YXR1czogciB9ID0geCh7XG4gICAgb25TdGF0dXNDaGFuZ2U6IHQgPT0gbnVsbCA/IHZvaWQgMCA6IHQub25Sb29tU3RhdHVzQ2hhbmdlXG4gIH0pLCBvID0gVCgpO1xuICBvLnRyYWNlKFwidXNlTWVzc2FnZXMoKTtcIiwgeyBwYXJhbXM6IHQsIHJvb21JZDogZS5yb29tSWQgfSk7XG4gIGNvbnN0IGQgPSBoKHQgPT0gbnVsbCA/IHZvaWQgMCA6IHQubGlzdGVuZXIpLCBpID0gaCh0ID09IG51bGwgPyB2b2lkIDAgOiB0Lm9uRGlzY29udGludWl0eSksIGMgPSBhKChiKSA9PiBlLm1lc3NhZ2VzLnNlbmQoYiksIFtlXSksIHMgPSBhKChiKSA9PiBlLm1lc3NhZ2VzLmdldChiKSwgW2VdKSwgW2wsIGZdID0geSgpO1xuICByZXR1cm4gZygoKSA9PiB7XG4gICAgaWYgKCFkKSByZXR1cm47XG4gICAgby5kZWJ1ZyhcInVzZU1lc3NhZ2VzKCk7IGFwcGx5aW5nIGxpc3RlbmVyXCIsIHsgcm9vbUlkOiBlLnJvb21JZCB9KTtcbiAgICBsZXQgYiA9ICExO1xuICAgIGNvbnN0IFMgPSBlLm1lc3NhZ2VzLnN1YnNjcmliZShkKTtcbiAgICByZXR1cm4gZigoKSA9PiAoby5kZWJ1ZyhcInVzZU1lc3NhZ2VzKCk7IHNldHRpbmcgZ2V0UHJldmlvdXNNZXNzYWdlcyBzdGF0ZVwiLCB7IHJvb21JZDogZS5yb29tSWQgfSksIChDKSA9PiBiID8gKG8uZGVidWcoXCJ1c2VNZXNzYWdlcygpOyBnZXRQcmV2aW91c01lc3NhZ2VzIGNhbGxlZCBhZnRlciB1bm1vdW50XCIsIHsgcm9vbUlkOiBlLnJvb21JZCB9KSwgUHJvbWlzZS5yZXNvbHZlKHtcbiAgICAgIGl0ZW1zOiBbXSxcbiAgICAgIGhhc05leHQ6ICgpID0+ICExLFxuICAgICAgaXNMYXN0OiAoKSA9PiAhMCxcbiAgICAgIG5leHQ6ICgpID0+IHtcbiAgICAgIH0sXG4gICAgICBwcmV2aW91czogKCkgPT4ge1xuICAgICAgfSxcbiAgICAgIGN1cnJlbnQ6ICgpID0+IHtcbiAgICAgIH0sXG4gICAgICBmaXJzdDogKCkgPT4ge1xuICAgICAgfVxuICAgIH0pKSA6IFMuZ2V0UHJldmlvdXNNZXNzYWdlcyhDKSkpLCAoKSA9PiB7XG4gICAgICBvLmRlYnVnKFwidXNlTWVzc2FnZXMoKTsgcmVtb3ZpbmcgbGlzdGVuZXIgYW5kIGdldFByZXZpb3VzTWVzc2FnZXMgc3RhdGVcIiwgeyByb29tSWQ6IGUucm9vbUlkIH0pLCBiID0gITAsIFMudW5zdWJzY3JpYmUoKSwgZih2b2lkIDApO1xuICAgIH07XG4gIH0sIFtlLCBvLCBkXSksIGcoKCkgPT4ge1xuICAgIGlmICghaSkgcmV0dXJuO1xuICAgIG8uZGVidWcoXCJ1c2VNZXNzYWdlcygpOyBhcHBseWluZyBvbkRpc2NvbnRpbnVpdHkgbGlzdGVuZXJcIiwgeyByb29tSWQ6IGUucm9vbUlkIH0pO1xuICAgIGNvbnN0IHsgb2ZmOiBiIH0gPSBlLm1lc3NhZ2VzLm9uRGlzY29udGludWl0eShpKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgby5kZWJ1ZyhcInVzZU1lc3NhZ2VzKCk7IHJlbW92aW5nIG9uRGlzY29udGludWl0eSBsaXN0ZW5lclwiLCB7IHJvb21JZDogZS5yb29tSWQgfSksIGIoKTtcbiAgICB9O1xuICB9LCBbZSwgbywgaV0pLCB7XG4gICAgc2VuZDogYyxcbiAgICBnZXQ6IHMsXG4gICAgbWVzc2FnZXM6IGUubWVzc2FnZXMsXG4gICAgZ2V0UHJldmlvdXNNZXNzYWdlczogbCxcbiAgICBjb25uZWN0aW9uU3RhdHVzOiBuLFxuICAgIGNvbm5lY3Rpb25FcnJvcjogdSxcbiAgICByb29tU3RhdHVzOiByLFxuICAgIHJvb21FcnJvcjogbVxuICB9O1xufSwgZGUgPSAodCkgPT4ge1xuICBjb25zdCB7IGN1cnJlbnRTdGF0dXM6IG4sIGVycm9yOiB1IH0gPSBNKHtcbiAgICBvblN0YXR1c0NoYW5nZTogdCA9PSBudWxsID8gdm9pZCAwIDogdC5vbkNvbm5lY3Rpb25TdGF0dXNDaGFuZ2VcbiAgfSksIHsgcm9vbTogZSwgcm9vbUVycm9yOiBtLCByb29tU3RhdHVzOiByIH0gPSB4KHtcbiAgICBvblN0YXR1c0NoYW5nZTogdCA9PSBudWxsID8gdm9pZCAwIDogdC5vblJvb21TdGF0dXNDaGFuZ2VcbiAgfSksIG8gPSBUKCk7XG4gIG8udHJhY2UoXCJ1c2VPY2N1cGFuY3koKTtcIiwgeyBwYXJhbXM6IHQsIHJvb21JZDogZS5yb29tSWQgfSk7XG4gIGNvbnN0IFtkLCBpXSA9IHkoe1xuICAgIGNvbm5lY3Rpb25zOiAwLFxuICAgIHByZXNlbmNlTWVtYmVyczogMFxuICB9KSwgYyA9IGgodCA9PSBudWxsID8gdm9pZCAwIDogdC5saXN0ZW5lciksIHMgPSBoKHQgPT0gbnVsbCA/IHZvaWQgMCA6IHQub25EaXNjb250aW51aXR5KTtcbiAgcmV0dXJuIGcoKCkgPT4ge1xuICAgIGlmICghcykgcmV0dXJuO1xuICAgIG8uZGVidWcoXCJ1c2VPY2N1cGFuY3koKTsgYXBwbHlpbmcgb25EaXNjb250aW51aXR5IGxpc3RlbmVyXCIsIHsgcm9vbUlkOiBlLnJvb21JZCB9KTtcbiAgICBjb25zdCB7IG9mZjogbCB9ID0gZS5vY2N1cGFuY3kub25EaXNjb250aW51aXR5KHMpO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBvLmRlYnVnKFwidXNlT2NjdXBhbmN5KCk7IHJlbW92aW5nIG9uRGlzY29udGludWl0eSBsaXN0ZW5lclwiLCB7IHJvb21JZDogZS5yb29tSWQgfSksIGwoKTtcbiAgICB9O1xuICB9LCBbZSwgcywgb10pLCBnKCgpID0+IHtcbiAgICBvLmRlYnVnKFwidXNlT2NjdXBhbmN5KCk7IGFwcGx5aW5nIGludGVybmFsIGxpc3RlbmVyXCIsIHsgcm9vbUlkOiBlLnJvb21JZCB9KTtcbiAgICBjb25zdCB7IHVuc3Vic2NyaWJlOiBsIH0gPSBlLm9jY3VwYW5jeS5zdWJzY3JpYmUoKGYpID0+IHtcbiAgICAgIGkoe1xuICAgICAgICBjb25uZWN0aW9uczogZi5jb25uZWN0aW9ucyxcbiAgICAgICAgcHJlc2VuY2VNZW1iZXJzOiBmLnByZXNlbmNlTWVtYmVyc1xuICAgICAgfSk7XG4gICAgfSk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIG8uZGVidWcoXCJ1c2VPY2N1cGFuY3koKTsgY2xlYW5pbmcgdXAgaW50ZXJuYWwgbGlzdGVuZXJcIiwgeyByb29tSWQ6IGUucm9vbUlkIH0pLCBsKCk7XG4gICAgfTtcbiAgfSwgW2UsIG9dKSwgZygoKSA9PiB7XG4gICAgaWYgKCFjKSByZXR1cm47XG4gICAgby5kZWJ1ZyhcInVzZU9jY3VwYW5jeSgpOyBhcHBseWluZyBsaXN0ZW5lclwiLCB7IHJvb21JZDogZS5yb29tSWQgfSk7XG4gICAgY29uc3QgeyB1bnN1YnNjcmliZTogbCB9ID0gZS5vY2N1cGFuY3kuc3Vic2NyaWJlKGMpO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBvLmRlYnVnKFwidXNlT2NjdXBhbmN5KCk7IGNsZWFuaW5nIHVwIGxpc3RlbmVyXCIsIHsgcm9vbUlkOiBlLnJvb21JZCB9KSwgbCgpO1xuICAgIH07XG4gIH0sIFtjLCBlLCBvXSksIHtcbiAgICBjb25uZWN0aW9uU3RhdHVzOiBuLFxuICAgIGNvbm5lY3Rpb25FcnJvcjogdSxcbiAgICByb29tU3RhdHVzOiByLFxuICAgIHJvb21FcnJvcjogbSxcbiAgICBvY2N1cGFuY3k6IGUub2NjdXBhbmN5LFxuICAgIGNvbm5lY3Rpb25zOiBkLmNvbm5lY3Rpb25zLFxuICAgIHByZXNlbmNlTWVtYmVyczogZC5wcmVzZW5jZU1lbWJlcnNcbiAgfTtcbn0sIEggPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldChbXG4gIFguU3VzcGVuZGVkLFxuICBYLkZhaWxlZFxuXSksIGdlID0gKHQpID0+IHtcbiAgY29uc3QgeyBjdXJyZW50U3RhdHVzOiBuLCBlcnJvcjogdSB9ID0gTSh7XG4gICAgb25TdGF0dXNDaGFuZ2U6IHQgPT0gbnVsbCA/IHZvaWQgMCA6IHQub25Db25uZWN0aW9uU3RhdHVzQ2hhbmdlXG4gIH0pLCB7IHJvb206IGUsIHJvb21FcnJvcjogbSwgcm9vbVN0YXR1czogciB9ID0geCh7XG4gICAgb25TdGF0dXNDaGFuZ2U6IHQgPT0gbnVsbCA/IHZvaWQgMCA6IHQub25Sb29tU3RhdHVzQ2hhbmdlXG4gIH0pLCBvID0gVCgpO1xuICBvLnRyYWNlKFwidXNlUHJlc2VuY2UoKTtcIiwgeyBwYXJhbXM6IHQsIHJvb21JZDogZS5yb29tSWQgfSk7XG4gIGNvbnN0IFtkLCBpXSA9IHkoITEpLCBbYywgc10gPSB5KCksIGwgPSBQKHsgcm9vbVN0YXR1czogciwgY29ubmVjdGlvblN0YXR1czogbiB9KSwgZiA9IGgodCA9PSBudWxsID8gdm9pZCAwIDogdC5vbkRpc2NvbnRpbnVpdHkpLCBiID0gUCh0KTtcbiAgZygoKSA9PiB7XG4gICAgYi5jdXJyZW50ID0gdDtcbiAgfSwgW3RdKSwgZygoKSA9PiB7XG4gICAgbC5jdXJyZW50ID0geyByb29tU3RhdHVzOiByLCBjb25uZWN0aW9uU3RhdHVzOiBuIH07XG4gIH0sIFtyLCBuXSksIGcoKCkgPT4ge1xuICAgIHZhciBEO1xuICAgIGNvbnN0IEMgPSByID09PSBZLkF0dGFjaGVkICYmICFILmhhcyhuKSwgTCA9IGwuY3VycmVudC5yb29tU3RhdHVzID09PSBZLkF0dGFjaGVkICYmICFILmhhcyhsLmN1cnJlbnQuY29ubmVjdGlvblN0YXR1cyk7XG4gICAgaWYgKEMpXG4gICAgICByZXR1cm4gZS5wcmVzZW5jZS5lbnRlcigoRCA9IGIuY3VycmVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IEQuZW50ZXJXaXRoRGF0YSkudGhlbigoKSA9PiB7XG4gICAgICAgIG8uZGVidWcoXCJ1c2VQcmVzZW5jZSgpOyBlbnRlcmVkIHJvb21cIiwgeyByb29tSWQ6IGUucm9vbUlkIH0pLCBpKCEwKSwgcyh2b2lkIDApO1xuICAgICAgfSkuY2F0Y2goKEkpID0+IHtcbiAgICAgICAgby5lcnJvcihcInVzZVByZXNlbmNlKCk7IGVycm9yIGVudGVyaW5nIHJvb21cIiwgeyBlcnJvcjogSSwgcm9vbUlkOiBlLnJvb21JZCB9KSwgcyhJKTtcbiAgICAgIH0pLCAoKSA9PiB7XG4gICAgICAgIHZhciBJO1xuICAgICAgICBMICYmIGUucHJlc2VuY2UubGVhdmUoKEkgPSBiLmN1cnJlbnQpID09IG51bGwgPyB2b2lkIDAgOiBJLmxlYXZlV2l0aERhdGEpLnRoZW4oKCkgPT4ge1xuICAgICAgICAgIG8uZGVidWcoXCJ1c2VQcmVzZW5jZSgpOyBsZWZ0IHJvb21cIiwgeyByb29tSWQ6IGUucm9vbUlkIH0pLCBpKCExKSwgcyh2b2lkIDApO1xuICAgICAgICB9KS5jYXRjaCgodikgPT4ge1xuICAgICAgICAgIG8uZXJyb3IoXCJ1c2VQcmVzZW5jZSgpOyBlcnJvciBsZWF2aW5nIHJvb21cIiwgeyBlcnJvcjogdiwgcm9vbUlkOiBlLnJvb21JZCB9KSwgcyh2KTtcbiAgICAgICAgfSk7XG4gICAgICB9O1xuICB9LCBbZSwgbiwgciwgb10pLCBnKCgpID0+IHtcbiAgICBpZiAoIWYpIHJldHVybjtcbiAgICBvLmRlYnVnKFwidXNlUHJlc2VuY2UoKTsgYXBwbHlpbmcgb25EaXNjb250aW51aXR5IGxpc3RlbmVyXCIsIHsgcm9vbUlkOiBlLnJvb21JZCB9KTtcbiAgICBjb25zdCB7IG9mZjogQyB9ID0gZS5wcmVzZW5jZS5vbkRpc2NvbnRpbnVpdHkoZik7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIG8uZGVidWcoXCJ1c2VQcmVzZW5jZSgpOyByZW1vdmluZyBvbkRpc2NvbnRpbnVpdHkgbGlzdGVuZXJcIiwgeyByb29tSWQ6IGUucm9vbUlkIH0pLCBDKCk7XG4gICAgfTtcbiAgfSwgW2UsIGYsIG9dKTtcbiAgY29uc3QgUyA9IGEoXG4gICAgKEMpID0+IGUucHJlc2VuY2UudXBkYXRlKEMpLnRoZW4oKCkgPT4ge1xuICAgICAgaSghMCksIHModm9pZCAwKTtcbiAgICB9KSxcbiAgICBbZV1cbiAgKTtcbiAgcmV0dXJuIHtcbiAgICBjb25uZWN0aW9uU3RhdHVzOiBuLFxuICAgIGNvbm5lY3Rpb25FcnJvcjogdSxcbiAgICByb29tU3RhdHVzOiByLFxuICAgIHJvb21FcnJvcjogbSxcbiAgICB1cGRhdGU6IFMsXG4gICAgaXNQcmVzZW50OiBkLFxuICAgIGVycm9yOiBjLFxuICAgIHByZXNlbmNlOiBlLnByZXNlbmNlXG4gIH07XG59LCB0ZSA9IDE1MDAsIG9lID0gM2U0LCBuZSA9IDUsIGxlID0gKHQpID0+IHtcbiAgY29uc3QgeyBjdXJyZW50U3RhdHVzOiBuLCBlcnJvcjogdSB9ID0gTSh7XG4gICAgb25TdGF0dXNDaGFuZ2U6IHQgPT0gbnVsbCA/IHZvaWQgMCA6IHQub25Db25uZWN0aW9uU3RhdHVzQ2hhbmdlXG4gIH0pLCB7IHJvb206IGUsIHJvb21FcnJvcjogbSwgcm9vbVN0YXR1czogciB9ID0geCh7XG4gICAgb25TdGF0dXNDaGFuZ2U6IHQgPT0gbnVsbCA/IHZvaWQgMCA6IHQub25Sb29tU3RhdHVzQ2hhbmdlXG4gIH0pLCBvID0gVCgpO1xuICBvLnRyYWNlKFwidXNlUHJlc2VuY2VMaXN0ZW5lcigpO1wiLCB7IHJvb21JZDogZS5yb29tSWQgfSk7XG4gIGNvbnN0IGQgPSBQKDApLCBpID0gUCgwKSwgYyA9IFAoKSwgcyA9IFAoMCksIGwgPSBQKFtdKSwgW2YsIGJdID0geShbXSksIFMgPSBQKCksIFtDLCBMXSA9IHkoKSwgRCA9IGgodCA9PSBudWxsID8gdm9pZCAwIDogdC5saXN0ZW5lciksIEkgPSBoKHQgPT0gbnVsbCA/IHZvaWQgMCA6IHQub25EaXNjb250aW51aXR5KSwgdiA9IGEoXG4gICAgKEUpID0+IHtcbiAgICAgIG8uZGVidWcoXCJ1c2VQcmVzZW5jZUxpc3RlbmVyKCk7IHNldHRpbmcgZXJyb3Igc3RhdGVcIiwgeyBlcnJvcjogRSwgcm9vbUlkOiBlLnJvb21JZCB9KSwgUy5jdXJyZW50ID0gRSwgTChFKTtcbiAgICB9LFxuICAgIFtvLCBlLnJvb21JZF1cbiAgKSwgdyA9IGEoKCkgPT4ge1xuICAgIG8uZGVidWcoXCJ1c2VQcmVzZW5jZUxpc3RlbmVyKCk7IGNsZWFyaW5nIGVycm9yIHN0YXRlXCIsIHsgcm9vbUlkOiBlLnJvb21JZCB9KSwgUy5jdXJyZW50ID0gdm9pZCAwLCBMKHZvaWQgMCk7XG4gIH0sIFtvLCBlLnJvb21JZF0pO1xuICByZXR1cm4gZygoKSA9PiB7XG4gICAgY29uc3QgRSA9ICgpID0+IHtcbiAgICAgIGQuY3VycmVudCArPSAxLCBjLmN1cnJlbnQgJiYgKGNsZWFyVGltZW91dChjLmN1cnJlbnQpLCBjLmN1cnJlbnQgPSB2b2lkIDAsIHMuY3VycmVudCA9IDApLCBHKGQuY3VycmVudCk7XG4gICAgfSwgRyA9IChSKSA9PiB7XG4gICAgICBlLnByZXNlbmNlLmdldCh7IHdhaXRGb3JTeW5jOiAhMCB9KS50aGVuKChfKSA9PiB7XG4gICAgICAgIG8uZGVidWcoXCJ1c2VQcmVzZW5jZUxpc3RlbmVyKCk7IGZldGNoZWQgcHJlc2VuY2UgZGF0YVwiLCB7IHByZXNlbmNlTWVtYmVyczogXywgcm9vbUlkOiBlLnJvb21JZCB9KSwgYy5jdXJyZW50ICYmIChjbGVhclRpbWVvdXQoYy5jdXJyZW50KSwgYy5jdXJyZW50ID0gdm9pZCAwLCBzLmN1cnJlbnQgPSAwKSwgIShpLmN1cnJlbnQgPj0gUikgJiYgKGkuY3VycmVudCA9IFIsIGwuY3VycmVudCA9IF8sIGIoXyksIFMuY3VycmVudCAmJiB3KCkpO1xuICAgICAgfSkuY2F0Y2goKCkgPT4ge1xuICAgICAgICBpZiAoIShzLmN1cnJlbnQgPCBuZSkpIHtcbiAgICAgICAgICBvLmVycm9yKFwidXNlUHJlc2VuY2VMaXN0ZW5lcigpOyBmYWlsZWQgdG8gZmV0Y2ggcHJlc2VuY2UgZGF0YSBhZnRlciBtYXggcmV0cmllc1wiLCB7XG4gICAgICAgICAgICByb29tSWQ6IGUucm9vbUlkXG4gICAgICAgICAgfSksIHYobmV3IEYuRXJyb3JJbmZvKFwiZmFpbGVkIHRvIGZldGNoIHByZXNlbmNlIGRhdGEgYWZ0ZXIgbWF4IHJldHJpZXNcIiwgNWU0LCA1MDApKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGMuY3VycmVudCkge1xuICAgICAgICAgIG8uZGVidWcoXCJ1c2VQcmVzZW5jZUxpc3RlbmVyKCk7IHdhaXRpbmcgZm9yIHJldHJ5IGJ1dCBuZXcgZXZlbnQgcmVjZWl2ZWRcIiwgeyByb29tSWQ6IGUucm9vbUlkIH0pO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBRID0gTWF0aC5taW4oXG4gICAgICAgICAgb2UsXG4gICAgICAgICAgdGUgKiBNYXRoLnBvdygyLCBzLmN1cnJlbnQpXG4gICAgICAgICk7XG4gICAgICAgIHMuY3VycmVudCArPSAxLCBvLmRlYnVnKFwidXNlUHJlc2VuY2VMaXN0ZW5lcigpOyByZXRyeWluZyB0byBmZXRjaCBwcmVzZW5jZSBkYXRhXCIsIHtcbiAgICAgICAgICBudW1SZXRyaWVzOiBzLmN1cnJlbnQsXG4gICAgICAgICAgcm9vbUlkOiBlLnJvb21JZFxuICAgICAgICB9KSwgYy5jdXJyZW50ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgYy5jdXJyZW50ID0gdm9pZCAwLCBkLmN1cnJlbnQgKz0gMSwgRyhkLmN1cnJlbnQpO1xuICAgICAgICB9LCBRKTtcbiAgICAgIH0pO1xuICAgIH07XG4gICAgbGV0IEE7XG4gICAgcmV0dXJuIGUucHJlc2VuY2UuZ2V0KHsgd2FpdEZvclN5bmM6ICEwIH0pLnRoZW4oKFIpID0+IHtcbiAgICAgIG8uZGVidWcoXCJ1c2VQcmVzZW5jZUxpc3RlbmVyKCk7IGZldGNoZWQgaW5pdGlhbCBwcmVzZW5jZSBkYXRhXCIsIHsgcHJlc2VuY2VNZW1iZXJzOiBSLCByb29tSWQ6IGUucm9vbUlkIH0pLCBsLmN1cnJlbnQgPSBSLCBiKFIpLCB3KCk7XG4gICAgfSkuY2F0Y2goKFIpID0+IHtcbiAgICAgIGNvbnN0IF8gPSBSO1xuICAgICAgSihfLCBLLlJvb21Jc1JlbGVhc2VkKSB8fCAoby5lcnJvcihcInVzZVByZXNlbmNlTGlzdGVuZXIoKTsgZXJyb3IgZmV0Y2hpbmcgaW5pdGlhbCBwcmVzZW5jZSBkYXRhXCIsIHtcbiAgICAgICAgZXJyb3I6IFIsXG4gICAgICAgIHJvb21JZDogZS5yb29tSWRcbiAgICAgIH0pLCB2KF8pKTtcbiAgICB9KS5maW5hbGx5KCgpID0+IHtcbiAgICAgIG8uZGVidWcoXCJ1c2VQcmVzZW5jZUxpc3RlbmVyKCk7IHN1YnNjcmliaW5nIGludGVybmFsIGxpc3RlbmVyIHRvIHByZXNlbmNlIGV2ZW50c1wiLCB7XG4gICAgICAgIHJvb21JZDogZS5yb29tSWRcbiAgICAgIH0pLCBBID0gZS5wcmVzZW5jZS5zdWJzY3JpYmUoKCkgPT4ge1xuICAgICAgICBFKCk7XG4gICAgICB9KS51bnN1YnNjcmliZTtcbiAgICB9KSwgKCkgPT4ge1xuICAgICAgQSAmJiAoby5kZWJ1ZyhcInVzZVByZXNlbmNlTGlzdGVuZXIoKTsgY2xlYW5pbmcgdXAgaW50ZXJuYWwgbGlzdGVuZXJcIiwgeyByb29tSWQ6IGUucm9vbUlkIH0pLCBBKCkpO1xuICAgIH07XG4gIH0sIFtlLCB2LCB3LCBvXSksIGcoKCkgPT4ge1xuICAgIGlmICghRCkgcmV0dXJuO1xuICAgIGNvbnN0IHsgdW5zdWJzY3JpYmU6IEUgfSA9IGUucHJlc2VuY2Uuc3Vic2NyaWJlKEQpO1xuICAgIHJldHVybiBvLmRlYnVnKFwidXNlUHJlc2VuY2VMaXN0ZW5lcigpOyBhcHBseWluZyBleHRlcm5hbCBsaXN0ZW5lclwiLCB7IHJvb21JZDogZS5yb29tSWQgfSksICgpID0+IHtcbiAgICAgIG8uZGVidWcoXCJ1c2VQcmVzZW5jZUxpc3RlbmVyKCk7IGNsZWFuaW5nIHVwIGV4dGVybmFsIGxpc3RlbmVyXCIsIHsgcm9vbUlkOiBlLnJvb21JZCB9KSwgRSgpO1xuICAgIH07XG4gIH0sIFtlLCBELCBvXSksIGcoKCkgPT4ge1xuICAgIGlmICghSSkgcmV0dXJuO1xuICAgIG8uZGVidWcoXCJ1c2VQcmVzZW5jZUxpc3RlbmVyKCk7IGFwcGx5aW5nIG9uRGlzY29udGludWl0eSBsaXN0ZW5lclwiLCB7IHJvb21JZDogZS5yb29tSWQgfSk7XG4gICAgY29uc3QgeyBvZmY6IEUgfSA9IGUucHJlc2VuY2Uub25EaXNjb250aW51aXR5KEkpO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBvLmRlYnVnKFwidXNlUHJlc2VuY2VMaXN0ZW5lcigpOyByZW1vdmluZyBvbkRpc2NvbnRpbnVpdHkgbGlzdGVuZXJcIiwgeyByb29tSWQ6IGUucm9vbUlkIH0pLCBFKCk7XG4gICAgfTtcbiAgfSwgW2UsIEksIG9dKSwge1xuICAgIGNvbm5lY3Rpb25TdGF0dXM6IG4sXG4gICAgY29ubmVjdGlvbkVycm9yOiB1LFxuICAgIHJvb21TdGF0dXM6IHIsXG4gICAgcm9vbUVycm9yOiBtLFxuICAgIGVycm9yOiBDLFxuICAgIHByZXNlbmNlRGF0YTogZixcbiAgICBwcmVzZW5jZTogZS5wcmVzZW5jZVxuICB9O1xufSwgSWUgPSAodCkgPT4ge1xuICBjb25zdCB7IGN1cnJlbnRTdGF0dXM6IG4sIGVycm9yOiB1IH0gPSBNKHtcbiAgICBvblN0YXR1c0NoYW5nZTogdCA9PSBudWxsID8gdm9pZCAwIDogdC5vbkNvbm5lY3Rpb25TdGF0dXNDaGFuZ2VcbiAgfSksIHsgcm9vbTogZSwgcm9vbUVycm9yOiBtLCByb29tU3RhdHVzOiByIH0gPSB4KHtcbiAgICBvblN0YXR1c0NoYW5nZTogdCA9PSBudWxsID8gdm9pZCAwIDogdC5vblJvb21TdGF0dXNDaGFuZ2VcbiAgfSksIG8gPSBUKCk7XG4gIG8udHJhY2UoXCJ1c2VSb29tUmVhY3Rpb25zKCk7XCIsIHsgcGFyYW1zOiB0LCByb29tSWQ6IGUucm9vbUlkIH0pO1xuICBjb25zdCBkID0gaCh0ID09IG51bGwgPyB2b2lkIDAgOiB0Lmxpc3RlbmVyKSwgaSA9IGgodCA9PSBudWxsID8gdm9pZCAwIDogdC5vbkRpc2NvbnRpbnVpdHkpO1xuICBnKCgpID0+IHtcbiAgICBpZiAoIWkpIHJldHVybjtcbiAgICBvLmRlYnVnKFwidXNlUm9vbVJlYWN0aW9ucygpOyBhcHBseWluZyBvbkRpc2NvbnRpbnVpdHkgbGlzdGVuZXJcIiwgeyByb29tSWQ6IGUucm9vbUlkIH0pO1xuICAgIGNvbnN0IHsgb2ZmOiBzIH0gPSBlLnJlYWN0aW9ucy5vbkRpc2NvbnRpbnVpdHkoaSk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIG8uZGVidWcoXCJ1c2VSb29tUmVhY3Rpb25zKCk7IHJlbW92aW5nIG9uRGlzY29udGludWl0eSBsaXN0ZW5lclwiLCB7IHJvb21JZDogZS5yb29tSWQgfSksIHMoKTtcbiAgICB9O1xuICB9LCBbZSwgaSwgb10pLCBnKCgpID0+IHtcbiAgICBpZiAoIWQpIHJldHVybjtcbiAgICBvLmRlYnVnKFwidXNlUm9vbVJlYWN0aW9ucygpOyBhcHBseWluZyBsaXN0ZW5lclwiLCB7IHJvb21JZDogZS5yb29tSWQgfSk7XG4gICAgY29uc3QgeyB1bnN1YnNjcmliZTogcyB9ID0gZS5yZWFjdGlvbnMuc3Vic2NyaWJlKGQpO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBvLmRlYnVnKFwidXNlUm9vbVJlYWN0aW9ucygpOyByZW1vdmluZyBsaXN0ZW5lclwiLCB7IHJvb21JZDogZS5yb29tSWQgfSksIHMoKTtcbiAgICB9O1xuICB9LCBbZSwgZCwgb10pO1xuICBjb25zdCBjID0gYSgocykgPT4gZS5yZWFjdGlvbnMuc2VuZChzKSwgW2UucmVhY3Rpb25zXSk7XG4gIHJldHVybiB7XG4gICAgY29ubmVjdGlvblN0YXR1czogbixcbiAgICBjb25uZWN0aW9uRXJyb3I6IHUsXG4gICAgcm9vbVN0YXR1czogcixcbiAgICByb29tRXJyb3I6IG0sXG4gICAgc2VuZDogYyxcbiAgICByZWFjdGlvbnM6IGUucmVhY3Rpb25zXG4gIH07XG59LCBmZSA9ICh0KSA9PiB7XG4gIGNvbnN0IHsgY3VycmVudFN0YXR1czogbiwgZXJyb3I6IHUgfSA9IE0oe1xuICAgIG9uU3RhdHVzQ2hhbmdlOiB0ID09IG51bGwgPyB2b2lkIDAgOiB0Lm9uQ29ubmVjdGlvblN0YXR1c0NoYW5nZVxuICB9KSwgeyByb29tOiBlLCByb29tRXJyb3I6IG0sIHJvb21TdGF0dXM6IHIgfSA9IHgoe1xuICAgIG9uU3RhdHVzQ2hhbmdlOiB0ID09IG51bGwgPyB2b2lkIDAgOiB0Lm9uUm9vbVN0YXR1c0NoYW5nZVxuICB9KSwgbyA9IFQoKTtcbiAgby50cmFjZShcInVzZVR5cGluZygpO1wiLCB7IHJvb21JZDogZS5yb29tSWQgfSk7XG4gIGNvbnN0IFtkLCBpXSA9IHkoLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKSksIFtjLCBzXSA9IHkoKSwgbCA9IGgodCA9PSBudWxsID8gdm9pZCAwIDogdC5saXN0ZW5lciksIGYgPSBoKHQgPT0gbnVsbCA/IHZvaWQgMCA6IHQub25EaXNjb250aW51aXR5KTtcbiAgZygoKSA9PiB7XG4gICAgcyh2b2lkIDApLCBpKChJKSA9PiBJLnNpemUgPT09IDAgPyBJIDogLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKSk7XG4gICAgbGV0IEMgPSAhMDtcbiAgICBjb25zdCBMID0gKEkpID0+IHtcbiAgICAgIEkgPT09IHZvaWQgMCA/IG8uZGVidWcoXCJ1c2VUeXBpbmcoKTsgY2xlYXJpbmcgZXJyb3Igc3RhdGVcIiwgeyByb29tSWQ6IGUucm9vbUlkIH0pIDogby5lcnJvcihcInVzZVR5cGluZygpOyBzZXR0aW5nIGVycm9yIHN0YXRlXCIsIHsgZXJyb3I6IEksIHJvb21JZDogZS5yb29tSWQgfSksIHMoSSk7XG4gICAgfTtcbiAgICBlLnR5cGluZy5nZXQoKS50aGVuKChJKSA9PiB7XG4gICAgICBDICYmIGkoSSk7XG4gICAgfSkuY2F0Y2goKEkpID0+IHtcbiAgICAgIGNvbnN0IHYgPSBJO1xuICAgICAgIUMgfHwgSih2LCBLLlJvb21Jc1JlbGVhc2VkKSB8fCBMKHYpO1xuICAgIH0pO1xuICAgIGNvbnN0IEQgPSBlLnR5cGluZy5zdWJzY3JpYmUoKEkpID0+IHtcbiAgICAgIEwodm9pZCAwKSwgaShJLmN1cnJlbnRseVR5cGluZyk7XG4gICAgfSk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIG8uZGVidWcoXCJ1c2VUeXBpbmcoKTsgdW5zdWJzY3JpYmluZyBmcm9tIHR5cGluZyBldmVudHNcIiwgeyByb29tSWQ6IGUucm9vbUlkIH0pLCBDID0gITEsIEQudW5zdWJzY3JpYmUoKTtcbiAgICB9O1xuICB9LCBbZSwgb10pLCBnKCgpID0+IHtcbiAgICBpZiAoIWYpIHJldHVybjtcbiAgICBvLmRlYnVnKFwidXNlVHlwaW5nKCk7IGFwcGx5aW5nIG9uRGlzY29udGludWl0eSBsaXN0ZW5lclwiLCB7IHJvb21JZDogZS5yb29tSWQgfSk7XG4gICAgY29uc3QgeyBvZmY6IEMgfSA9IGUudHlwaW5nLm9uRGlzY29udGludWl0eShmKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgby5kZWJ1ZyhcInVzZVR5cGluZygpOyByZW1vdmluZyBvbkRpc2NvbnRpbnVpdHkgbGlzdGVuZXJcIiwgeyByb29tSWQ6IGUucm9vbUlkIH0pLCBDKCk7XG4gICAgfTtcbiAgfSwgW2UsIGYsIG9dKSwgZygoKSA9PiB7XG4gICAgaWYgKCFsKSByZXR1cm47XG4gICAgby5kZWJ1ZyhcInVzZVR5cGluZygpOyBhcHBseWluZyBsaXN0ZW5lclwiLCB7IHJvb21JZDogZS5yb29tSWQgfSk7XG4gICAgY29uc3QgeyB1bnN1YnNjcmliZTogQyB9ID0gZS50eXBpbmcuc3Vic2NyaWJlKGwpO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBvLmRlYnVnKFwidXNlVHlwaW5nKCk7IHJlbW92aW5nIGxpc3RlbmVyXCIsIHsgcm9vbUlkOiBlLnJvb21JZCB9KSwgQygpO1xuICAgIH07XG4gIH0sIFtlLCBsLCBvXSk7XG4gIGNvbnN0IGIgPSBhKCgpID0+IGUudHlwaW5nLnN0YXJ0KCksIFtlLnR5cGluZ10pLCBTID0gYSgoKSA9PiBlLnR5cGluZy5zdG9wKCksIFtlLnR5cGluZ10pO1xuICByZXR1cm4ge1xuICAgIGNvbm5lY3Rpb25TdGF0dXM6IG4sXG4gICAgY29ubmVjdGlvbkVycm9yOiB1LFxuICAgIHJvb21TdGF0dXM6IHIsXG4gICAgcm9vbUVycm9yOiBtLFxuICAgIGVycm9yOiBjLFxuICAgIHN0YXJ0OiBiLFxuICAgIHN0b3A6IFMsXG4gICAgY3VycmVudGx5VHlwaW5nOiBkLFxuICAgIHR5cGluZ0luZGljYXRvcnM6IGUudHlwaW5nXG4gIH07XG59LCBtZSA9ICh7XG4gIGlkOiB0LFxuICBvcHRpb25zOiBuLFxuICByZWxlYXNlOiB1ID0gITAsXG4gIGF0dGFjaDogZSA9ICEwLFxuICBjaGlsZHJlbjogbVxufSkgPT4ge1xuICBjb25zdCByID0gVigpLCBvID0gVCgpO1xuICBvLnRyYWNlKFwiQ2hhdFJvb21Qcm92aWRlcigpO1wiLCB7IHJvb21JZDogdCwgb3B0aW9uczogbiwgcmVsZWFzZTogdSwgYXR0YWNoOiBlIH0pO1xuICBjb25zdCBbZCwgaV0gPSB5KHsgcm9vbTogci5yb29tcy5nZXQodCwgbikgfSk7XG4gIHJldHVybiBnKCgpID0+IHtcbiAgICBjb25zdCBjID0gci5yb29tcy5nZXQodCwgbik7XG4gICAgcmV0dXJuIGkoKHMpID0+IHMucm9vbSA9PT0gYyA/IHMgOiB7IHJvb206IGMgfSksIGUgJiYgKG8uZGVidWcoXCJDaGF0Um9vbVByb3ZpZGVyKCk7IGF0dGFjaGluZyByb29tXCIsIHsgcm9vbUlkOiB0IH0pLCBjLmF0dGFjaCgpLmNhdGNoKCgpID0+IHtcbiAgICB9KSksICgpID0+IHtcbiAgICAgIHUgPyAoby5kZWJ1ZyhcIkNoYXRSb29tUHJvdmlkZXIoKTsgcmVsZWFzaW5nIHJvb21cIiwgeyByb29tSWQ6IHQgfSksIHIucm9vbXMucmVsZWFzZSh0KSkgOiBlICYmIChvLmRlYnVnKFwiQ2hhdFJvb21Qcm92aWRlcigpOyBkZXRhY2hpbmcgcm9vbVwiLCB7IHJvb21JZDogdCB9KSwgYy5kZXRhY2goKS5jYXRjaCgoKSA9PiB7XG4gICAgICB9KSk7XG4gICAgfTtcbiAgfSwgW3IsIHQsIG4sIHUsIGUsIG9dKSwgLyogQF9fUFVSRV9fICovIHooVS5Qcm92aWRlciwgeyB2YWx1ZTogZCwgY2hpbGRyZW46IG0gfSk7XG59O1xuZXhwb3J0IHtcbiAgdWUgYXMgQ2hhdENsaWVudFByb3ZpZGVyLFxuICBVIGFzIENoYXRSb29tQ29udGV4dCxcbiAgbWUgYXMgQ2hhdFJvb21Qcm92aWRlcixcbiAgViBhcyB1c2VDaGF0Q2xpZW50LFxuICBNIGFzIHVzZUNoYXRDb25uZWN0aW9uLFxuICBpZSBhcyB1c2VNZXNzYWdlcyxcbiAgZGUgYXMgdXNlT2NjdXBhbmN5LFxuICBnZSBhcyB1c2VQcmVzZW5jZSxcbiAgbGUgYXMgdXNlUHJlc2VuY2VMaXN0ZW5lcixcbiAgeCBhcyB1c2VSb29tLFxuICBJZSBhcyB1c2VSb29tUmVhY3Rpb25zLFxuICBmZSBhcyB1c2VUeXBpbmdcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hYmx5LWNoYXQtcmVhY3QuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../../../node_modules/@ably/chat/dist/react/ably-chat-react.js\n");

/***/ })

};
;