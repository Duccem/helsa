"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/better-call";
exports.ids = ["vendor-chunks/better-call"];
exports.modules = {

/***/ "(action-browser)/../../../node_modules/better-call/dist/index.js":
/*!*******************************************************!*\
  !*** ../../../node_modules/better-call/dist/index.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   APIError: () => (/* binding */ APIError),\n/* harmony export */   createEndpoint: () => (/* binding */ createEndpoint),\n/* harmony export */   createEndpointCreator: () => (/* binding */ createEndpointCreator),\n/* harmony export */   createMiddleware: () => (/* binding */ createMiddleware),\n/* harmony export */   createMiddlewareCreator: () => (/* binding */ createMiddlewareCreator),\n/* harmony export */   createRouter: () => (/* binding */ createRouter),\n/* harmony export */   getBody: () => (/* binding */ getBody),\n/* harmony export */   getCookie: () => (/* binding */ getCookie),\n/* harmony export */   getRequest: () => (/* binding */ getRequest),\n/* harmony export */   getSignedCookie: () => (/* binding */ getSignedCookie),\n/* harmony export */   json: () => (/* binding */ json),\n/* harmony export */   parse: () => (/* binding */ parse),\n/* harmony export */   parseSigned: () => (/* binding */ parseSigned),\n/* harmony export */   serialize: () => (/* binding */ serialize),\n/* harmony export */   serializeSigned: () => (/* binding */ serializeSigned),\n/* harmony export */   setCookie: () => (/* binding */ setCookie),\n/* harmony export */   setResponse: () => (/* binding */ setResponse),\n/* harmony export */   setSignedCookie: () => (/* binding */ setSignedCookie),\n/* harmony export */   shouldSerialize: () => (/* binding */ shouldSerialize),\n/* harmony export */   signCookieValue: () => (/* binding */ signCookieValue),\n/* harmony export */   statusCode: () => (/* binding */ statusCode),\n/* harmony export */   toNodeHandler: () => (/* binding */ toNodeHandler)\n/* harmony export */ });\n/* harmony import */ var zod__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! zod */ \"(action-browser)/../../../node_modules/zod/lib/index.mjs\");\n/* harmony import */ var uncrypto__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! uncrypto */ \"(action-browser)/../../../node_modules/uncrypto/dist/crypto.node.mjs\");\n/* harmony import */ var rou3__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! rou3 */ \"(action-browser)/../../../node_modules/rou3/dist/index.mjs\");\n/* harmony import */ var set_cookie_parser__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! set-cookie-parser */ \"(action-browser)/../../../node_modules/set-cookie-parser/lib/set-cookie.js\");\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n\n// src/endpoint.ts\n\n\n// src/error.ts\nvar APIError = class extends Error {\n  constructor(status, body, headers) {\n    super(`API Error: ${status} ${body?.message ?? \"\"}`, {\n      cause: body\n    });\n    __publicField(this, \"status\");\n    __publicField(this, \"headers\");\n    __publicField(this, \"body\");\n    this.status = status;\n    this.body = body ?? {};\n    this.body.code = body?.message ? body.message.toUpperCase().replace(/ /g, \"_\").replace(/[^A-Z0-9_]/g, \"\") : status;\n    this.stack = \"\";\n    this.headers = headers ?? new Headers();\n    if (!this.headers.has(\"Content-Type\")) {\n      this.headers.set(\"Content-Type\", \"application/json\");\n    }\n    this.name = \"BetterCallAPIError\";\n  }\n};\n\n// src/helper.ts\nvar json = (body, option) => {\n  return {\n    response: {\n      body: option?.body ?? body,\n      status: option?.status ?? 200,\n      statusText: option?.statusText ?? \"OK\",\n      headers: option?.headers\n    },\n    body,\n    _flag: \"json\"\n  };\n};\n\n// src/cookie.ts\n\nvar algorithm = { name: \"HMAC\", hash: \"SHA-256\" };\nvar getCryptoKey = async (secret) => {\n  const secretBuf = typeof secret === \"string\" ? new TextEncoder().encode(secret) : secret;\n  return await uncrypto__WEBPACK_IMPORTED_MODULE_0__.subtle.importKey(\"raw\", secretBuf, algorithm, false, [\"sign\", \"verify\"]);\n};\nvar makeSignature = async (value, secret) => {\n  const key = await getCryptoKey(secret);\n  const signature = await uncrypto__WEBPACK_IMPORTED_MODULE_0__.subtle.sign(algorithm.name, key, new TextEncoder().encode(value));\n  return btoa(String.fromCharCode(...new Uint8Array(signature)));\n};\nvar verifySignature = async (base64Signature, value, secret) => {\n  try {\n    const signatureBinStr = atob(base64Signature);\n    const signature = new Uint8Array(signatureBinStr.length);\n    for (let i = 0, len = signatureBinStr.length; i < len; i++) {\n      signature[i] = signatureBinStr.charCodeAt(i);\n    }\n    return await uncrypto__WEBPACK_IMPORTED_MODULE_0__.subtle.verify(algorithm, secret, signature, new TextEncoder().encode(value));\n  } catch (e) {\n    return false;\n  }\n};\nvar validCookieNameRegEx = /^[\\w!#$%&'*.^`|~+-]+$/;\nvar validCookieValueRegEx = /^[ !#-:<-[\\]-~]*$/;\nvar parse = (cookie, name) => {\n  const pairs = cookie.trim().split(\";\");\n  return pairs.reduce((parsedCookie, pairStr) => {\n    pairStr = pairStr.trim();\n    const valueStartPos = pairStr.indexOf(\"=\");\n    if (valueStartPos === -1) {\n      return parsedCookie;\n    }\n    const cookieName = pairStr.substring(0, valueStartPos).trim();\n    if (name && name !== cookieName || !validCookieNameRegEx.test(cookieName)) {\n      return parsedCookie;\n    }\n    let cookieValue = pairStr.substring(valueStartPos + 1).trim();\n    if (cookieValue.startsWith('\"') && cookieValue.endsWith('\"')) {\n      cookieValue = cookieValue.slice(1, -1);\n    }\n    if (validCookieValueRegEx.test(cookieValue)) {\n      parsedCookie[cookieName] = decodeURIComponent(cookieValue);\n    }\n    return parsedCookie;\n  }, {});\n};\nvar parseSigned = async (cookie, secret, name) => {\n  const parsedCookie = {};\n  const secretKey = await getCryptoKey(secret);\n  for (const [key, value] of Object.entries(parse(cookie, name))) {\n    const signatureStartPos = value.lastIndexOf(\".\");\n    if (signatureStartPos < 1) {\n      continue;\n    }\n    const signedValue = value.substring(0, signatureStartPos);\n    const signature = value.substring(signatureStartPos + 1);\n    if (signature.length !== 44 || !signature.endsWith(\"=\")) {\n      continue;\n    }\n    const isVerified = await verifySignature(signature, signedValue, secretKey);\n    parsedCookie[key] = isVerified ? signedValue : false;\n  }\n  return parsedCookie;\n};\nvar _serialize = (name, value, opt = {}) => {\n  let cookie = `${name}=${value}`;\n  if (name.startsWith(\"__Secure-\") && !opt.secure) {\n    opt.secure = true;\n  }\n  if (name.startsWith(\"__Host-\")) {\n    if (!opt.secure) {\n      opt.secure = true;\n    }\n    if (opt.path !== \"/\") {\n      opt.path = \"/\";\n    }\n    if (opt.domain) {\n      opt.domain = void 0;\n    }\n  }\n  if (opt && typeof opt.maxAge === \"number\" && opt.maxAge >= 0) {\n    if (opt.maxAge > 3456e4) {\n      throw new Error(\n        \"Cookies Max-Age SHOULD NOT be greater than 400 days (34560000 seconds) in duration.\"\n      );\n    }\n    cookie += `; Max-Age=${Math.floor(opt.maxAge)}`;\n  }\n  if (opt.domain && opt.prefix !== \"host\") {\n    cookie += `; Domain=${opt.domain}`;\n  }\n  if (opt.path) {\n    cookie += `; Path=${opt.path}`;\n  }\n  if (opt.expires) {\n    if (opt.expires.getTime() - Date.now() > 3456e7) {\n      throw new Error(\n        \"Cookies Expires SHOULD NOT be greater than 400 days (34560000 seconds) in the future.\"\n      );\n    }\n    cookie += `; Expires=${opt.expires.toUTCString()}`;\n  }\n  if (opt.httpOnly) {\n    cookie += \"; HttpOnly\";\n  }\n  if (opt.secure) {\n    cookie += \"; Secure\";\n  }\n  if (opt.sameSite) {\n    cookie += `; SameSite=${opt.sameSite.charAt(0).toUpperCase() + opt.sameSite.slice(1)}`;\n  }\n  if (opt.partitioned) {\n    if (!opt.secure) {\n      throw new Error(\"Partitioned Cookie must have Secure attributes\");\n    }\n    cookie += \"; Partitioned\";\n  }\n  return cookie;\n};\nvar serialize = (name, value, opt) => {\n  value = encodeURIComponent(value);\n  return _serialize(name, value, opt);\n};\nvar serializeSigned = async (name, value, secret, opt = {}) => {\n  const signature = await makeSignature(value, secret);\n  value = `${value}.${signature}`;\n  value = encodeURIComponent(value);\n  return _serialize(name, value, opt);\n};\nvar signCookieValue = async (value, secret) => {\n  const signature = await makeSignature(value, secret);\n  value = `${value}.${signature}`;\n  value = encodeURIComponent(value);\n  return value;\n};\n\n// src/cookie-utils.ts\nvar getCookie = (cookie, key, prefix) => {\n  if (!cookie) {\n    return void 0;\n  }\n  let finalKey = key;\n  if (prefix) {\n    if (prefix === \"secure\") {\n      finalKey = \"__Secure-\" + key;\n    } else if (prefix === \"host\") {\n      finalKey = \"__Host-\" + key;\n    } else {\n      return void 0;\n    }\n  }\n  const obj = parse(cookie, finalKey);\n  return obj[finalKey];\n};\nvar setCookie = (header, name, value, opt) => {\n  const existingCookies = header.get(\"Set-Cookie\");\n  if (existingCookies) {\n    const cookies = existingCookies.split(\", \");\n    const updatedCookies = cookies.filter((cookie2) => !cookie2.startsWith(`${name}=`));\n    header.delete(\"Set-Cookie\");\n    updatedCookies.forEach((cookie2) => header.append(\"Set-Cookie\", cookie2));\n  }\n  let cookie;\n  if (opt?.prefix === \"secure\") {\n    cookie = serialize(\"__Secure-\" + name, value, { path: \"/\", ...opt, secure: true });\n  } else if (opt?.prefix === \"host\") {\n    cookie = serialize(\"__Host-\" + name, value, {\n      ...opt,\n      path: \"/\",\n      secure: true,\n      domain: void 0\n    });\n  } else {\n    cookie = serialize(name, value, { path: \"/\", ...opt });\n  }\n  header.append(\"Set-Cookie\", cookie);\n};\nvar setSignedCookie = async (header, name, value, secret, opt) => {\n  let cookie;\n  if (opt?.prefix === \"secure\") {\n    cookie = await serializeSigned(\"__Secure-\" + name, value, secret, {\n      path: \"/\",\n      ...opt,\n      secure: true\n    });\n  } else if (opt?.prefix === \"host\") {\n    cookie = await serializeSigned(\"__Host-\" + name, value, secret, {\n      ...opt,\n      path: \"/\",\n      secure: true,\n      domain: void 0\n    });\n  } else {\n    cookie = await serializeSigned(name, value, secret, { path: \"/\", ...opt });\n  }\n  header.append(\"Set-Cookie\", cookie);\n};\nvar getSignedCookie = async (header, secret, key, prefix) => {\n  const cookie = header.get(\"cookie\");\n  if (!cookie) {\n    return void 0;\n  }\n  let finalKey = key;\n  if (prefix) {\n    if (prefix === \"secure\") {\n      finalKey = \"__Secure-\" + key;\n    } else if (prefix === \"host\") {\n      finalKey = \"__Host-\" + key;\n    }\n  }\n  const obj = await parseSigned(cookie, secret, finalKey);\n  return obj[finalKey];\n};\n\n// src/endpoint.ts\nfunction createEndpointCreator(opts) {\n  return (path, options, handler) => {\n    return createEndpoint(\n      path,\n      {\n        ...options,\n        use: [...options?.use || [], ...opts?.use || []]\n      },\n      handler\n    );\n  };\n}\nfunction createEndpoint(path, options, handler) {\n  let responseHeader = new Headers();\n  const handle = async (...ctx) => {\n    let internalCtx = {\n      setHeader(key, value) {\n        responseHeader.set(key, value);\n      },\n      setCookie(key, value, options2) {\n        setCookie(responseHeader, key, value, options2);\n      },\n      getCookie(key, prefix) {\n        const header = ctx[0]?.headers;\n        const cookieH = header?.get(\"cookie\");\n        const cookie = getCookie(cookieH || \"\", key, prefix);\n        return cookie;\n      },\n      getSignedCookie(key, secret, prefix) {\n        const header = ctx[0]?.headers;\n        if (!header) {\n          throw new TypeError(\"Headers are required\");\n        }\n        const cookie = getSignedCookie(header, secret, key, prefix);\n        return cookie;\n      },\n      async setSignedCookie(key, value, secret, options2) {\n        await setSignedCookie(responseHeader, key, value, secret, options2);\n      },\n      redirect(url) {\n        responseHeader.set(\"Location\", url);\n        return new APIError(\"FOUND\");\n      },\n      json,\n      context: ctx[0]?.context || {},\n      _flag: ctx[0]?.asResponse ? \"router\" : ctx[0]?._flag,\n      responseHeader,\n      path,\n      ...ctx[0] || {}\n    };\n    if (options.use?.length) {\n      let middlewareContexts = {};\n      let middlewareBody = {};\n      for (const middleware of options.use) {\n        if (typeof middleware !== \"function\") {\n          console.warn(\"Middleware is not a function\", {\n            middleware\n          });\n          continue;\n        }\n        const res = await middleware(internalCtx);\n        if (res) {\n          const body = res.options?.body ? res.options.body.parse(internalCtx.body) : void 0;\n          middlewareContexts = {\n            ...middlewareContexts,\n            ...res\n          };\n          middlewareBody = {\n            ...middlewareBody,\n            ...body\n          };\n        }\n      }\n      internalCtx = {\n        ...internalCtx,\n        body: {\n          ...middlewareBody,\n          ...internalCtx.body\n        },\n        context: {\n          ...internalCtx.context || {},\n          ...middlewareContexts\n        }\n      };\n    }\n    try {\n      const body = options.body ? options.body.parse(internalCtx.body) : internalCtx.body;\n      internalCtx = {\n        ...internalCtx,\n        body: body ? {\n          ...body,\n          ...internalCtx.body\n        } : internalCtx.body\n      };\n      internalCtx.query = options.query ? options.query.parse(internalCtx.query) : internalCtx.query;\n    } catch (e) {\n      if (e instanceof zod__WEBPACK_IMPORTED_MODULE_1__.ZodError) {\n        throw new APIError(\"BAD_REQUEST\", {\n          message: e.message,\n          details: e.errors\n        });\n      }\n      throw e;\n    }\n    if (options.requireHeaders && !internalCtx.headers) {\n      throw new APIError(\"BAD_REQUEST\", {\n        message: \"Headers are required\"\n      });\n    }\n    if (options.requireRequest && !internalCtx.request) {\n      throw new APIError(\"BAD_REQUEST\", {\n        message: \"Request is required\"\n      });\n    }\n    if (internalCtx.request && !internalCtx.headers) {\n      internalCtx.headers = internalCtx.request.headers;\n    }\n    try {\n      let res = await handler(internalCtx);\n      let actualResponse = res;\n      if (res && typeof res === \"object\" && \"_flag\" in res) {\n        if (res._flag === \"json\" && internalCtx._flag === \"router\") {\n          const h = res.response.headers;\n          Object.keys(h || {}).forEach((key) => {\n            responseHeader.set(key, h[key]);\n          });\n          responseHeader.set(\"Content-Type\", \"application/json\");\n          actualResponse = new Response(JSON.stringify(res.response.body), {\n            status: res.response.status ?? 200,\n            statusText: res.response.statusText,\n            headers: responseHeader\n          });\n        } else {\n          actualResponse = res.body;\n        }\n      }\n      responseHeader = new Headers();\n      return actualResponse;\n    } catch (e) {\n      if (e instanceof APIError) {\n        responseHeader.set(\"Content-Type\", \"application/json\");\n        e.headers = responseHeader;\n        responseHeader = new Headers();\n        throw e;\n      }\n      throw e;\n    }\n  };\n  handle.path = path;\n  handle.options = options;\n  handle.method = options.method;\n  handle.headers = responseHeader;\n  return handle;\n}\n\n// src/router.ts\n\n\n// src/utils.ts\nasync function getBody(request) {\n  const contentType = request.headers.get(\"content-type\") || \"\";\n  if (!request.body) {\n    return void 0;\n  }\n  if (contentType.includes(\"application/json\")) {\n    return await request.json();\n  }\n  if (contentType.includes(\"application/x-www-form-urlencoded\")) {\n    const formData = await request.formData();\n    const result = {};\n    formData.forEach((value, key) => {\n      result[key] = value.toString();\n    });\n    return result;\n  }\n  if (contentType.includes(\"multipart/form-data\")) {\n    const formData = await request.formData();\n    const result = {};\n    formData.forEach((value, key) => {\n      result[key] = value;\n    });\n    return result;\n  }\n  if (contentType.includes(\"text/plain\")) {\n    return await request.text();\n  }\n  if (contentType.includes(\"application/octet-stream\")) {\n    return await request.arrayBuffer();\n  }\n  if (contentType.includes(\"application/pdf\") || contentType.includes(\"image/\") || contentType.includes(\"video/\")) {\n    const blob = await request.blob();\n    return blob;\n  }\n  if (contentType.includes(\"application/stream\") || request.body instanceof ReadableStream) {\n    return request.body;\n  }\n  return await request.text();\n}\nfunction shouldSerialize(body) {\n  return typeof body === \"object\" && body !== null && !(body instanceof Blob) && !(body instanceof FormData);\n}\nvar statusCode = {\n  OK: 200,\n  CREATED: 201,\n  ACCEPTED: 202,\n  NO_CONTENT: 204,\n  MULTIPLE_CHOICES: 300,\n  MOVED_PERMANENTLY: 301,\n  FOUND: 302,\n  SEE_OTHER: 303,\n  NOT_MODIFIED: 304,\n  TEMPORARY_REDIRECT: 307,\n  BAD_REQUEST: 400,\n  UNAUTHORIZED: 401,\n  PAYMENT_REQUIRED: 402,\n  FORBIDDEN: 403,\n  NOT_FOUND: 404,\n  METHOD_NOT_ALLOWED: 405,\n  NOT_ACCEPTABLE: 406,\n  PROXY_AUTHENTICATION_REQUIRED: 407,\n  REQUEST_TIMEOUT: 408,\n  CONFLICT: 409,\n  GONE: 410,\n  LENGTH_REQUIRED: 411,\n  PRECONDITION_FAILED: 412,\n  PAYLOAD_TOO_LARGE: 413,\n  URI_TOO_LONG: 414,\n  UNSUPPORTED_MEDIA_TYPE: 415,\n  RANGE_NOT_SATISFIABLE: 416,\n  EXPECTATION_FAILED: 417,\n  \"I'M_A_TEAPOT\": 418,\n  MISDIRECTED_REQUEST: 421,\n  UNPROCESSABLE_ENTITY: 422,\n  LOCKED: 423,\n  FAILED_DEPENDENCY: 424,\n  TOO_EARLY: 425,\n  UPGRADE_REQUIRED: 426,\n  PRECONDITION_REQUIRED: 428,\n  TOO_MANY_REQUESTS: 429,\n  REQUEST_HEADER_FIELDS_TOO_LARGE: 431,\n  UNAVAILABLE_FOR_LEGAL_REASONS: 451,\n  INTERNAL_SERVER_ERROR: 500,\n  NOT_IMPLEMENTED: 501,\n  BAD_GATEWAY: 502,\n  SERVICE_UNAVAILABLE: 503,\n  GATEWAY_TIMEOUT: 504,\n  HTTP_VERSION_NOT_SUPPORTED: 505,\n  VARIANT_ALSO_NEGOTIATES: 506,\n  INSUFFICIENT_STORAGE: 507,\n  LOOP_DETECTED: 508,\n  NOT_EXTENDED: 510,\n  NETWORK_AUTHENTICATION_REQUIRED: 511\n};\n\n// src/router.ts\nvar createRouter = (endpoints, config) => {\n  const _endpoints = Object.values(endpoints);\n  const router = (0,rou3__WEBPACK_IMPORTED_MODULE_2__.createRouter)();\n  for (const endpoint of _endpoints) {\n    if (endpoint.options.metadata?.SERVER_ONLY) continue;\n    if (Array.isArray(endpoint.options?.method)) {\n      for (const method of endpoint.options.method) {\n        (0,rou3__WEBPACK_IMPORTED_MODULE_2__.addRoute)(router, method, endpoint.path, endpoint);\n      }\n    } else {\n      (0,rou3__WEBPACK_IMPORTED_MODULE_2__.addRoute)(router, endpoint.options.method, endpoint.path, endpoint);\n    }\n  }\n  const middlewareRouter = (0,rou3__WEBPACK_IMPORTED_MODULE_2__.createRouter)();\n  for (const route of config?.routerMiddleware || []) {\n    (0,rou3__WEBPACK_IMPORTED_MODULE_2__.addRoute)(middlewareRouter, \"*\", route.path, route.middleware);\n  }\n  const handler = async (request) => {\n    const url = new URL(request.url);\n    let path = url.pathname;\n    if (config?.basePath) {\n      path = path.split(config.basePath)[1];\n    }\n    if (!path?.length) {\n      config?.onError?.(new APIError(\"NOT_FOUND\"));\n      console.warn(\n        `[better-call]: Make sure the URL has the basePath (${config?.basePath}).`\n      );\n      return new Response(null, {\n        status: 404,\n        statusText: \"Not Found\"\n      });\n    }\n    const method = request.method;\n    const route = (0,rou3__WEBPACK_IMPORTED_MODULE_2__.findRoute)(router, method, path);\n    const handler2 = route?.data;\n    const body = await getBody(request);\n    const headers = request.headers;\n    const query = Object.fromEntries(url.searchParams);\n    const routerMiddleware = (0,rou3__WEBPACK_IMPORTED_MODULE_2__.findAllRoutes)(middlewareRouter, \"*\", path);\n    if (!handler2) {\n      return new Response(null, {\n        status: 404,\n        statusText: \"Not Found\"\n      });\n    }\n    try {\n      let middlewareContext = {};\n      if (routerMiddleware?.length) {\n        for (const route2 of routerMiddleware) {\n          const middleware = route2.data;\n          const res = await middleware({\n            path,\n            method,\n            headers,\n            params: route2?.params,\n            request,\n            body,\n            query,\n            context: {\n              ...config?.extraContext\n            }\n          });\n          if (res instanceof Response) {\n            return res;\n          }\n          if (res?._flag === \"json\") {\n            return new Response(JSON.stringify(res), {\n              headers: res.headers\n            });\n          }\n          if (res) {\n            middlewareContext = {\n              ...res,\n              ...middlewareContext\n            };\n          }\n        }\n      }\n      const handlerRes = await handler2({\n        path,\n        method,\n        headers,\n        params: route?.params,\n        request,\n        body,\n        query,\n        _flag: \"router\",\n        context: {\n          ...middlewareContext,\n          ...config?.extraContext\n        }\n      });\n      if (handlerRes instanceof Response) {\n        return handlerRes;\n      }\n      const resBody = shouldSerialize(handlerRes) ? JSON.stringify(handlerRes) : handlerRes;\n      return new Response(resBody, {\n        headers: handler2.headers\n      });\n    } catch (e) {\n      if (config?.onError) {\n        const onErrorRes = await config.onError(e);\n        if (onErrorRes instanceof Response) {\n          return onErrorRes;\n        }\n      }\n      if (e instanceof APIError) {\n        return new Response(e.body ? JSON.stringify(e.body) : null, {\n          status: statusCode[e.status],\n          statusText: e.status,\n          headers: e.headers\n        });\n      }\n      if (config?.throwError) {\n        throw e;\n      }\n      return new Response(null, {\n        status: 500,\n        statusText: \"Internal Server Error\"\n      });\n    }\n  };\n  return {\n    handler: async (request) => {\n      const onReq = await config?.onRequest?.(request);\n      if (onReq instanceof Response) {\n        return onReq;\n      }\n      const req = onReq instanceof Request ? onReq : request;\n      const res = await handler(req);\n      const onRes = await config?.onResponse?.(res);\n      if (onRes instanceof Response) {\n        return onRes;\n      }\n      return res;\n    },\n    endpoints\n  };\n};\n\n// src/middleware.ts\nfunction createMiddleware(optionsOrHandler, handler) {\n  if (typeof optionsOrHandler === \"function\") {\n    return createEndpoint(\n      \"*\",\n      {\n        method: \"*\"\n      },\n      optionsOrHandler\n    );\n  }\n  if (!handler) {\n    throw new Error(\"Middleware handler is required\");\n  }\n  const endpoint = createEndpoint(\n    \"*\",\n    {\n      ...optionsOrHandler,\n      method: \"*\"\n    },\n    handler\n  );\n  return endpoint;\n}\nvar createMiddlewareCreator = (opts) => {\n  function fn(optionsOrHandler, handler) {\n    if (typeof optionsOrHandler === \"function\") {\n      return createEndpoint(\n        \"*\",\n        {\n          method: \"*\"\n        },\n        optionsOrHandler\n      );\n    }\n    if (!handler) {\n      throw new Error(\"Middleware handler is required\");\n    }\n    const endpoint = createEndpoint(\n      \"*\",\n      {\n        ...optionsOrHandler,\n        method: \"*\"\n      },\n      handler\n    );\n    return endpoint;\n  }\n  return fn;\n};\n\n// src/types.ts\n\n\n// src/adapter/request.ts\n\nfunction get_raw_body(req, body_size_limit) {\n  const h = req.headers;\n  if (!h[\"content-type\"]) return null;\n  const content_length = Number(h[\"content-length\"]);\n  if (req.httpVersionMajor === 1 && isNaN(content_length) && h[\"transfer-encoding\"] == null || content_length === 0) {\n    return null;\n  }\n  let length = content_length;\n  if (body_size_limit) {\n    if (!length) {\n      length = body_size_limit;\n    } else if (length > body_size_limit) {\n      throw Error(\n        `Received content-length of ${length}, but only accept up to ${body_size_limit} bytes.`\n      );\n    }\n  }\n  if (req.destroyed) {\n    const readable = new ReadableStream();\n    readable.cancel();\n    return readable;\n  }\n  let size = 0;\n  let cancelled = false;\n  return new ReadableStream({\n    start(controller) {\n      req.on(\"error\", (error) => {\n        cancelled = true;\n        controller.error(error);\n      });\n      req.on(\"end\", () => {\n        if (cancelled) return;\n        controller.close();\n      });\n      req.on(\"data\", (chunk) => {\n        if (cancelled) return;\n        size += chunk.length;\n        if (size > length) {\n          cancelled = true;\n          controller.error(\n            new Error(\n              `request body size exceeded ${content_length ? \"'content-length'\" : \"BODY_SIZE_LIMIT\"} of ${length}`\n            )\n          );\n          return;\n        }\n        controller.enqueue(chunk);\n        if (controller.desiredSize === null || controller.desiredSize <= 0) {\n          req.pause();\n        }\n      });\n    },\n    pull() {\n      req.resume();\n    },\n    cancel(reason) {\n      cancelled = true;\n      req.destroy(reason);\n    }\n  });\n}\nfunction getRequest({\n  request,\n  base,\n  bodySizeLimit\n}) {\n  return new Request(base + request.url, {\n    // @ts-expect-error\n    duplex: \"half\",\n    method: request.method,\n    body: get_raw_body(request, bodySizeLimit),\n    headers: request.headers\n  });\n}\nasync function setResponse(res, response) {\n  for (const [key, value] of response.headers) {\n    try {\n      res.setHeader(\n        key,\n        key === \"set-cookie\" ? set_cookie_parser__WEBPACK_IMPORTED_MODULE_3__.splitCookiesString(response.headers.get(key)) : value\n      );\n    } catch (error) {\n      res.getHeaderNames().forEach((name) => res.removeHeader(name));\n      res.writeHead(500).end(String(error));\n      return;\n    }\n  }\n  res.writeHead(response.status);\n  if (!response.body) {\n    res.end();\n    return;\n  }\n  if (response.body.locked) {\n    res.end(\n      \"Fatal error: Response body is locked. This can happen when the response was already read (for example through 'response.json()' or 'response.text()').\"\n    );\n    return;\n  }\n  const reader = response.body.getReader();\n  if (res.destroyed) {\n    reader.cancel();\n    return;\n  }\n  const cancel = (error) => {\n    res.off(\"close\", cancel);\n    res.off(\"error\", cancel);\n    reader.cancel(error).catch(() => {\n    });\n    if (error) res.destroy(error);\n  };\n  res.on(\"close\", cancel);\n  res.on(\"error\", cancel);\n  next();\n  async function next() {\n    try {\n      for (; ; ) {\n        const { done, value } = await reader.read();\n        if (done) break;\n        if (!res.write(value)) {\n          res.once(\"drain\", next);\n          return;\n        }\n      }\n      res.end();\n    } catch (error) {\n      cancel(error instanceof Error ? error : new Error(String(error)));\n    }\n  }\n}\n\n// src/adapter/node.ts\nfunction toNodeHandler(handler) {\n  return async (req, res) => {\n    const protocol = req.headers[\"x-forwarded-proto\"] || (req.socket.encrypted ? \"https\" : \"http\");\n    const base = `${protocol}://${req.headers[\":authority\"] || req.headers.host}`;\n    const response = await handler(getRequest({ base, request: req }));\n    setResponse(res, response);\n  };\n}\n\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uLi8uLi8uLi9ub2RlX21vZHVsZXMvYmV0dGVyLWNhbGwvZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0EsOEVBQThFLDZEQUE2RDtBQUMzSTs7QUFFQTtBQUMrQjs7QUFFL0I7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFFBQVEsRUFBRSxvQkFBb0I7QUFDdEQ7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ2tDO0FBQ2xDLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0EsZUFBZSw0Q0FBTTtBQUNyQjtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsNENBQU07QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELFNBQVM7QUFDM0Q7QUFDQTtBQUNBLGlCQUFpQiw0Q0FBTTtBQUN2QixJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsSUFBSTtBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDLGtCQUFrQixLQUFLLEdBQUcsTUFBTTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNhOztBQUViO0FBQ3VEO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxzQ0FBc0MsT0FBTywwQkFBMEIsaUJBQWlCO0FBQ3hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMseURBQXlELEtBQUssT0FBTztBQUNqSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixpRUFBb0M7QUFDbkU7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2YsZ0JBQWdCLGNBQWM7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsU0FBUyxLQUFLLDhDQUE4QztBQUNoRixnREFBZ0Qsb0JBQW9CO0FBQ3BFO0FBQ0E7QUFDQTtBQXdCRTtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQGhlbHNhL2FwcC8uLi8uLi8uLi9ub2RlX21vZHVsZXMvYmV0dGVyLWNhbGwvZGlzdC9pbmRleC5qcz9mOTQzIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19kZWZOb3JtYWxQcm9wID0gKG9iaiwga2V5LCB2YWx1ZSkgPT4ga2V5IGluIG9iaiA/IF9fZGVmUHJvcChvYmosIGtleSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlLCB2YWx1ZSB9KSA6IG9ialtrZXldID0gdmFsdWU7XG52YXIgX19wdWJsaWNGaWVsZCA9IChvYmosIGtleSwgdmFsdWUpID0+IF9fZGVmTm9ybWFsUHJvcChvYmosIHR5cGVvZiBrZXkgIT09IFwic3ltYm9sXCIgPyBrZXkgKyBcIlwiIDoga2V5LCB2YWx1ZSk7XG5cbi8vIHNyYy9lbmRwb2ludC50c1xuaW1wb3J0IHsgWm9kRXJyb3IgfSBmcm9tIFwiem9kXCI7XG5cbi8vIHNyYy9lcnJvci50c1xudmFyIEFQSUVycm9yID0gY2xhc3MgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKHN0YXR1cywgYm9keSwgaGVhZGVycykge1xuICAgIHN1cGVyKGBBUEkgRXJyb3I6ICR7c3RhdHVzfSAke2JvZHk/Lm1lc3NhZ2UgPz8gXCJcIn1gLCB7XG4gICAgICBjYXVzZTogYm9keVxuICAgIH0pO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJzdGF0dXNcIik7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImhlYWRlcnNcIik7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImJvZHlcIik7XG4gICAgdGhpcy5zdGF0dXMgPSBzdGF0dXM7XG4gICAgdGhpcy5ib2R5ID0gYm9keSA/PyB7fTtcbiAgICB0aGlzLmJvZHkuY29kZSA9IGJvZHk/Lm1lc3NhZ2UgPyBib2R5Lm1lc3NhZ2UudG9VcHBlckNhc2UoKS5yZXBsYWNlKC8gL2csIFwiX1wiKS5yZXBsYWNlKC9bXkEtWjAtOV9dL2csIFwiXCIpIDogc3RhdHVzO1xuICAgIHRoaXMuc3RhY2sgPSBcIlwiO1xuICAgIHRoaXMuaGVhZGVycyA9IGhlYWRlcnMgPz8gbmV3IEhlYWRlcnMoKTtcbiAgICBpZiAoIXRoaXMuaGVhZGVycy5oYXMoXCJDb250ZW50LVR5cGVcIikpIHtcbiAgICAgIHRoaXMuaGVhZGVycy5zZXQoXCJDb250ZW50LVR5cGVcIiwgXCJhcHBsaWNhdGlvbi9qc29uXCIpO1xuICAgIH1cbiAgICB0aGlzLm5hbWUgPSBcIkJldHRlckNhbGxBUElFcnJvclwiO1xuICB9XG59O1xuXG4vLyBzcmMvaGVscGVyLnRzXG52YXIganNvbiA9IChib2R5LCBvcHRpb24pID0+IHtcbiAgcmV0dXJuIHtcbiAgICByZXNwb25zZToge1xuICAgICAgYm9keTogb3B0aW9uPy5ib2R5ID8/IGJvZHksXG4gICAgICBzdGF0dXM6IG9wdGlvbj8uc3RhdHVzID8/IDIwMCxcbiAgICAgIHN0YXR1c1RleHQ6IG9wdGlvbj8uc3RhdHVzVGV4dCA/PyBcIk9LXCIsXG4gICAgICBoZWFkZXJzOiBvcHRpb24/LmhlYWRlcnNcbiAgICB9LFxuICAgIGJvZHksXG4gICAgX2ZsYWc6IFwianNvblwiXG4gIH07XG59O1xuXG4vLyBzcmMvY29va2llLnRzXG5pbXBvcnQgeyBzdWJ0bGUgfSBmcm9tIFwidW5jcnlwdG9cIjtcbnZhciBhbGdvcml0aG0gPSB7IG5hbWU6IFwiSE1BQ1wiLCBoYXNoOiBcIlNIQS0yNTZcIiB9O1xudmFyIGdldENyeXB0b0tleSA9IGFzeW5jIChzZWNyZXQpID0+IHtcbiAgY29uc3Qgc2VjcmV0QnVmID0gdHlwZW9mIHNlY3JldCA9PT0gXCJzdHJpbmdcIiA/IG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZShzZWNyZXQpIDogc2VjcmV0O1xuICByZXR1cm4gYXdhaXQgc3VidGxlLmltcG9ydEtleShcInJhd1wiLCBzZWNyZXRCdWYsIGFsZ29yaXRobSwgZmFsc2UsIFtcInNpZ25cIiwgXCJ2ZXJpZnlcIl0pO1xufTtcbnZhciBtYWtlU2lnbmF0dXJlID0gYXN5bmMgKHZhbHVlLCBzZWNyZXQpID0+IHtcbiAgY29uc3Qga2V5ID0gYXdhaXQgZ2V0Q3J5cHRvS2V5KHNlY3JldCk7XG4gIGNvbnN0IHNpZ25hdHVyZSA9IGF3YWl0IHN1YnRsZS5zaWduKGFsZ29yaXRobS5uYW1lLCBrZXksIG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZSh2YWx1ZSkpO1xuICByZXR1cm4gYnRvYShTdHJpbmcuZnJvbUNoYXJDb2RlKC4uLm5ldyBVaW50OEFycmF5KHNpZ25hdHVyZSkpKTtcbn07XG52YXIgdmVyaWZ5U2lnbmF0dXJlID0gYXN5bmMgKGJhc2U2NFNpZ25hdHVyZSwgdmFsdWUsIHNlY3JldCkgPT4ge1xuICB0cnkge1xuICAgIGNvbnN0IHNpZ25hdHVyZUJpblN0ciA9IGF0b2IoYmFzZTY0U2lnbmF0dXJlKTtcbiAgICBjb25zdCBzaWduYXR1cmUgPSBuZXcgVWludDhBcnJheShzaWduYXR1cmVCaW5TdHIubGVuZ3RoKTtcbiAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gc2lnbmF0dXJlQmluU3RyLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBzaWduYXR1cmVbaV0gPSBzaWduYXR1cmVCaW5TdHIuY2hhckNvZGVBdChpKTtcbiAgICB9XG4gICAgcmV0dXJuIGF3YWl0IHN1YnRsZS52ZXJpZnkoYWxnb3JpdGhtLCBzZWNyZXQsIHNpZ25hdHVyZSwgbmV3IFRleHRFbmNvZGVyKCkuZW5jb2RlKHZhbHVlKSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn07XG52YXIgdmFsaWRDb29raWVOYW1lUmVnRXggPSAvXltcXHchIyQlJicqLl5gfH4rLV0rJC87XG52YXIgdmFsaWRDb29raWVWYWx1ZVJlZ0V4ID0gL15bICEjLTo8LVtcXF0tfl0qJC87XG52YXIgcGFyc2UgPSAoY29va2llLCBuYW1lKSA9PiB7XG4gIGNvbnN0IHBhaXJzID0gY29va2llLnRyaW0oKS5zcGxpdChcIjtcIik7XG4gIHJldHVybiBwYWlycy5yZWR1Y2UoKHBhcnNlZENvb2tpZSwgcGFpclN0cikgPT4ge1xuICAgIHBhaXJTdHIgPSBwYWlyU3RyLnRyaW0oKTtcbiAgICBjb25zdCB2YWx1ZVN0YXJ0UG9zID0gcGFpclN0ci5pbmRleE9mKFwiPVwiKTtcbiAgICBpZiAodmFsdWVTdGFydFBvcyA9PT0gLTEpIHtcbiAgICAgIHJldHVybiBwYXJzZWRDb29raWU7XG4gICAgfVxuICAgIGNvbnN0IGNvb2tpZU5hbWUgPSBwYWlyU3RyLnN1YnN0cmluZygwLCB2YWx1ZVN0YXJ0UG9zKS50cmltKCk7XG4gICAgaWYgKG5hbWUgJiYgbmFtZSAhPT0gY29va2llTmFtZSB8fCAhdmFsaWRDb29raWVOYW1lUmVnRXgudGVzdChjb29raWVOYW1lKSkge1xuICAgICAgcmV0dXJuIHBhcnNlZENvb2tpZTtcbiAgICB9XG4gICAgbGV0IGNvb2tpZVZhbHVlID0gcGFpclN0ci5zdWJzdHJpbmcodmFsdWVTdGFydFBvcyArIDEpLnRyaW0oKTtcbiAgICBpZiAoY29va2llVmFsdWUuc3RhcnRzV2l0aCgnXCInKSAmJiBjb29raWVWYWx1ZS5lbmRzV2l0aCgnXCInKSkge1xuICAgICAgY29va2llVmFsdWUgPSBjb29raWVWYWx1ZS5zbGljZSgxLCAtMSk7XG4gICAgfVxuICAgIGlmICh2YWxpZENvb2tpZVZhbHVlUmVnRXgudGVzdChjb29raWVWYWx1ZSkpIHtcbiAgICAgIHBhcnNlZENvb2tpZVtjb29raWVOYW1lXSA9IGRlY29kZVVSSUNvbXBvbmVudChjb29raWVWYWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiBwYXJzZWRDb29raWU7XG4gIH0sIHt9KTtcbn07XG52YXIgcGFyc2VTaWduZWQgPSBhc3luYyAoY29va2llLCBzZWNyZXQsIG5hbWUpID0+IHtcbiAgY29uc3QgcGFyc2VkQ29va2llID0ge307XG4gIGNvbnN0IHNlY3JldEtleSA9IGF3YWl0IGdldENyeXB0b0tleShzZWNyZXQpO1xuICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhwYXJzZShjb29raWUsIG5hbWUpKSkge1xuICAgIGNvbnN0IHNpZ25hdHVyZVN0YXJ0UG9zID0gdmFsdWUubGFzdEluZGV4T2YoXCIuXCIpO1xuICAgIGlmIChzaWduYXR1cmVTdGFydFBvcyA8IDEpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBjb25zdCBzaWduZWRWYWx1ZSA9IHZhbHVlLnN1YnN0cmluZygwLCBzaWduYXR1cmVTdGFydFBvcyk7XG4gICAgY29uc3Qgc2lnbmF0dXJlID0gdmFsdWUuc3Vic3RyaW5nKHNpZ25hdHVyZVN0YXJ0UG9zICsgMSk7XG4gICAgaWYgKHNpZ25hdHVyZS5sZW5ndGggIT09IDQ0IHx8ICFzaWduYXR1cmUuZW5kc1dpdGgoXCI9XCIpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgY29uc3QgaXNWZXJpZmllZCA9IGF3YWl0IHZlcmlmeVNpZ25hdHVyZShzaWduYXR1cmUsIHNpZ25lZFZhbHVlLCBzZWNyZXRLZXkpO1xuICAgIHBhcnNlZENvb2tpZVtrZXldID0gaXNWZXJpZmllZCA/IHNpZ25lZFZhbHVlIDogZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHBhcnNlZENvb2tpZTtcbn07XG52YXIgX3NlcmlhbGl6ZSA9IChuYW1lLCB2YWx1ZSwgb3B0ID0ge30pID0+IHtcbiAgbGV0IGNvb2tpZSA9IGAke25hbWV9PSR7dmFsdWV9YDtcbiAgaWYgKG5hbWUuc3RhcnRzV2l0aChcIl9fU2VjdXJlLVwiKSAmJiAhb3B0LnNlY3VyZSkge1xuICAgIG9wdC5zZWN1cmUgPSB0cnVlO1xuICB9XG4gIGlmIChuYW1lLnN0YXJ0c1dpdGgoXCJfX0hvc3QtXCIpKSB7XG4gICAgaWYgKCFvcHQuc2VjdXJlKSB7XG4gICAgICBvcHQuc2VjdXJlID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKG9wdC5wYXRoICE9PSBcIi9cIikge1xuICAgICAgb3B0LnBhdGggPSBcIi9cIjtcbiAgICB9XG4gICAgaWYgKG9wdC5kb21haW4pIHtcbiAgICAgIG9wdC5kb21haW4gPSB2b2lkIDA7XG4gICAgfVxuICB9XG4gIGlmIChvcHQgJiYgdHlwZW9mIG9wdC5tYXhBZ2UgPT09IFwibnVtYmVyXCIgJiYgb3B0Lm1heEFnZSA+PSAwKSB7XG4gICAgaWYgKG9wdC5tYXhBZ2UgPiAzNDU2ZTQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgXCJDb29raWVzIE1heC1BZ2UgU0hPVUxEIE5PVCBiZSBncmVhdGVyIHRoYW4gNDAwIGRheXMgKDM0NTYwMDAwIHNlY29uZHMpIGluIGR1cmF0aW9uLlwiXG4gICAgICApO1xuICAgIH1cbiAgICBjb29raWUgKz0gYDsgTWF4LUFnZT0ke01hdGguZmxvb3Iob3B0Lm1heEFnZSl9YDtcbiAgfVxuICBpZiAob3B0LmRvbWFpbiAmJiBvcHQucHJlZml4ICE9PSBcImhvc3RcIikge1xuICAgIGNvb2tpZSArPSBgOyBEb21haW49JHtvcHQuZG9tYWlufWA7XG4gIH1cbiAgaWYgKG9wdC5wYXRoKSB7XG4gICAgY29va2llICs9IGA7IFBhdGg9JHtvcHQucGF0aH1gO1xuICB9XG4gIGlmIChvcHQuZXhwaXJlcykge1xuICAgIGlmIChvcHQuZXhwaXJlcy5nZXRUaW1lKCkgLSBEYXRlLm5vdygpID4gMzQ1NmU3KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIFwiQ29va2llcyBFeHBpcmVzIFNIT1VMRCBOT1QgYmUgZ3JlYXRlciB0aGFuIDQwMCBkYXlzICgzNDU2MDAwMCBzZWNvbmRzKSBpbiB0aGUgZnV0dXJlLlwiXG4gICAgICApO1xuICAgIH1cbiAgICBjb29raWUgKz0gYDsgRXhwaXJlcz0ke29wdC5leHBpcmVzLnRvVVRDU3RyaW5nKCl9YDtcbiAgfVxuICBpZiAob3B0Lmh0dHBPbmx5KSB7XG4gICAgY29va2llICs9IFwiOyBIdHRwT25seVwiO1xuICB9XG4gIGlmIChvcHQuc2VjdXJlKSB7XG4gICAgY29va2llICs9IFwiOyBTZWN1cmVcIjtcbiAgfVxuICBpZiAob3B0LnNhbWVTaXRlKSB7XG4gICAgY29va2llICs9IGA7IFNhbWVTaXRlPSR7b3B0LnNhbWVTaXRlLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgb3B0LnNhbWVTaXRlLnNsaWNlKDEpfWA7XG4gIH1cbiAgaWYgKG9wdC5wYXJ0aXRpb25lZCkge1xuICAgIGlmICghb3B0LnNlY3VyZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUGFydGl0aW9uZWQgQ29va2llIG11c3QgaGF2ZSBTZWN1cmUgYXR0cmlidXRlc1wiKTtcbiAgICB9XG4gICAgY29va2llICs9IFwiOyBQYXJ0aXRpb25lZFwiO1xuICB9XG4gIHJldHVybiBjb29raWU7XG59O1xudmFyIHNlcmlhbGl6ZSA9IChuYW1lLCB2YWx1ZSwgb3B0KSA9PiB7XG4gIHZhbHVlID0gZW5jb2RlVVJJQ29tcG9uZW50KHZhbHVlKTtcbiAgcmV0dXJuIF9zZXJpYWxpemUobmFtZSwgdmFsdWUsIG9wdCk7XG59O1xudmFyIHNlcmlhbGl6ZVNpZ25lZCA9IGFzeW5jIChuYW1lLCB2YWx1ZSwgc2VjcmV0LCBvcHQgPSB7fSkgPT4ge1xuICBjb25zdCBzaWduYXR1cmUgPSBhd2FpdCBtYWtlU2lnbmF0dXJlKHZhbHVlLCBzZWNyZXQpO1xuICB2YWx1ZSA9IGAke3ZhbHVlfS4ke3NpZ25hdHVyZX1gO1xuICB2YWx1ZSA9IGVuY29kZVVSSUNvbXBvbmVudCh2YWx1ZSk7XG4gIHJldHVybiBfc2VyaWFsaXplKG5hbWUsIHZhbHVlLCBvcHQpO1xufTtcbnZhciBzaWduQ29va2llVmFsdWUgPSBhc3luYyAodmFsdWUsIHNlY3JldCkgPT4ge1xuICBjb25zdCBzaWduYXR1cmUgPSBhd2FpdCBtYWtlU2lnbmF0dXJlKHZhbHVlLCBzZWNyZXQpO1xuICB2YWx1ZSA9IGAke3ZhbHVlfS4ke3NpZ25hdHVyZX1gO1xuICB2YWx1ZSA9IGVuY29kZVVSSUNvbXBvbmVudCh2YWx1ZSk7XG4gIHJldHVybiB2YWx1ZTtcbn07XG5cbi8vIHNyYy9jb29raWUtdXRpbHMudHNcbnZhciBnZXRDb29raWUgPSAoY29va2llLCBrZXksIHByZWZpeCkgPT4ge1xuICBpZiAoIWNvb2tpZSkge1xuICAgIHJldHVybiB2b2lkIDA7XG4gIH1cbiAgbGV0IGZpbmFsS2V5ID0ga2V5O1xuICBpZiAocHJlZml4KSB7XG4gICAgaWYgKHByZWZpeCA9PT0gXCJzZWN1cmVcIikge1xuICAgICAgZmluYWxLZXkgPSBcIl9fU2VjdXJlLVwiICsga2V5O1xuICAgIH0gZWxzZSBpZiAocHJlZml4ID09PSBcImhvc3RcIikge1xuICAgICAgZmluYWxLZXkgPSBcIl9fSG9zdC1cIiArIGtleTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICB9XG4gIH1cbiAgY29uc3Qgb2JqID0gcGFyc2UoY29va2llLCBmaW5hbEtleSk7XG4gIHJldHVybiBvYmpbZmluYWxLZXldO1xufTtcbnZhciBzZXRDb29raWUgPSAoaGVhZGVyLCBuYW1lLCB2YWx1ZSwgb3B0KSA9PiB7XG4gIGNvbnN0IGV4aXN0aW5nQ29va2llcyA9IGhlYWRlci5nZXQoXCJTZXQtQ29va2llXCIpO1xuICBpZiAoZXhpc3RpbmdDb29raWVzKSB7XG4gICAgY29uc3QgY29va2llcyA9IGV4aXN0aW5nQ29va2llcy5zcGxpdChcIiwgXCIpO1xuICAgIGNvbnN0IHVwZGF0ZWRDb29raWVzID0gY29va2llcy5maWx0ZXIoKGNvb2tpZTIpID0+ICFjb29raWUyLnN0YXJ0c1dpdGgoYCR7bmFtZX09YCkpO1xuICAgIGhlYWRlci5kZWxldGUoXCJTZXQtQ29va2llXCIpO1xuICAgIHVwZGF0ZWRDb29raWVzLmZvckVhY2goKGNvb2tpZTIpID0+IGhlYWRlci5hcHBlbmQoXCJTZXQtQ29va2llXCIsIGNvb2tpZTIpKTtcbiAgfVxuICBsZXQgY29va2llO1xuICBpZiAob3B0Py5wcmVmaXggPT09IFwic2VjdXJlXCIpIHtcbiAgICBjb29raWUgPSBzZXJpYWxpemUoXCJfX1NlY3VyZS1cIiArIG5hbWUsIHZhbHVlLCB7IHBhdGg6IFwiL1wiLCAuLi5vcHQsIHNlY3VyZTogdHJ1ZSB9KTtcbiAgfSBlbHNlIGlmIChvcHQ/LnByZWZpeCA9PT0gXCJob3N0XCIpIHtcbiAgICBjb29raWUgPSBzZXJpYWxpemUoXCJfX0hvc3QtXCIgKyBuYW1lLCB2YWx1ZSwge1xuICAgICAgLi4ub3B0LFxuICAgICAgcGF0aDogXCIvXCIsXG4gICAgICBzZWN1cmU6IHRydWUsXG4gICAgICBkb21haW46IHZvaWQgMFxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIGNvb2tpZSA9IHNlcmlhbGl6ZShuYW1lLCB2YWx1ZSwgeyBwYXRoOiBcIi9cIiwgLi4ub3B0IH0pO1xuICB9XG4gIGhlYWRlci5hcHBlbmQoXCJTZXQtQ29va2llXCIsIGNvb2tpZSk7XG59O1xudmFyIHNldFNpZ25lZENvb2tpZSA9IGFzeW5jIChoZWFkZXIsIG5hbWUsIHZhbHVlLCBzZWNyZXQsIG9wdCkgPT4ge1xuICBsZXQgY29va2llO1xuICBpZiAob3B0Py5wcmVmaXggPT09IFwic2VjdXJlXCIpIHtcbiAgICBjb29raWUgPSBhd2FpdCBzZXJpYWxpemVTaWduZWQoXCJfX1NlY3VyZS1cIiArIG5hbWUsIHZhbHVlLCBzZWNyZXQsIHtcbiAgICAgIHBhdGg6IFwiL1wiLFxuICAgICAgLi4ub3B0LFxuICAgICAgc2VjdXJlOiB0cnVlXG4gICAgfSk7XG4gIH0gZWxzZSBpZiAob3B0Py5wcmVmaXggPT09IFwiaG9zdFwiKSB7XG4gICAgY29va2llID0gYXdhaXQgc2VyaWFsaXplU2lnbmVkKFwiX19Ib3N0LVwiICsgbmFtZSwgdmFsdWUsIHNlY3JldCwge1xuICAgICAgLi4ub3B0LFxuICAgICAgcGF0aDogXCIvXCIsXG4gICAgICBzZWN1cmU6IHRydWUsXG4gICAgICBkb21haW46IHZvaWQgMFxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIGNvb2tpZSA9IGF3YWl0IHNlcmlhbGl6ZVNpZ25lZChuYW1lLCB2YWx1ZSwgc2VjcmV0LCB7IHBhdGg6IFwiL1wiLCAuLi5vcHQgfSk7XG4gIH1cbiAgaGVhZGVyLmFwcGVuZChcIlNldC1Db29raWVcIiwgY29va2llKTtcbn07XG52YXIgZ2V0U2lnbmVkQ29va2llID0gYXN5bmMgKGhlYWRlciwgc2VjcmV0LCBrZXksIHByZWZpeCkgPT4ge1xuICBjb25zdCBjb29raWUgPSBoZWFkZXIuZ2V0KFwiY29va2llXCIpO1xuICBpZiAoIWNvb2tpZSkge1xuICAgIHJldHVybiB2b2lkIDA7XG4gIH1cbiAgbGV0IGZpbmFsS2V5ID0ga2V5O1xuICBpZiAocHJlZml4KSB7XG4gICAgaWYgKHByZWZpeCA9PT0gXCJzZWN1cmVcIikge1xuICAgICAgZmluYWxLZXkgPSBcIl9fU2VjdXJlLVwiICsga2V5O1xuICAgIH0gZWxzZSBpZiAocHJlZml4ID09PSBcImhvc3RcIikge1xuICAgICAgZmluYWxLZXkgPSBcIl9fSG9zdC1cIiArIGtleTtcbiAgICB9XG4gIH1cbiAgY29uc3Qgb2JqID0gYXdhaXQgcGFyc2VTaWduZWQoY29va2llLCBzZWNyZXQsIGZpbmFsS2V5KTtcbiAgcmV0dXJuIG9ialtmaW5hbEtleV07XG59O1xuXG4vLyBzcmMvZW5kcG9pbnQudHNcbmZ1bmN0aW9uIGNyZWF0ZUVuZHBvaW50Q3JlYXRvcihvcHRzKSB7XG4gIHJldHVybiAocGF0aCwgb3B0aW9ucywgaGFuZGxlcikgPT4ge1xuICAgIHJldHVybiBjcmVhdGVFbmRwb2ludChcbiAgICAgIHBhdGgsXG4gICAgICB7XG4gICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgIHVzZTogWy4uLm9wdGlvbnM/LnVzZSB8fCBbXSwgLi4ub3B0cz8udXNlIHx8IFtdXVxuICAgICAgfSxcbiAgICAgIGhhbmRsZXJcbiAgICApO1xuICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlRW5kcG9pbnQocGF0aCwgb3B0aW9ucywgaGFuZGxlcikge1xuICBsZXQgcmVzcG9uc2VIZWFkZXIgPSBuZXcgSGVhZGVycygpO1xuICBjb25zdCBoYW5kbGUgPSBhc3luYyAoLi4uY3R4KSA9PiB7XG4gICAgbGV0IGludGVybmFsQ3R4ID0ge1xuICAgICAgc2V0SGVhZGVyKGtleSwgdmFsdWUpIHtcbiAgICAgICAgcmVzcG9uc2VIZWFkZXIuc2V0KGtleSwgdmFsdWUpO1xuICAgICAgfSxcbiAgICAgIHNldENvb2tpZShrZXksIHZhbHVlLCBvcHRpb25zMikge1xuICAgICAgICBzZXRDb29raWUocmVzcG9uc2VIZWFkZXIsIGtleSwgdmFsdWUsIG9wdGlvbnMyKTtcbiAgICAgIH0sXG4gICAgICBnZXRDb29raWUoa2V5LCBwcmVmaXgpIHtcbiAgICAgICAgY29uc3QgaGVhZGVyID0gY3R4WzBdPy5oZWFkZXJzO1xuICAgICAgICBjb25zdCBjb29raWVIID0gaGVhZGVyPy5nZXQoXCJjb29raWVcIik7XG4gICAgICAgIGNvbnN0IGNvb2tpZSA9IGdldENvb2tpZShjb29raWVIIHx8IFwiXCIsIGtleSwgcHJlZml4KTtcbiAgICAgICAgcmV0dXJuIGNvb2tpZTtcbiAgICAgIH0sXG4gICAgICBnZXRTaWduZWRDb29raWUoa2V5LCBzZWNyZXQsIHByZWZpeCkge1xuICAgICAgICBjb25zdCBoZWFkZXIgPSBjdHhbMF0/LmhlYWRlcnM7XG4gICAgICAgIGlmICghaGVhZGVyKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkhlYWRlcnMgYXJlIHJlcXVpcmVkXCIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNvb2tpZSA9IGdldFNpZ25lZENvb2tpZShoZWFkZXIsIHNlY3JldCwga2V5LCBwcmVmaXgpO1xuICAgICAgICByZXR1cm4gY29va2llO1xuICAgICAgfSxcbiAgICAgIGFzeW5jIHNldFNpZ25lZENvb2tpZShrZXksIHZhbHVlLCBzZWNyZXQsIG9wdGlvbnMyKSB7XG4gICAgICAgIGF3YWl0IHNldFNpZ25lZENvb2tpZShyZXNwb25zZUhlYWRlciwga2V5LCB2YWx1ZSwgc2VjcmV0LCBvcHRpb25zMik7XG4gICAgICB9LFxuICAgICAgcmVkaXJlY3QodXJsKSB7XG4gICAgICAgIHJlc3BvbnNlSGVhZGVyLnNldChcIkxvY2F0aW9uXCIsIHVybCk7XG4gICAgICAgIHJldHVybiBuZXcgQVBJRXJyb3IoXCJGT1VORFwiKTtcbiAgICAgIH0sXG4gICAgICBqc29uLFxuICAgICAgY29udGV4dDogY3R4WzBdPy5jb250ZXh0IHx8IHt9LFxuICAgICAgX2ZsYWc6IGN0eFswXT8uYXNSZXNwb25zZSA/IFwicm91dGVyXCIgOiBjdHhbMF0/Ll9mbGFnLFxuICAgICAgcmVzcG9uc2VIZWFkZXIsXG4gICAgICBwYXRoLFxuICAgICAgLi4uY3R4WzBdIHx8IHt9XG4gICAgfTtcbiAgICBpZiAob3B0aW9ucy51c2U/Lmxlbmd0aCkge1xuICAgICAgbGV0IG1pZGRsZXdhcmVDb250ZXh0cyA9IHt9O1xuICAgICAgbGV0IG1pZGRsZXdhcmVCb2R5ID0ge307XG4gICAgICBmb3IgKGNvbnN0IG1pZGRsZXdhcmUgb2Ygb3B0aW9ucy51c2UpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBtaWRkbGV3YXJlICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oXCJNaWRkbGV3YXJlIGlzIG5vdCBhIGZ1bmN0aW9uXCIsIHtcbiAgICAgICAgICAgIG1pZGRsZXdhcmVcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXMgPSBhd2FpdCBtaWRkbGV3YXJlKGludGVybmFsQ3R4KTtcbiAgICAgICAgaWYgKHJlcykge1xuICAgICAgICAgIGNvbnN0IGJvZHkgPSByZXMub3B0aW9ucz8uYm9keSA/IHJlcy5vcHRpb25zLmJvZHkucGFyc2UoaW50ZXJuYWxDdHguYm9keSkgOiB2b2lkIDA7XG4gICAgICAgICAgbWlkZGxld2FyZUNvbnRleHRzID0ge1xuICAgICAgICAgICAgLi4ubWlkZGxld2FyZUNvbnRleHRzLFxuICAgICAgICAgICAgLi4ucmVzXG4gICAgICAgICAgfTtcbiAgICAgICAgICBtaWRkbGV3YXJlQm9keSA9IHtcbiAgICAgICAgICAgIC4uLm1pZGRsZXdhcmVCb2R5LFxuICAgICAgICAgICAgLi4uYm9keVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGludGVybmFsQ3R4ID0ge1xuICAgICAgICAuLi5pbnRlcm5hbEN0eCxcbiAgICAgICAgYm9keToge1xuICAgICAgICAgIC4uLm1pZGRsZXdhcmVCb2R5LFxuICAgICAgICAgIC4uLmludGVybmFsQ3R4LmJvZHlcbiAgICAgICAgfSxcbiAgICAgICAgY29udGV4dDoge1xuICAgICAgICAgIC4uLmludGVybmFsQ3R4LmNvbnRleHQgfHwge30sXG4gICAgICAgICAgLi4ubWlkZGxld2FyZUNvbnRleHRzXG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICBjb25zdCBib2R5ID0gb3B0aW9ucy5ib2R5ID8gb3B0aW9ucy5ib2R5LnBhcnNlKGludGVybmFsQ3R4LmJvZHkpIDogaW50ZXJuYWxDdHguYm9keTtcbiAgICAgIGludGVybmFsQ3R4ID0ge1xuICAgICAgICAuLi5pbnRlcm5hbEN0eCxcbiAgICAgICAgYm9keTogYm9keSA/IHtcbiAgICAgICAgICAuLi5ib2R5LFxuICAgICAgICAgIC4uLmludGVybmFsQ3R4LmJvZHlcbiAgICAgICAgfSA6IGludGVybmFsQ3R4LmJvZHlcbiAgICAgIH07XG4gICAgICBpbnRlcm5hbEN0eC5xdWVyeSA9IG9wdGlvbnMucXVlcnkgPyBvcHRpb25zLnF1ZXJ5LnBhcnNlKGludGVybmFsQ3R4LnF1ZXJ5KSA6IGludGVybmFsQ3R4LnF1ZXJ5O1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGlmIChlIGluc3RhbmNlb2YgWm9kRXJyb3IpIHtcbiAgICAgICAgdGhyb3cgbmV3IEFQSUVycm9yKFwiQkFEX1JFUVVFU1RcIiwge1xuICAgICAgICAgIG1lc3NhZ2U6IGUubWVzc2FnZSxcbiAgICAgICAgICBkZXRhaWxzOiBlLmVycm9yc1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHRocm93IGU7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLnJlcXVpcmVIZWFkZXJzICYmICFpbnRlcm5hbEN0eC5oZWFkZXJzKSB7XG4gICAgICB0aHJvdyBuZXcgQVBJRXJyb3IoXCJCQURfUkVRVUVTVFwiLCB7XG4gICAgICAgIG1lc3NhZ2U6IFwiSGVhZGVycyBhcmUgcmVxdWlyZWRcIlxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLnJlcXVpcmVSZXF1ZXN0ICYmICFpbnRlcm5hbEN0eC5yZXF1ZXN0KSB7XG4gICAgICB0aHJvdyBuZXcgQVBJRXJyb3IoXCJCQURfUkVRVUVTVFwiLCB7XG4gICAgICAgIG1lc3NhZ2U6IFwiUmVxdWVzdCBpcyByZXF1aXJlZFwiXG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKGludGVybmFsQ3R4LnJlcXVlc3QgJiYgIWludGVybmFsQ3R4LmhlYWRlcnMpIHtcbiAgICAgIGludGVybmFsQ3R4LmhlYWRlcnMgPSBpbnRlcm5hbEN0eC5yZXF1ZXN0LmhlYWRlcnM7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICBsZXQgcmVzID0gYXdhaXQgaGFuZGxlcihpbnRlcm5hbEN0eCk7XG4gICAgICBsZXQgYWN0dWFsUmVzcG9uc2UgPSByZXM7XG4gICAgICBpZiAocmVzICYmIHR5cGVvZiByZXMgPT09IFwib2JqZWN0XCIgJiYgXCJfZmxhZ1wiIGluIHJlcykge1xuICAgICAgICBpZiAocmVzLl9mbGFnID09PSBcImpzb25cIiAmJiBpbnRlcm5hbEN0eC5fZmxhZyA9PT0gXCJyb3V0ZXJcIikge1xuICAgICAgICAgIGNvbnN0IGggPSByZXMucmVzcG9uc2UuaGVhZGVycztcbiAgICAgICAgICBPYmplY3Qua2V5cyhoIHx8IHt9KS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgICAgICAgIHJlc3BvbnNlSGVhZGVyLnNldChrZXksIGhba2V5XSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmVzcG9uc2VIZWFkZXIuc2V0KFwiQ29udGVudC1UeXBlXCIsIFwiYXBwbGljYXRpb24vanNvblwiKTtcbiAgICAgICAgICBhY3R1YWxSZXNwb25zZSA9IG5ldyBSZXNwb25zZShKU09OLnN0cmluZ2lmeShyZXMucmVzcG9uc2UuYm9keSksIHtcbiAgICAgICAgICAgIHN0YXR1czogcmVzLnJlc3BvbnNlLnN0YXR1cyA/PyAyMDAsXG4gICAgICAgICAgICBzdGF0dXNUZXh0OiByZXMucmVzcG9uc2Uuc3RhdHVzVGV4dCxcbiAgICAgICAgICAgIGhlYWRlcnM6IHJlc3BvbnNlSGVhZGVyXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYWN0dWFsUmVzcG9uc2UgPSByZXMuYm9keTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmVzcG9uc2VIZWFkZXIgPSBuZXcgSGVhZGVycygpO1xuICAgICAgcmV0dXJuIGFjdHVhbFJlc3BvbnNlO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGlmIChlIGluc3RhbmNlb2YgQVBJRXJyb3IpIHtcbiAgICAgICAgcmVzcG9uc2VIZWFkZXIuc2V0KFwiQ29udGVudC1UeXBlXCIsIFwiYXBwbGljYXRpb24vanNvblwiKTtcbiAgICAgICAgZS5oZWFkZXJzID0gcmVzcG9uc2VIZWFkZXI7XG4gICAgICAgIHJlc3BvbnNlSGVhZGVyID0gbmV3IEhlYWRlcnMoKTtcbiAgICAgICAgdGhyb3cgZTtcbiAgICAgIH1cbiAgICAgIHRocm93IGU7XG4gICAgfVxuICB9O1xuICBoYW5kbGUucGF0aCA9IHBhdGg7XG4gIGhhbmRsZS5vcHRpb25zID0gb3B0aW9ucztcbiAgaGFuZGxlLm1ldGhvZCA9IG9wdGlvbnMubWV0aG9kO1xuICBoYW5kbGUuaGVhZGVycyA9IHJlc3BvbnNlSGVhZGVyO1xuICByZXR1cm4gaGFuZGxlO1xufVxuXG4vLyBzcmMvcm91dGVyLnRzXG5pbXBvcnQgeyBjcmVhdGVSb3V0ZXIgYXMgY3JlYXRlUm91M1JvdXRlciwgYWRkUm91dGUsIGZpbmRSb3V0ZSwgZmluZEFsbFJvdXRlcyB9IGZyb20gXCJyb3UzXCI7XG5cbi8vIHNyYy91dGlscy50c1xuYXN5bmMgZnVuY3Rpb24gZ2V0Qm9keShyZXF1ZXN0KSB7XG4gIGNvbnN0IGNvbnRlbnRUeXBlID0gcmVxdWVzdC5oZWFkZXJzLmdldChcImNvbnRlbnQtdHlwZVwiKSB8fCBcIlwiO1xuICBpZiAoIXJlcXVlc3QuYm9keSkge1xuICAgIHJldHVybiB2b2lkIDA7XG4gIH1cbiAgaWYgKGNvbnRlbnRUeXBlLmluY2x1ZGVzKFwiYXBwbGljYXRpb24vanNvblwiKSkge1xuICAgIHJldHVybiBhd2FpdCByZXF1ZXN0Lmpzb24oKTtcbiAgfVxuICBpZiAoY29udGVudFR5cGUuaW5jbHVkZXMoXCJhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWRcIikpIHtcbiAgICBjb25zdCBmb3JtRGF0YSA9IGF3YWl0IHJlcXVlc3QuZm9ybURhdGEoKTtcbiAgICBjb25zdCByZXN1bHQgPSB7fTtcbiAgICBmb3JtRGF0YS5mb3JFYWNoKCh2YWx1ZSwga2V5KSA9PiB7XG4gICAgICByZXN1bHRba2V5XSA9IHZhbHVlLnRvU3RyaW5nKCk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBpZiAoY29udGVudFR5cGUuaW5jbHVkZXMoXCJtdWx0aXBhcnQvZm9ybS1kYXRhXCIpKSB7XG4gICAgY29uc3QgZm9ybURhdGEgPSBhd2FpdCByZXF1ZXN0LmZvcm1EYXRhKCk7XG4gICAgY29uc3QgcmVzdWx0ID0ge307XG4gICAgZm9ybURhdGEuZm9yRWFjaCgodmFsdWUsIGtleSkgPT4ge1xuICAgICAgcmVzdWx0W2tleV0gPSB2YWx1ZTtcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIGlmIChjb250ZW50VHlwZS5pbmNsdWRlcyhcInRleHQvcGxhaW5cIikpIHtcbiAgICByZXR1cm4gYXdhaXQgcmVxdWVzdC50ZXh0KCk7XG4gIH1cbiAgaWYgKGNvbnRlbnRUeXBlLmluY2x1ZGVzKFwiYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtXCIpKSB7XG4gICAgcmV0dXJuIGF3YWl0IHJlcXVlc3QuYXJyYXlCdWZmZXIoKTtcbiAgfVxuICBpZiAoY29udGVudFR5cGUuaW5jbHVkZXMoXCJhcHBsaWNhdGlvbi9wZGZcIikgfHwgY29udGVudFR5cGUuaW5jbHVkZXMoXCJpbWFnZS9cIikgfHwgY29udGVudFR5cGUuaW5jbHVkZXMoXCJ2aWRlby9cIikpIHtcbiAgICBjb25zdCBibG9iID0gYXdhaXQgcmVxdWVzdC5ibG9iKCk7XG4gICAgcmV0dXJuIGJsb2I7XG4gIH1cbiAgaWYgKGNvbnRlbnRUeXBlLmluY2x1ZGVzKFwiYXBwbGljYXRpb24vc3RyZWFtXCIpIHx8IHJlcXVlc3QuYm9keSBpbnN0YW5jZW9mIFJlYWRhYmxlU3RyZWFtKSB7XG4gICAgcmV0dXJuIHJlcXVlc3QuYm9keTtcbiAgfVxuICByZXR1cm4gYXdhaXQgcmVxdWVzdC50ZXh0KCk7XG59XG5mdW5jdGlvbiBzaG91bGRTZXJpYWxpemUoYm9keSkge1xuICByZXR1cm4gdHlwZW9mIGJvZHkgPT09IFwib2JqZWN0XCIgJiYgYm9keSAhPT0gbnVsbCAmJiAhKGJvZHkgaW5zdGFuY2VvZiBCbG9iKSAmJiAhKGJvZHkgaW5zdGFuY2VvZiBGb3JtRGF0YSk7XG59XG52YXIgc3RhdHVzQ29kZSA9IHtcbiAgT0s6IDIwMCxcbiAgQ1JFQVRFRDogMjAxLFxuICBBQ0NFUFRFRDogMjAyLFxuICBOT19DT05URU5UOiAyMDQsXG4gIE1VTFRJUExFX0NIT0lDRVM6IDMwMCxcbiAgTU9WRURfUEVSTUFORU5UTFk6IDMwMSxcbiAgRk9VTkQ6IDMwMixcbiAgU0VFX09USEVSOiAzMDMsXG4gIE5PVF9NT0RJRklFRDogMzA0LFxuICBURU1QT1JBUllfUkVESVJFQ1Q6IDMwNyxcbiAgQkFEX1JFUVVFU1Q6IDQwMCxcbiAgVU5BVVRIT1JJWkVEOiA0MDEsXG4gIFBBWU1FTlRfUkVRVUlSRUQ6IDQwMixcbiAgRk9SQklEREVOOiA0MDMsXG4gIE5PVF9GT1VORDogNDA0LFxuICBNRVRIT0RfTk9UX0FMTE9XRUQ6IDQwNSxcbiAgTk9UX0FDQ0VQVEFCTEU6IDQwNixcbiAgUFJPWFlfQVVUSEVOVElDQVRJT05fUkVRVUlSRUQ6IDQwNyxcbiAgUkVRVUVTVF9USU1FT1VUOiA0MDgsXG4gIENPTkZMSUNUOiA0MDksXG4gIEdPTkU6IDQxMCxcbiAgTEVOR1RIX1JFUVVJUkVEOiA0MTEsXG4gIFBSRUNPTkRJVElPTl9GQUlMRUQ6IDQxMixcbiAgUEFZTE9BRF9UT09fTEFSR0U6IDQxMyxcbiAgVVJJX1RPT19MT05HOiA0MTQsXG4gIFVOU1VQUE9SVEVEX01FRElBX1RZUEU6IDQxNSxcbiAgUkFOR0VfTk9UX1NBVElTRklBQkxFOiA0MTYsXG4gIEVYUEVDVEFUSU9OX0ZBSUxFRDogNDE3LFxuICBcIkknTV9BX1RFQVBPVFwiOiA0MTgsXG4gIE1JU0RJUkVDVEVEX1JFUVVFU1Q6IDQyMSxcbiAgVU5QUk9DRVNTQUJMRV9FTlRJVFk6IDQyMixcbiAgTE9DS0VEOiA0MjMsXG4gIEZBSUxFRF9ERVBFTkRFTkNZOiA0MjQsXG4gIFRPT19FQVJMWTogNDI1LFxuICBVUEdSQURFX1JFUVVJUkVEOiA0MjYsXG4gIFBSRUNPTkRJVElPTl9SRVFVSVJFRDogNDI4LFxuICBUT09fTUFOWV9SRVFVRVNUUzogNDI5LFxuICBSRVFVRVNUX0hFQURFUl9GSUVMRFNfVE9PX0xBUkdFOiA0MzEsXG4gIFVOQVZBSUxBQkxFX0ZPUl9MRUdBTF9SRUFTT05TOiA0NTEsXG4gIElOVEVSTkFMX1NFUlZFUl9FUlJPUjogNTAwLFxuICBOT1RfSU1QTEVNRU5URUQ6IDUwMSxcbiAgQkFEX0dBVEVXQVk6IDUwMixcbiAgU0VSVklDRV9VTkFWQUlMQUJMRTogNTAzLFxuICBHQVRFV0FZX1RJTUVPVVQ6IDUwNCxcbiAgSFRUUF9WRVJTSU9OX05PVF9TVVBQT1JURUQ6IDUwNSxcbiAgVkFSSUFOVF9BTFNPX05FR09USUFURVM6IDUwNixcbiAgSU5TVUZGSUNJRU5UX1NUT1JBR0U6IDUwNyxcbiAgTE9PUF9ERVRFQ1RFRDogNTA4LFxuICBOT1RfRVhURU5ERUQ6IDUxMCxcbiAgTkVUV09SS19BVVRIRU5USUNBVElPTl9SRVFVSVJFRDogNTExXG59O1xuXG4vLyBzcmMvcm91dGVyLnRzXG52YXIgY3JlYXRlUm91dGVyID0gKGVuZHBvaW50cywgY29uZmlnKSA9PiB7XG4gIGNvbnN0IF9lbmRwb2ludHMgPSBPYmplY3QudmFsdWVzKGVuZHBvaW50cyk7XG4gIGNvbnN0IHJvdXRlciA9IGNyZWF0ZVJvdTNSb3V0ZXIoKTtcbiAgZm9yIChjb25zdCBlbmRwb2ludCBvZiBfZW5kcG9pbnRzKSB7XG4gICAgaWYgKGVuZHBvaW50Lm9wdGlvbnMubWV0YWRhdGE/LlNFUlZFUl9PTkxZKSBjb250aW51ZTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShlbmRwb2ludC5vcHRpb25zPy5tZXRob2QpKSB7XG4gICAgICBmb3IgKGNvbnN0IG1ldGhvZCBvZiBlbmRwb2ludC5vcHRpb25zLm1ldGhvZCkge1xuICAgICAgICBhZGRSb3V0ZShyb3V0ZXIsIG1ldGhvZCwgZW5kcG9pbnQucGF0aCwgZW5kcG9pbnQpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBhZGRSb3V0ZShyb3V0ZXIsIGVuZHBvaW50Lm9wdGlvbnMubWV0aG9kLCBlbmRwb2ludC5wYXRoLCBlbmRwb2ludCk7XG4gICAgfVxuICB9XG4gIGNvbnN0IG1pZGRsZXdhcmVSb3V0ZXIgPSBjcmVhdGVSb3UzUm91dGVyKCk7XG4gIGZvciAoY29uc3Qgcm91dGUgb2YgY29uZmlnPy5yb3V0ZXJNaWRkbGV3YXJlIHx8IFtdKSB7XG4gICAgYWRkUm91dGUobWlkZGxld2FyZVJvdXRlciwgXCIqXCIsIHJvdXRlLnBhdGgsIHJvdXRlLm1pZGRsZXdhcmUpO1xuICB9XG4gIGNvbnN0IGhhbmRsZXIgPSBhc3luYyAocmVxdWVzdCkgPT4ge1xuICAgIGNvbnN0IHVybCA9IG5ldyBVUkwocmVxdWVzdC51cmwpO1xuICAgIGxldCBwYXRoID0gdXJsLnBhdGhuYW1lO1xuICAgIGlmIChjb25maWc/LmJhc2VQYXRoKSB7XG4gICAgICBwYXRoID0gcGF0aC5zcGxpdChjb25maWcuYmFzZVBhdGgpWzFdO1xuICAgIH1cbiAgICBpZiAoIXBhdGg/Lmxlbmd0aCkge1xuICAgICAgY29uZmlnPy5vbkVycm9yPy4obmV3IEFQSUVycm9yKFwiTk9UX0ZPVU5EXCIpKTtcbiAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgYFtiZXR0ZXItY2FsbF06IE1ha2Ugc3VyZSB0aGUgVVJMIGhhcyB0aGUgYmFzZVBhdGggKCR7Y29uZmlnPy5iYXNlUGF0aH0pLmBcbiAgICAgICk7XG4gICAgICByZXR1cm4gbmV3IFJlc3BvbnNlKG51bGwsIHtcbiAgICAgICAgc3RhdHVzOiA0MDQsXG4gICAgICAgIHN0YXR1c1RleHQ6IFwiTm90IEZvdW5kXCJcbiAgICAgIH0pO1xuICAgIH1cbiAgICBjb25zdCBtZXRob2QgPSByZXF1ZXN0Lm1ldGhvZDtcbiAgICBjb25zdCByb3V0ZSA9IGZpbmRSb3V0ZShyb3V0ZXIsIG1ldGhvZCwgcGF0aCk7XG4gICAgY29uc3QgaGFuZGxlcjIgPSByb3V0ZT8uZGF0YTtcbiAgICBjb25zdCBib2R5ID0gYXdhaXQgZ2V0Qm9keShyZXF1ZXN0KTtcbiAgICBjb25zdCBoZWFkZXJzID0gcmVxdWVzdC5oZWFkZXJzO1xuICAgIGNvbnN0IHF1ZXJ5ID0gT2JqZWN0LmZyb21FbnRyaWVzKHVybC5zZWFyY2hQYXJhbXMpO1xuICAgIGNvbnN0IHJvdXRlck1pZGRsZXdhcmUgPSBmaW5kQWxsUm91dGVzKG1pZGRsZXdhcmVSb3V0ZXIsIFwiKlwiLCBwYXRoKTtcbiAgICBpZiAoIWhhbmRsZXIyKSB7XG4gICAgICByZXR1cm4gbmV3IFJlc3BvbnNlKG51bGwsIHtcbiAgICAgICAgc3RhdHVzOiA0MDQsXG4gICAgICAgIHN0YXR1c1RleHQ6IFwiTm90IEZvdW5kXCJcbiAgICAgIH0pO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgbGV0IG1pZGRsZXdhcmVDb250ZXh0ID0ge307XG4gICAgICBpZiAocm91dGVyTWlkZGxld2FyZT8ubGVuZ3RoKSB7XG4gICAgICAgIGZvciAoY29uc3Qgcm91dGUyIG9mIHJvdXRlck1pZGRsZXdhcmUpIHtcbiAgICAgICAgICBjb25zdCBtaWRkbGV3YXJlID0gcm91dGUyLmRhdGE7XG4gICAgICAgICAgY29uc3QgcmVzID0gYXdhaXQgbWlkZGxld2FyZSh7XG4gICAgICAgICAgICBwYXRoLFxuICAgICAgICAgICAgbWV0aG9kLFxuICAgICAgICAgICAgaGVhZGVycyxcbiAgICAgICAgICAgIHBhcmFtczogcm91dGUyPy5wYXJhbXMsXG4gICAgICAgICAgICByZXF1ZXN0LFxuICAgICAgICAgICAgYm9keSxcbiAgICAgICAgICAgIHF1ZXJ5LFxuICAgICAgICAgICAgY29udGV4dDoge1xuICAgICAgICAgICAgICAuLi5jb25maWc/LmV4dHJhQ29udGV4dFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGlmIChyZXMgaW5zdGFuY2VvZiBSZXNwb25zZSkge1xuICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHJlcz8uX2ZsYWcgPT09IFwianNvblwiKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFJlc3BvbnNlKEpTT04uc3RyaW5naWZ5KHJlcyksIHtcbiAgICAgICAgICAgICAgaGVhZGVyczogcmVzLmhlYWRlcnNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocmVzKSB7XG4gICAgICAgICAgICBtaWRkbGV3YXJlQ29udGV4dCA9IHtcbiAgICAgICAgICAgICAgLi4ucmVzLFxuICAgICAgICAgICAgICAuLi5taWRkbGV3YXJlQ29udGV4dFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvbnN0IGhhbmRsZXJSZXMgPSBhd2FpdCBoYW5kbGVyMih7XG4gICAgICAgIHBhdGgsXG4gICAgICAgIG1ldGhvZCxcbiAgICAgICAgaGVhZGVycyxcbiAgICAgICAgcGFyYW1zOiByb3V0ZT8ucGFyYW1zLFxuICAgICAgICByZXF1ZXN0LFxuICAgICAgICBib2R5LFxuICAgICAgICBxdWVyeSxcbiAgICAgICAgX2ZsYWc6IFwicm91dGVyXCIsXG4gICAgICAgIGNvbnRleHQ6IHtcbiAgICAgICAgICAuLi5taWRkbGV3YXJlQ29udGV4dCxcbiAgICAgICAgICAuLi5jb25maWc/LmV4dHJhQ29udGV4dFxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGlmIChoYW5kbGVyUmVzIGluc3RhbmNlb2YgUmVzcG9uc2UpIHtcbiAgICAgICAgcmV0dXJuIGhhbmRsZXJSZXM7XG4gICAgICB9XG4gICAgICBjb25zdCByZXNCb2R5ID0gc2hvdWxkU2VyaWFsaXplKGhhbmRsZXJSZXMpID8gSlNPTi5zdHJpbmdpZnkoaGFuZGxlclJlcykgOiBoYW5kbGVyUmVzO1xuICAgICAgcmV0dXJuIG5ldyBSZXNwb25zZShyZXNCb2R5LCB7XG4gICAgICAgIGhlYWRlcnM6IGhhbmRsZXIyLmhlYWRlcnNcbiAgICAgIH0pO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGlmIChjb25maWc/Lm9uRXJyb3IpIHtcbiAgICAgICAgY29uc3Qgb25FcnJvclJlcyA9IGF3YWl0IGNvbmZpZy5vbkVycm9yKGUpO1xuICAgICAgICBpZiAob25FcnJvclJlcyBpbnN0YW5jZW9mIFJlc3BvbnNlKSB7XG4gICAgICAgICAgcmV0dXJuIG9uRXJyb3JSZXM7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChlIGluc3RhbmNlb2YgQVBJRXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBSZXNwb25zZShlLmJvZHkgPyBKU09OLnN0cmluZ2lmeShlLmJvZHkpIDogbnVsbCwge1xuICAgICAgICAgIHN0YXR1czogc3RhdHVzQ29kZVtlLnN0YXR1c10sXG4gICAgICAgICAgc3RhdHVzVGV4dDogZS5zdGF0dXMsXG4gICAgICAgICAgaGVhZGVyczogZS5oZWFkZXJzXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYgKGNvbmZpZz8udGhyb3dFcnJvcikge1xuICAgICAgICB0aHJvdyBlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5ldyBSZXNwb25zZShudWxsLCB7XG4gICAgICAgIHN0YXR1czogNTAwLFxuICAgICAgICBzdGF0dXNUZXh0OiBcIkludGVybmFsIFNlcnZlciBFcnJvclwiXG4gICAgICB9KTtcbiAgICB9XG4gIH07XG4gIHJldHVybiB7XG4gICAgaGFuZGxlcjogYXN5bmMgKHJlcXVlc3QpID0+IHtcbiAgICAgIGNvbnN0IG9uUmVxID0gYXdhaXQgY29uZmlnPy5vblJlcXVlc3Q/LihyZXF1ZXN0KTtcbiAgICAgIGlmIChvblJlcSBpbnN0YW5jZW9mIFJlc3BvbnNlKSB7XG4gICAgICAgIHJldHVybiBvblJlcTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHJlcSA9IG9uUmVxIGluc3RhbmNlb2YgUmVxdWVzdCA/IG9uUmVxIDogcmVxdWVzdDtcbiAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IGhhbmRsZXIocmVxKTtcbiAgICAgIGNvbnN0IG9uUmVzID0gYXdhaXQgY29uZmlnPy5vblJlc3BvbnNlPy4ocmVzKTtcbiAgICAgIGlmIChvblJlcyBpbnN0YW5jZW9mIFJlc3BvbnNlKSB7XG4gICAgICAgIHJldHVybiBvblJlcztcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXM7XG4gICAgfSxcbiAgICBlbmRwb2ludHNcbiAgfTtcbn07XG5cbi8vIHNyYy9taWRkbGV3YXJlLnRzXG5mdW5jdGlvbiBjcmVhdGVNaWRkbGV3YXJlKG9wdGlvbnNPckhhbmRsZXIsIGhhbmRsZXIpIHtcbiAgaWYgKHR5cGVvZiBvcHRpb25zT3JIYW5kbGVyID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICByZXR1cm4gY3JlYXRlRW5kcG9pbnQoXG4gICAgICBcIipcIixcbiAgICAgIHtcbiAgICAgICAgbWV0aG9kOiBcIipcIlxuICAgICAgfSxcbiAgICAgIG9wdGlvbnNPckhhbmRsZXJcbiAgICApO1xuICB9XG4gIGlmICghaGFuZGxlcikge1xuICAgIHRocm93IG5ldyBFcnJvcihcIk1pZGRsZXdhcmUgaGFuZGxlciBpcyByZXF1aXJlZFwiKTtcbiAgfVxuICBjb25zdCBlbmRwb2ludCA9IGNyZWF0ZUVuZHBvaW50KFxuICAgIFwiKlwiLFxuICAgIHtcbiAgICAgIC4uLm9wdGlvbnNPckhhbmRsZXIsXG4gICAgICBtZXRob2Q6IFwiKlwiXG4gICAgfSxcbiAgICBoYW5kbGVyXG4gICk7XG4gIHJldHVybiBlbmRwb2ludDtcbn1cbnZhciBjcmVhdGVNaWRkbGV3YXJlQ3JlYXRvciA9IChvcHRzKSA9PiB7XG4gIGZ1bmN0aW9uIGZuKG9wdGlvbnNPckhhbmRsZXIsIGhhbmRsZXIpIHtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnNPckhhbmRsZXIgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgcmV0dXJuIGNyZWF0ZUVuZHBvaW50KFxuICAgICAgICBcIipcIixcbiAgICAgICAge1xuICAgICAgICAgIG1ldGhvZDogXCIqXCJcbiAgICAgICAgfSxcbiAgICAgICAgb3B0aW9uc09ySGFuZGxlclxuICAgICAgKTtcbiAgICB9XG4gICAgaWYgKCFoYW5kbGVyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNaWRkbGV3YXJlIGhhbmRsZXIgaXMgcmVxdWlyZWRcIik7XG4gICAgfVxuICAgIGNvbnN0IGVuZHBvaW50ID0gY3JlYXRlRW5kcG9pbnQoXG4gICAgICBcIipcIixcbiAgICAgIHtcbiAgICAgICAgLi4ub3B0aW9uc09ySGFuZGxlcixcbiAgICAgICAgbWV0aG9kOiBcIipcIlxuICAgICAgfSxcbiAgICAgIGhhbmRsZXJcbiAgICApO1xuICAgIHJldHVybiBlbmRwb2ludDtcbiAgfVxuICByZXR1cm4gZm47XG59O1xuXG4vLyBzcmMvdHlwZXMudHNcbmltcG9ydCBcInpvZFwiO1xuXG4vLyBzcmMvYWRhcHRlci9yZXF1ZXN0LnRzXG5pbXBvcnQgKiBhcyBzZXRfY29va2llX3BhcnNlciBmcm9tIFwic2V0LWNvb2tpZS1wYXJzZXJcIjtcbmZ1bmN0aW9uIGdldF9yYXdfYm9keShyZXEsIGJvZHlfc2l6ZV9saW1pdCkge1xuICBjb25zdCBoID0gcmVxLmhlYWRlcnM7XG4gIGlmICghaFtcImNvbnRlbnQtdHlwZVwiXSkgcmV0dXJuIG51bGw7XG4gIGNvbnN0IGNvbnRlbnRfbGVuZ3RoID0gTnVtYmVyKGhbXCJjb250ZW50LWxlbmd0aFwiXSk7XG4gIGlmIChyZXEuaHR0cFZlcnNpb25NYWpvciA9PT0gMSAmJiBpc05hTihjb250ZW50X2xlbmd0aCkgJiYgaFtcInRyYW5zZmVyLWVuY29kaW5nXCJdID09IG51bGwgfHwgY29udGVudF9sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBsZXQgbGVuZ3RoID0gY29udGVudF9sZW5ndGg7XG4gIGlmIChib2R5X3NpemVfbGltaXQpIHtcbiAgICBpZiAoIWxlbmd0aCkge1xuICAgICAgbGVuZ3RoID0gYm9keV9zaXplX2xpbWl0O1xuICAgIH0gZWxzZSBpZiAobGVuZ3RoID4gYm9keV9zaXplX2xpbWl0KSB7XG4gICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgYFJlY2VpdmVkIGNvbnRlbnQtbGVuZ3RoIG9mICR7bGVuZ3RofSwgYnV0IG9ubHkgYWNjZXB0IHVwIHRvICR7Ym9keV9zaXplX2xpbWl0fSBieXRlcy5gXG4gICAgICApO1xuICAgIH1cbiAgfVxuICBpZiAocmVxLmRlc3Ryb3llZCkge1xuICAgIGNvbnN0IHJlYWRhYmxlID0gbmV3IFJlYWRhYmxlU3RyZWFtKCk7XG4gICAgcmVhZGFibGUuY2FuY2VsKCk7XG4gICAgcmV0dXJuIHJlYWRhYmxlO1xuICB9XG4gIGxldCBzaXplID0gMDtcbiAgbGV0IGNhbmNlbGxlZCA9IGZhbHNlO1xuICByZXR1cm4gbmV3IFJlYWRhYmxlU3RyZWFtKHtcbiAgICBzdGFydChjb250cm9sbGVyKSB7XG4gICAgICByZXEub24oXCJlcnJvclwiLCAoZXJyb3IpID0+IHtcbiAgICAgICAgY2FuY2VsbGVkID0gdHJ1ZTtcbiAgICAgICAgY29udHJvbGxlci5lcnJvcihlcnJvcik7XG4gICAgICB9KTtcbiAgICAgIHJlcS5vbihcImVuZFwiLCAoKSA9PiB7XG4gICAgICAgIGlmIChjYW5jZWxsZWQpIHJldHVybjtcbiAgICAgICAgY29udHJvbGxlci5jbG9zZSgpO1xuICAgICAgfSk7XG4gICAgICByZXEub24oXCJkYXRhXCIsIChjaHVuaykgPT4ge1xuICAgICAgICBpZiAoY2FuY2VsbGVkKSByZXR1cm47XG4gICAgICAgIHNpemUgKz0gY2h1bmsubGVuZ3RoO1xuICAgICAgICBpZiAoc2l6ZSA+IGxlbmd0aCkge1xuICAgICAgICAgIGNhbmNlbGxlZCA9IHRydWU7XG4gICAgICAgICAgY29udHJvbGxlci5lcnJvcihcbiAgICAgICAgICAgIG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgYHJlcXVlc3QgYm9keSBzaXplIGV4Y2VlZGVkICR7Y29udGVudF9sZW5ndGggPyBcIidjb250ZW50LWxlbmd0aCdcIiA6IFwiQk9EWV9TSVpFX0xJTUlUXCJ9IG9mICR7bGVuZ3RofWBcbiAgICAgICAgICAgIClcbiAgICAgICAgICApO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb250cm9sbGVyLmVucXVldWUoY2h1bmspO1xuICAgICAgICBpZiAoY29udHJvbGxlci5kZXNpcmVkU2l6ZSA9PT0gbnVsbCB8fCBjb250cm9sbGVyLmRlc2lyZWRTaXplIDw9IDApIHtcbiAgICAgICAgICByZXEucGF1c2UoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSxcbiAgICBwdWxsKCkge1xuICAgICAgcmVxLnJlc3VtZSgpO1xuICAgIH0sXG4gICAgY2FuY2VsKHJlYXNvbikge1xuICAgICAgY2FuY2VsbGVkID0gdHJ1ZTtcbiAgICAgIHJlcS5kZXN0cm95KHJlYXNvbik7XG4gICAgfVxuICB9KTtcbn1cbmZ1bmN0aW9uIGdldFJlcXVlc3Qoe1xuICByZXF1ZXN0LFxuICBiYXNlLFxuICBib2R5U2l6ZUxpbWl0XG59KSB7XG4gIHJldHVybiBuZXcgUmVxdWVzdChiYXNlICsgcmVxdWVzdC51cmwsIHtcbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgZHVwbGV4OiBcImhhbGZcIixcbiAgICBtZXRob2Q6IHJlcXVlc3QubWV0aG9kLFxuICAgIGJvZHk6IGdldF9yYXdfYm9keShyZXF1ZXN0LCBib2R5U2l6ZUxpbWl0KSxcbiAgICBoZWFkZXJzOiByZXF1ZXN0LmhlYWRlcnNcbiAgfSk7XG59XG5hc3luYyBmdW5jdGlvbiBzZXRSZXNwb25zZShyZXMsIHJlc3BvbnNlKSB7XG4gIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIHJlc3BvbnNlLmhlYWRlcnMpIHtcbiAgICB0cnkge1xuICAgICAgcmVzLnNldEhlYWRlcihcbiAgICAgICAga2V5LFxuICAgICAgICBrZXkgPT09IFwic2V0LWNvb2tpZVwiID8gc2V0X2Nvb2tpZV9wYXJzZXIuc3BsaXRDb29raWVzU3RyaW5nKHJlc3BvbnNlLmhlYWRlcnMuZ2V0KGtleSkpIDogdmFsdWVcbiAgICAgICk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHJlcy5nZXRIZWFkZXJOYW1lcygpLmZvckVhY2goKG5hbWUpID0+IHJlcy5yZW1vdmVIZWFkZXIobmFtZSkpO1xuICAgICAgcmVzLndyaXRlSGVhZCg1MDApLmVuZChTdHJpbmcoZXJyb3IpKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cbiAgcmVzLndyaXRlSGVhZChyZXNwb25zZS5zdGF0dXMpO1xuICBpZiAoIXJlc3BvbnNlLmJvZHkpIHtcbiAgICByZXMuZW5kKCk7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChyZXNwb25zZS5ib2R5LmxvY2tlZCkge1xuICAgIHJlcy5lbmQoXG4gICAgICBcIkZhdGFsIGVycm9yOiBSZXNwb25zZSBib2R5IGlzIGxvY2tlZC4gVGhpcyBjYW4gaGFwcGVuIHdoZW4gdGhlIHJlc3BvbnNlIHdhcyBhbHJlYWR5IHJlYWQgKGZvciBleGFtcGxlIHRocm91Z2ggJ3Jlc3BvbnNlLmpzb24oKScgb3IgJ3Jlc3BvbnNlLnRleHQoKScpLlwiXG4gICAgKTtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgcmVhZGVyID0gcmVzcG9uc2UuYm9keS5nZXRSZWFkZXIoKTtcbiAgaWYgKHJlcy5kZXN0cm95ZWQpIHtcbiAgICByZWFkZXIuY2FuY2VsKCk7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IGNhbmNlbCA9IChlcnJvcikgPT4ge1xuICAgIHJlcy5vZmYoXCJjbG9zZVwiLCBjYW5jZWwpO1xuICAgIHJlcy5vZmYoXCJlcnJvclwiLCBjYW5jZWwpO1xuICAgIHJlYWRlci5jYW5jZWwoZXJyb3IpLmNhdGNoKCgpID0+IHtcbiAgICB9KTtcbiAgICBpZiAoZXJyb3IpIHJlcy5kZXN0cm95KGVycm9yKTtcbiAgfTtcbiAgcmVzLm9uKFwiY2xvc2VcIiwgY2FuY2VsKTtcbiAgcmVzLm9uKFwiZXJyb3JcIiwgY2FuY2VsKTtcbiAgbmV4dCgpO1xuICBhc3luYyBmdW5jdGlvbiBuZXh0KCkge1xuICAgIHRyeSB7XG4gICAgICBmb3IgKDsgOyApIHtcbiAgICAgICAgY29uc3QgeyBkb25lLCB2YWx1ZSB9ID0gYXdhaXQgcmVhZGVyLnJlYWQoKTtcbiAgICAgICAgaWYgKGRvbmUpIGJyZWFrO1xuICAgICAgICBpZiAoIXJlcy53cml0ZSh2YWx1ZSkpIHtcbiAgICAgICAgICByZXMub25jZShcImRyYWluXCIsIG5leHQpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmVzLmVuZCgpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjYW5jZWwoZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yIDogbmV3IEVycm9yKFN0cmluZyhlcnJvcikpKTtcbiAgICB9XG4gIH1cbn1cblxuLy8gc3JjL2FkYXB0ZXIvbm9kZS50c1xuZnVuY3Rpb24gdG9Ob2RlSGFuZGxlcihoYW5kbGVyKSB7XG4gIHJldHVybiBhc3luYyAocmVxLCByZXMpID0+IHtcbiAgICBjb25zdCBwcm90b2NvbCA9IHJlcS5oZWFkZXJzW1wieC1mb3J3YXJkZWQtcHJvdG9cIl0gfHwgKHJlcS5zb2NrZXQuZW5jcnlwdGVkID8gXCJodHRwc1wiIDogXCJodHRwXCIpO1xuICAgIGNvbnN0IGJhc2UgPSBgJHtwcm90b2NvbH06Ly8ke3JlcS5oZWFkZXJzW1wiOmF1dGhvcml0eVwiXSB8fCByZXEuaGVhZGVycy5ob3N0fWA7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBoYW5kbGVyKGdldFJlcXVlc3QoeyBiYXNlLCByZXF1ZXN0OiByZXEgfSkpO1xuICAgIHNldFJlc3BvbnNlKHJlcywgcmVzcG9uc2UpO1xuICB9O1xufVxuZXhwb3J0IHtcbiAgQVBJRXJyb3IsXG4gIGNyZWF0ZUVuZHBvaW50LFxuICBjcmVhdGVFbmRwb2ludENyZWF0b3IsXG4gIGNyZWF0ZU1pZGRsZXdhcmUsXG4gIGNyZWF0ZU1pZGRsZXdhcmVDcmVhdG9yLFxuICBjcmVhdGVSb3V0ZXIsXG4gIGdldEJvZHksXG4gIGdldENvb2tpZSxcbiAgZ2V0UmVxdWVzdCxcbiAgZ2V0U2lnbmVkQ29va2llLFxuICBqc29uLFxuICBwYXJzZSxcbiAgcGFyc2VTaWduZWQsXG4gIHNlcmlhbGl6ZSxcbiAgc2VyaWFsaXplU2lnbmVkLFxuICBzZXRDb29raWUsXG4gIHNldFJlc3BvbnNlLFxuICBzZXRTaWduZWRDb29raWUsXG4gIHNob3VsZFNlcmlhbGl6ZSxcbiAgc2lnbkNvb2tpZVZhbHVlLFxuICBzdGF0dXNDb2RlLFxuICB0b05vZGVIYW5kbGVyXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/../../../node_modules/better-call/dist/index.js\n");

/***/ }),

/***/ "(rsc)/../../../node_modules/better-call/dist/index.js":
/*!*******************************************************!*\
  !*** ../../../node_modules/better-call/dist/index.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   APIError: () => (/* binding */ APIError),\n/* harmony export */   createEndpoint: () => (/* binding */ createEndpoint),\n/* harmony export */   createEndpointCreator: () => (/* binding */ createEndpointCreator),\n/* harmony export */   createMiddleware: () => (/* binding */ createMiddleware),\n/* harmony export */   createMiddlewareCreator: () => (/* binding */ createMiddlewareCreator),\n/* harmony export */   createRouter: () => (/* binding */ createRouter),\n/* harmony export */   getBody: () => (/* binding */ getBody),\n/* harmony export */   getCookie: () => (/* binding */ getCookie),\n/* harmony export */   getRequest: () => (/* binding */ getRequest),\n/* harmony export */   getSignedCookie: () => (/* binding */ getSignedCookie),\n/* harmony export */   json: () => (/* binding */ json),\n/* harmony export */   parse: () => (/* binding */ parse),\n/* harmony export */   parseSigned: () => (/* binding */ parseSigned),\n/* harmony export */   serialize: () => (/* binding */ serialize),\n/* harmony export */   serializeSigned: () => (/* binding */ serializeSigned),\n/* harmony export */   setCookie: () => (/* binding */ setCookie),\n/* harmony export */   setResponse: () => (/* binding */ setResponse),\n/* harmony export */   setSignedCookie: () => (/* binding */ setSignedCookie),\n/* harmony export */   shouldSerialize: () => (/* binding */ shouldSerialize),\n/* harmony export */   signCookieValue: () => (/* binding */ signCookieValue),\n/* harmony export */   statusCode: () => (/* binding */ statusCode),\n/* harmony export */   toNodeHandler: () => (/* binding */ toNodeHandler)\n/* harmony export */ });\n/* harmony import */ var zod__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! zod */ \"(rsc)/../../../node_modules/zod/lib/index.mjs\");\n/* harmony import */ var uncrypto__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! uncrypto */ \"(rsc)/../../../node_modules/uncrypto/dist/crypto.node.mjs\");\n/* harmony import */ var rou3__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! rou3 */ \"(rsc)/../../../node_modules/rou3/dist/index.mjs\");\n/* harmony import */ var set_cookie_parser__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! set-cookie-parser */ \"(rsc)/../../../node_modules/set-cookie-parser/lib/set-cookie.js\");\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n\n// src/endpoint.ts\n\n\n// src/error.ts\nvar APIError = class extends Error {\n  constructor(status, body, headers) {\n    super(`API Error: ${status} ${body?.message ?? \"\"}`, {\n      cause: body\n    });\n    __publicField(this, \"status\");\n    __publicField(this, \"headers\");\n    __publicField(this, \"body\");\n    this.status = status;\n    this.body = body ?? {};\n    this.body.code = body?.message ? body.message.toUpperCase().replace(/ /g, \"_\").replace(/[^A-Z0-9_]/g, \"\") : status;\n    this.stack = \"\";\n    this.headers = headers ?? new Headers();\n    if (!this.headers.has(\"Content-Type\")) {\n      this.headers.set(\"Content-Type\", \"application/json\");\n    }\n    this.name = \"BetterCallAPIError\";\n  }\n};\n\n// src/helper.ts\nvar json = (body, option) => {\n  return {\n    response: {\n      body: option?.body ?? body,\n      status: option?.status ?? 200,\n      statusText: option?.statusText ?? \"OK\",\n      headers: option?.headers\n    },\n    body,\n    _flag: \"json\"\n  };\n};\n\n// src/cookie.ts\n\nvar algorithm = { name: \"HMAC\", hash: \"SHA-256\" };\nvar getCryptoKey = async (secret) => {\n  const secretBuf = typeof secret === \"string\" ? new TextEncoder().encode(secret) : secret;\n  return await uncrypto__WEBPACK_IMPORTED_MODULE_0__.subtle.importKey(\"raw\", secretBuf, algorithm, false, [\"sign\", \"verify\"]);\n};\nvar makeSignature = async (value, secret) => {\n  const key = await getCryptoKey(secret);\n  const signature = await uncrypto__WEBPACK_IMPORTED_MODULE_0__.subtle.sign(algorithm.name, key, new TextEncoder().encode(value));\n  return btoa(String.fromCharCode(...new Uint8Array(signature)));\n};\nvar verifySignature = async (base64Signature, value, secret) => {\n  try {\n    const signatureBinStr = atob(base64Signature);\n    const signature = new Uint8Array(signatureBinStr.length);\n    for (let i = 0, len = signatureBinStr.length; i < len; i++) {\n      signature[i] = signatureBinStr.charCodeAt(i);\n    }\n    return await uncrypto__WEBPACK_IMPORTED_MODULE_0__.subtle.verify(algorithm, secret, signature, new TextEncoder().encode(value));\n  } catch (e) {\n    return false;\n  }\n};\nvar validCookieNameRegEx = /^[\\w!#$%&'*.^`|~+-]+$/;\nvar validCookieValueRegEx = /^[ !#-:<-[\\]-~]*$/;\nvar parse = (cookie, name) => {\n  const pairs = cookie.trim().split(\";\");\n  return pairs.reduce((parsedCookie, pairStr) => {\n    pairStr = pairStr.trim();\n    const valueStartPos = pairStr.indexOf(\"=\");\n    if (valueStartPos === -1) {\n      return parsedCookie;\n    }\n    const cookieName = pairStr.substring(0, valueStartPos).trim();\n    if (name && name !== cookieName || !validCookieNameRegEx.test(cookieName)) {\n      return parsedCookie;\n    }\n    let cookieValue = pairStr.substring(valueStartPos + 1).trim();\n    if (cookieValue.startsWith('\"') && cookieValue.endsWith('\"')) {\n      cookieValue = cookieValue.slice(1, -1);\n    }\n    if (validCookieValueRegEx.test(cookieValue)) {\n      parsedCookie[cookieName] = decodeURIComponent(cookieValue);\n    }\n    return parsedCookie;\n  }, {});\n};\nvar parseSigned = async (cookie, secret, name) => {\n  const parsedCookie = {};\n  const secretKey = await getCryptoKey(secret);\n  for (const [key, value] of Object.entries(parse(cookie, name))) {\n    const signatureStartPos = value.lastIndexOf(\".\");\n    if (signatureStartPos < 1) {\n      continue;\n    }\n    const signedValue = value.substring(0, signatureStartPos);\n    const signature = value.substring(signatureStartPos + 1);\n    if (signature.length !== 44 || !signature.endsWith(\"=\")) {\n      continue;\n    }\n    const isVerified = await verifySignature(signature, signedValue, secretKey);\n    parsedCookie[key] = isVerified ? signedValue : false;\n  }\n  return parsedCookie;\n};\nvar _serialize = (name, value, opt = {}) => {\n  let cookie = `${name}=${value}`;\n  if (name.startsWith(\"__Secure-\") && !opt.secure) {\n    opt.secure = true;\n  }\n  if (name.startsWith(\"__Host-\")) {\n    if (!opt.secure) {\n      opt.secure = true;\n    }\n    if (opt.path !== \"/\") {\n      opt.path = \"/\";\n    }\n    if (opt.domain) {\n      opt.domain = void 0;\n    }\n  }\n  if (opt && typeof opt.maxAge === \"number\" && opt.maxAge >= 0) {\n    if (opt.maxAge > 3456e4) {\n      throw new Error(\n        \"Cookies Max-Age SHOULD NOT be greater than 400 days (34560000 seconds) in duration.\"\n      );\n    }\n    cookie += `; Max-Age=${Math.floor(opt.maxAge)}`;\n  }\n  if (opt.domain && opt.prefix !== \"host\") {\n    cookie += `; Domain=${opt.domain}`;\n  }\n  if (opt.path) {\n    cookie += `; Path=${opt.path}`;\n  }\n  if (opt.expires) {\n    if (opt.expires.getTime() - Date.now() > 3456e7) {\n      throw new Error(\n        \"Cookies Expires SHOULD NOT be greater than 400 days (34560000 seconds) in the future.\"\n      );\n    }\n    cookie += `; Expires=${opt.expires.toUTCString()}`;\n  }\n  if (opt.httpOnly) {\n    cookie += \"; HttpOnly\";\n  }\n  if (opt.secure) {\n    cookie += \"; Secure\";\n  }\n  if (opt.sameSite) {\n    cookie += `; SameSite=${opt.sameSite.charAt(0).toUpperCase() + opt.sameSite.slice(1)}`;\n  }\n  if (opt.partitioned) {\n    if (!opt.secure) {\n      throw new Error(\"Partitioned Cookie must have Secure attributes\");\n    }\n    cookie += \"; Partitioned\";\n  }\n  return cookie;\n};\nvar serialize = (name, value, opt) => {\n  value = encodeURIComponent(value);\n  return _serialize(name, value, opt);\n};\nvar serializeSigned = async (name, value, secret, opt = {}) => {\n  const signature = await makeSignature(value, secret);\n  value = `${value}.${signature}`;\n  value = encodeURIComponent(value);\n  return _serialize(name, value, opt);\n};\nvar signCookieValue = async (value, secret) => {\n  const signature = await makeSignature(value, secret);\n  value = `${value}.${signature}`;\n  value = encodeURIComponent(value);\n  return value;\n};\n\n// src/cookie-utils.ts\nvar getCookie = (cookie, key, prefix) => {\n  if (!cookie) {\n    return void 0;\n  }\n  let finalKey = key;\n  if (prefix) {\n    if (prefix === \"secure\") {\n      finalKey = \"__Secure-\" + key;\n    } else if (prefix === \"host\") {\n      finalKey = \"__Host-\" + key;\n    } else {\n      return void 0;\n    }\n  }\n  const obj = parse(cookie, finalKey);\n  return obj[finalKey];\n};\nvar setCookie = (header, name, value, opt) => {\n  const existingCookies = header.get(\"Set-Cookie\");\n  if (existingCookies) {\n    const cookies = existingCookies.split(\", \");\n    const updatedCookies = cookies.filter((cookie2) => !cookie2.startsWith(`${name}=`));\n    header.delete(\"Set-Cookie\");\n    updatedCookies.forEach((cookie2) => header.append(\"Set-Cookie\", cookie2));\n  }\n  let cookie;\n  if (opt?.prefix === \"secure\") {\n    cookie = serialize(\"__Secure-\" + name, value, { path: \"/\", ...opt, secure: true });\n  } else if (opt?.prefix === \"host\") {\n    cookie = serialize(\"__Host-\" + name, value, {\n      ...opt,\n      path: \"/\",\n      secure: true,\n      domain: void 0\n    });\n  } else {\n    cookie = serialize(name, value, { path: \"/\", ...opt });\n  }\n  header.append(\"Set-Cookie\", cookie);\n};\nvar setSignedCookie = async (header, name, value, secret, opt) => {\n  let cookie;\n  if (opt?.prefix === \"secure\") {\n    cookie = await serializeSigned(\"__Secure-\" + name, value, secret, {\n      path: \"/\",\n      ...opt,\n      secure: true\n    });\n  } else if (opt?.prefix === \"host\") {\n    cookie = await serializeSigned(\"__Host-\" + name, value, secret, {\n      ...opt,\n      path: \"/\",\n      secure: true,\n      domain: void 0\n    });\n  } else {\n    cookie = await serializeSigned(name, value, secret, { path: \"/\", ...opt });\n  }\n  header.append(\"Set-Cookie\", cookie);\n};\nvar getSignedCookie = async (header, secret, key, prefix) => {\n  const cookie = header.get(\"cookie\");\n  if (!cookie) {\n    return void 0;\n  }\n  let finalKey = key;\n  if (prefix) {\n    if (prefix === \"secure\") {\n      finalKey = \"__Secure-\" + key;\n    } else if (prefix === \"host\") {\n      finalKey = \"__Host-\" + key;\n    }\n  }\n  const obj = await parseSigned(cookie, secret, finalKey);\n  return obj[finalKey];\n};\n\n// src/endpoint.ts\nfunction createEndpointCreator(opts) {\n  return (path, options, handler) => {\n    return createEndpoint(\n      path,\n      {\n        ...options,\n        use: [...options?.use || [], ...opts?.use || []]\n      },\n      handler\n    );\n  };\n}\nfunction createEndpoint(path, options, handler) {\n  let responseHeader = new Headers();\n  const handle = async (...ctx) => {\n    let internalCtx = {\n      setHeader(key, value) {\n        responseHeader.set(key, value);\n      },\n      setCookie(key, value, options2) {\n        setCookie(responseHeader, key, value, options2);\n      },\n      getCookie(key, prefix) {\n        const header = ctx[0]?.headers;\n        const cookieH = header?.get(\"cookie\");\n        const cookie = getCookie(cookieH || \"\", key, prefix);\n        return cookie;\n      },\n      getSignedCookie(key, secret, prefix) {\n        const header = ctx[0]?.headers;\n        if (!header) {\n          throw new TypeError(\"Headers are required\");\n        }\n        const cookie = getSignedCookie(header, secret, key, prefix);\n        return cookie;\n      },\n      async setSignedCookie(key, value, secret, options2) {\n        await setSignedCookie(responseHeader, key, value, secret, options2);\n      },\n      redirect(url) {\n        responseHeader.set(\"Location\", url);\n        return new APIError(\"FOUND\");\n      },\n      json,\n      context: ctx[0]?.context || {},\n      _flag: ctx[0]?.asResponse ? \"router\" : ctx[0]?._flag,\n      responseHeader,\n      path,\n      ...ctx[0] || {}\n    };\n    if (options.use?.length) {\n      let middlewareContexts = {};\n      let middlewareBody = {};\n      for (const middleware of options.use) {\n        if (typeof middleware !== \"function\") {\n          console.warn(\"Middleware is not a function\", {\n            middleware\n          });\n          continue;\n        }\n        const res = await middleware(internalCtx);\n        if (res) {\n          const body = res.options?.body ? res.options.body.parse(internalCtx.body) : void 0;\n          middlewareContexts = {\n            ...middlewareContexts,\n            ...res\n          };\n          middlewareBody = {\n            ...middlewareBody,\n            ...body\n          };\n        }\n      }\n      internalCtx = {\n        ...internalCtx,\n        body: {\n          ...middlewareBody,\n          ...internalCtx.body\n        },\n        context: {\n          ...internalCtx.context || {},\n          ...middlewareContexts\n        }\n      };\n    }\n    try {\n      const body = options.body ? options.body.parse(internalCtx.body) : internalCtx.body;\n      internalCtx = {\n        ...internalCtx,\n        body: body ? {\n          ...body,\n          ...internalCtx.body\n        } : internalCtx.body\n      };\n      internalCtx.query = options.query ? options.query.parse(internalCtx.query) : internalCtx.query;\n    } catch (e) {\n      if (e instanceof zod__WEBPACK_IMPORTED_MODULE_1__.ZodError) {\n        throw new APIError(\"BAD_REQUEST\", {\n          message: e.message,\n          details: e.errors\n        });\n      }\n      throw e;\n    }\n    if (options.requireHeaders && !internalCtx.headers) {\n      throw new APIError(\"BAD_REQUEST\", {\n        message: \"Headers are required\"\n      });\n    }\n    if (options.requireRequest && !internalCtx.request) {\n      throw new APIError(\"BAD_REQUEST\", {\n        message: \"Request is required\"\n      });\n    }\n    if (internalCtx.request && !internalCtx.headers) {\n      internalCtx.headers = internalCtx.request.headers;\n    }\n    try {\n      let res = await handler(internalCtx);\n      let actualResponse = res;\n      if (res && typeof res === \"object\" && \"_flag\" in res) {\n        if (res._flag === \"json\" && internalCtx._flag === \"router\") {\n          const h = res.response.headers;\n          Object.keys(h || {}).forEach((key) => {\n            responseHeader.set(key, h[key]);\n          });\n          responseHeader.set(\"Content-Type\", \"application/json\");\n          actualResponse = new Response(JSON.stringify(res.response.body), {\n            status: res.response.status ?? 200,\n            statusText: res.response.statusText,\n            headers: responseHeader\n          });\n        } else {\n          actualResponse = res.body;\n        }\n      }\n      responseHeader = new Headers();\n      return actualResponse;\n    } catch (e) {\n      if (e instanceof APIError) {\n        responseHeader.set(\"Content-Type\", \"application/json\");\n        e.headers = responseHeader;\n        responseHeader = new Headers();\n        throw e;\n      }\n      throw e;\n    }\n  };\n  handle.path = path;\n  handle.options = options;\n  handle.method = options.method;\n  handle.headers = responseHeader;\n  return handle;\n}\n\n// src/router.ts\n\n\n// src/utils.ts\nasync function getBody(request) {\n  const contentType = request.headers.get(\"content-type\") || \"\";\n  if (!request.body) {\n    return void 0;\n  }\n  if (contentType.includes(\"application/json\")) {\n    return await request.json();\n  }\n  if (contentType.includes(\"application/x-www-form-urlencoded\")) {\n    const formData = await request.formData();\n    const result = {};\n    formData.forEach((value, key) => {\n      result[key] = value.toString();\n    });\n    return result;\n  }\n  if (contentType.includes(\"multipart/form-data\")) {\n    const formData = await request.formData();\n    const result = {};\n    formData.forEach((value, key) => {\n      result[key] = value;\n    });\n    return result;\n  }\n  if (contentType.includes(\"text/plain\")) {\n    return await request.text();\n  }\n  if (contentType.includes(\"application/octet-stream\")) {\n    return await request.arrayBuffer();\n  }\n  if (contentType.includes(\"application/pdf\") || contentType.includes(\"image/\") || contentType.includes(\"video/\")) {\n    const blob = await request.blob();\n    return blob;\n  }\n  if (contentType.includes(\"application/stream\") || request.body instanceof ReadableStream) {\n    return request.body;\n  }\n  return await request.text();\n}\nfunction shouldSerialize(body) {\n  return typeof body === \"object\" && body !== null && !(body instanceof Blob) && !(body instanceof FormData);\n}\nvar statusCode = {\n  OK: 200,\n  CREATED: 201,\n  ACCEPTED: 202,\n  NO_CONTENT: 204,\n  MULTIPLE_CHOICES: 300,\n  MOVED_PERMANENTLY: 301,\n  FOUND: 302,\n  SEE_OTHER: 303,\n  NOT_MODIFIED: 304,\n  TEMPORARY_REDIRECT: 307,\n  BAD_REQUEST: 400,\n  UNAUTHORIZED: 401,\n  PAYMENT_REQUIRED: 402,\n  FORBIDDEN: 403,\n  NOT_FOUND: 404,\n  METHOD_NOT_ALLOWED: 405,\n  NOT_ACCEPTABLE: 406,\n  PROXY_AUTHENTICATION_REQUIRED: 407,\n  REQUEST_TIMEOUT: 408,\n  CONFLICT: 409,\n  GONE: 410,\n  LENGTH_REQUIRED: 411,\n  PRECONDITION_FAILED: 412,\n  PAYLOAD_TOO_LARGE: 413,\n  URI_TOO_LONG: 414,\n  UNSUPPORTED_MEDIA_TYPE: 415,\n  RANGE_NOT_SATISFIABLE: 416,\n  EXPECTATION_FAILED: 417,\n  \"I'M_A_TEAPOT\": 418,\n  MISDIRECTED_REQUEST: 421,\n  UNPROCESSABLE_ENTITY: 422,\n  LOCKED: 423,\n  FAILED_DEPENDENCY: 424,\n  TOO_EARLY: 425,\n  UPGRADE_REQUIRED: 426,\n  PRECONDITION_REQUIRED: 428,\n  TOO_MANY_REQUESTS: 429,\n  REQUEST_HEADER_FIELDS_TOO_LARGE: 431,\n  UNAVAILABLE_FOR_LEGAL_REASONS: 451,\n  INTERNAL_SERVER_ERROR: 500,\n  NOT_IMPLEMENTED: 501,\n  BAD_GATEWAY: 502,\n  SERVICE_UNAVAILABLE: 503,\n  GATEWAY_TIMEOUT: 504,\n  HTTP_VERSION_NOT_SUPPORTED: 505,\n  VARIANT_ALSO_NEGOTIATES: 506,\n  INSUFFICIENT_STORAGE: 507,\n  LOOP_DETECTED: 508,\n  NOT_EXTENDED: 510,\n  NETWORK_AUTHENTICATION_REQUIRED: 511\n};\n\n// src/router.ts\nvar createRouter = (endpoints, config) => {\n  const _endpoints = Object.values(endpoints);\n  const router = (0,rou3__WEBPACK_IMPORTED_MODULE_2__.createRouter)();\n  for (const endpoint of _endpoints) {\n    if (endpoint.options.metadata?.SERVER_ONLY) continue;\n    if (Array.isArray(endpoint.options?.method)) {\n      for (const method of endpoint.options.method) {\n        (0,rou3__WEBPACK_IMPORTED_MODULE_2__.addRoute)(router, method, endpoint.path, endpoint);\n      }\n    } else {\n      (0,rou3__WEBPACK_IMPORTED_MODULE_2__.addRoute)(router, endpoint.options.method, endpoint.path, endpoint);\n    }\n  }\n  const middlewareRouter = (0,rou3__WEBPACK_IMPORTED_MODULE_2__.createRouter)();\n  for (const route of config?.routerMiddleware || []) {\n    (0,rou3__WEBPACK_IMPORTED_MODULE_2__.addRoute)(middlewareRouter, \"*\", route.path, route.middleware);\n  }\n  const handler = async (request) => {\n    const url = new URL(request.url);\n    let path = url.pathname;\n    if (config?.basePath) {\n      path = path.split(config.basePath)[1];\n    }\n    if (!path?.length) {\n      config?.onError?.(new APIError(\"NOT_FOUND\"));\n      console.warn(\n        `[better-call]: Make sure the URL has the basePath (${config?.basePath}).`\n      );\n      return new Response(null, {\n        status: 404,\n        statusText: \"Not Found\"\n      });\n    }\n    const method = request.method;\n    const route = (0,rou3__WEBPACK_IMPORTED_MODULE_2__.findRoute)(router, method, path);\n    const handler2 = route?.data;\n    const body = await getBody(request);\n    const headers = request.headers;\n    const query = Object.fromEntries(url.searchParams);\n    const routerMiddleware = (0,rou3__WEBPACK_IMPORTED_MODULE_2__.findAllRoutes)(middlewareRouter, \"*\", path);\n    if (!handler2) {\n      return new Response(null, {\n        status: 404,\n        statusText: \"Not Found\"\n      });\n    }\n    try {\n      let middlewareContext = {};\n      if (routerMiddleware?.length) {\n        for (const route2 of routerMiddleware) {\n          const middleware = route2.data;\n          const res = await middleware({\n            path,\n            method,\n            headers,\n            params: route2?.params,\n            request,\n            body,\n            query,\n            context: {\n              ...config?.extraContext\n            }\n          });\n          if (res instanceof Response) {\n            return res;\n          }\n          if (res?._flag === \"json\") {\n            return new Response(JSON.stringify(res), {\n              headers: res.headers\n            });\n          }\n          if (res) {\n            middlewareContext = {\n              ...res,\n              ...middlewareContext\n            };\n          }\n        }\n      }\n      const handlerRes = await handler2({\n        path,\n        method,\n        headers,\n        params: route?.params,\n        request,\n        body,\n        query,\n        _flag: \"router\",\n        context: {\n          ...middlewareContext,\n          ...config?.extraContext\n        }\n      });\n      if (handlerRes instanceof Response) {\n        return handlerRes;\n      }\n      const resBody = shouldSerialize(handlerRes) ? JSON.stringify(handlerRes) : handlerRes;\n      return new Response(resBody, {\n        headers: handler2.headers\n      });\n    } catch (e) {\n      if (config?.onError) {\n        const onErrorRes = await config.onError(e);\n        if (onErrorRes instanceof Response) {\n          return onErrorRes;\n        }\n      }\n      if (e instanceof APIError) {\n        return new Response(e.body ? JSON.stringify(e.body) : null, {\n          status: statusCode[e.status],\n          statusText: e.status,\n          headers: e.headers\n        });\n      }\n      if (config?.throwError) {\n        throw e;\n      }\n      return new Response(null, {\n        status: 500,\n        statusText: \"Internal Server Error\"\n      });\n    }\n  };\n  return {\n    handler: async (request) => {\n      const onReq = await config?.onRequest?.(request);\n      if (onReq instanceof Response) {\n        return onReq;\n      }\n      const req = onReq instanceof Request ? onReq : request;\n      const res = await handler(req);\n      const onRes = await config?.onResponse?.(res);\n      if (onRes instanceof Response) {\n        return onRes;\n      }\n      return res;\n    },\n    endpoints\n  };\n};\n\n// src/middleware.ts\nfunction createMiddleware(optionsOrHandler, handler) {\n  if (typeof optionsOrHandler === \"function\") {\n    return createEndpoint(\n      \"*\",\n      {\n        method: \"*\"\n      },\n      optionsOrHandler\n    );\n  }\n  if (!handler) {\n    throw new Error(\"Middleware handler is required\");\n  }\n  const endpoint = createEndpoint(\n    \"*\",\n    {\n      ...optionsOrHandler,\n      method: \"*\"\n    },\n    handler\n  );\n  return endpoint;\n}\nvar createMiddlewareCreator = (opts) => {\n  function fn(optionsOrHandler, handler) {\n    if (typeof optionsOrHandler === \"function\") {\n      return createEndpoint(\n        \"*\",\n        {\n          method: \"*\"\n        },\n        optionsOrHandler\n      );\n    }\n    if (!handler) {\n      throw new Error(\"Middleware handler is required\");\n    }\n    const endpoint = createEndpoint(\n      \"*\",\n      {\n        ...optionsOrHandler,\n        method: \"*\"\n      },\n      handler\n    );\n    return endpoint;\n  }\n  return fn;\n};\n\n// src/types.ts\n\n\n// src/adapter/request.ts\n\nfunction get_raw_body(req, body_size_limit) {\n  const h = req.headers;\n  if (!h[\"content-type\"]) return null;\n  const content_length = Number(h[\"content-length\"]);\n  if (req.httpVersionMajor === 1 && isNaN(content_length) && h[\"transfer-encoding\"] == null || content_length === 0) {\n    return null;\n  }\n  let length = content_length;\n  if (body_size_limit) {\n    if (!length) {\n      length = body_size_limit;\n    } else if (length > body_size_limit) {\n      throw Error(\n        `Received content-length of ${length}, but only accept up to ${body_size_limit} bytes.`\n      );\n    }\n  }\n  if (req.destroyed) {\n    const readable = new ReadableStream();\n    readable.cancel();\n    return readable;\n  }\n  let size = 0;\n  let cancelled = false;\n  return new ReadableStream({\n    start(controller) {\n      req.on(\"error\", (error) => {\n        cancelled = true;\n        controller.error(error);\n      });\n      req.on(\"end\", () => {\n        if (cancelled) return;\n        controller.close();\n      });\n      req.on(\"data\", (chunk) => {\n        if (cancelled) return;\n        size += chunk.length;\n        if (size > length) {\n          cancelled = true;\n          controller.error(\n            new Error(\n              `request body size exceeded ${content_length ? \"'content-length'\" : \"BODY_SIZE_LIMIT\"} of ${length}`\n            )\n          );\n          return;\n        }\n        controller.enqueue(chunk);\n        if (controller.desiredSize === null || controller.desiredSize <= 0) {\n          req.pause();\n        }\n      });\n    },\n    pull() {\n      req.resume();\n    },\n    cancel(reason) {\n      cancelled = true;\n      req.destroy(reason);\n    }\n  });\n}\nfunction getRequest({\n  request,\n  base,\n  bodySizeLimit\n}) {\n  return new Request(base + request.url, {\n    // @ts-expect-error\n    duplex: \"half\",\n    method: request.method,\n    body: get_raw_body(request, bodySizeLimit),\n    headers: request.headers\n  });\n}\nasync function setResponse(res, response) {\n  for (const [key, value] of response.headers) {\n    try {\n      res.setHeader(\n        key,\n        key === \"set-cookie\" ? set_cookie_parser__WEBPACK_IMPORTED_MODULE_3__.splitCookiesString(response.headers.get(key)) : value\n      );\n    } catch (error) {\n      res.getHeaderNames().forEach((name) => res.removeHeader(name));\n      res.writeHead(500).end(String(error));\n      return;\n    }\n  }\n  res.writeHead(response.status);\n  if (!response.body) {\n    res.end();\n    return;\n  }\n  if (response.body.locked) {\n    res.end(\n      \"Fatal error: Response body is locked. This can happen when the response was already read (for example through 'response.json()' or 'response.text()').\"\n    );\n    return;\n  }\n  const reader = response.body.getReader();\n  if (res.destroyed) {\n    reader.cancel();\n    return;\n  }\n  const cancel = (error) => {\n    res.off(\"close\", cancel);\n    res.off(\"error\", cancel);\n    reader.cancel(error).catch(() => {\n    });\n    if (error) res.destroy(error);\n  };\n  res.on(\"close\", cancel);\n  res.on(\"error\", cancel);\n  next();\n  async function next() {\n    try {\n      for (; ; ) {\n        const { done, value } = await reader.read();\n        if (done) break;\n        if (!res.write(value)) {\n          res.once(\"drain\", next);\n          return;\n        }\n      }\n      res.end();\n    } catch (error) {\n      cancel(error instanceof Error ? error : new Error(String(error)));\n    }\n  }\n}\n\n// src/adapter/node.ts\nfunction toNodeHandler(handler) {\n  return async (req, res) => {\n    const protocol = req.headers[\"x-forwarded-proto\"] || (req.socket.encrypted ? \"https\" : \"http\");\n    const base = `${protocol}://${req.headers[\":authority\"] || req.headers.host}`;\n    const response = await handler(getRequest({ base, request: req }));\n    setResponse(res, response);\n  };\n}\n\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2JldHRlci1jYWxsL2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBLDhFQUE4RSw2REFBNkQ7QUFDM0k7O0FBRUE7QUFDK0I7O0FBRS9CO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixRQUFRLEVBQUUsb0JBQW9CO0FBQ3REO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNrQztBQUNsQyxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBLGVBQWUsNENBQU07QUFDckI7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLDRDQUFNO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxTQUFTO0FBQzNEO0FBQ0E7QUFDQSxpQkFBaUIsNENBQU07QUFDdkIsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLElBQUk7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2QyxrQkFBa0IsS0FBSyxHQUFHLE1BQU07QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDYTs7QUFFYjtBQUN1RDtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0Esc0NBQXNDLE9BQU8sMEJBQTBCLGlCQUFpQjtBQUN4RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLHlEQUF5RCxLQUFLLE9BQU87QUFDakg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsaUVBQW9DO0FBQ25FO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmLGdCQUFnQixjQUFjO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFNBQVMsS0FBSyw4Q0FBOEM7QUFDaEYsZ0RBQWdELG9CQUFvQjtBQUNwRTtBQUNBO0FBQ0E7QUF3QkU7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL0BoZWxzYS9hcHAvLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2JldHRlci1jYWxsL2Rpc3QvaW5kZXguanM/ODYwYiJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgX19kZWZQcm9wID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fZGVmTm9ybWFsUHJvcCA9IChvYmosIGtleSwgdmFsdWUpID0+IGtleSBpbiBvYmogPyBfX2RlZlByb3Aob2JqLCBrZXksIHsgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSwgdmFsdWUgfSkgOiBvYmpba2V5XSA9IHZhbHVlO1xudmFyIF9fcHVibGljRmllbGQgPSAob2JqLCBrZXksIHZhbHVlKSA9PiBfX2RlZk5vcm1hbFByb3Aob2JqLCB0eXBlb2Yga2V5ICE9PSBcInN5bWJvbFwiID8ga2V5ICsgXCJcIiA6IGtleSwgdmFsdWUpO1xuXG4vLyBzcmMvZW5kcG9pbnQudHNcbmltcG9ydCB7IFpvZEVycm9yIH0gZnJvbSBcInpvZFwiO1xuXG4vLyBzcmMvZXJyb3IudHNcbnZhciBBUElFcnJvciA9IGNsYXNzIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihzdGF0dXMsIGJvZHksIGhlYWRlcnMpIHtcbiAgICBzdXBlcihgQVBJIEVycm9yOiAke3N0YXR1c30gJHtib2R5Py5tZXNzYWdlID8/IFwiXCJ9YCwge1xuICAgICAgY2F1c2U6IGJvZHlcbiAgICB9KTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwic3RhdHVzXCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJoZWFkZXJzXCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJib2R5XCIpO1xuICAgIHRoaXMuc3RhdHVzID0gc3RhdHVzO1xuICAgIHRoaXMuYm9keSA9IGJvZHkgPz8ge307XG4gICAgdGhpcy5ib2R5LmNvZGUgPSBib2R5Py5tZXNzYWdlID8gYm9keS5tZXNzYWdlLnRvVXBwZXJDYXNlKCkucmVwbGFjZSgvIC9nLCBcIl9cIikucmVwbGFjZSgvW15BLVowLTlfXS9nLCBcIlwiKSA6IHN0YXR1cztcbiAgICB0aGlzLnN0YWNrID0gXCJcIjtcbiAgICB0aGlzLmhlYWRlcnMgPSBoZWFkZXJzID8/IG5ldyBIZWFkZXJzKCk7XG4gICAgaWYgKCF0aGlzLmhlYWRlcnMuaGFzKFwiQ29udGVudC1UeXBlXCIpKSB7XG4gICAgICB0aGlzLmhlYWRlcnMuc2V0KFwiQ29udGVudC1UeXBlXCIsIFwiYXBwbGljYXRpb24vanNvblwiKTtcbiAgICB9XG4gICAgdGhpcy5uYW1lID0gXCJCZXR0ZXJDYWxsQVBJRXJyb3JcIjtcbiAgfVxufTtcblxuLy8gc3JjL2hlbHBlci50c1xudmFyIGpzb24gPSAoYm9keSwgb3B0aW9uKSA9PiB7XG4gIHJldHVybiB7XG4gICAgcmVzcG9uc2U6IHtcbiAgICAgIGJvZHk6IG9wdGlvbj8uYm9keSA/PyBib2R5LFxuICAgICAgc3RhdHVzOiBvcHRpb24/LnN0YXR1cyA/PyAyMDAsXG4gICAgICBzdGF0dXNUZXh0OiBvcHRpb24/LnN0YXR1c1RleHQgPz8gXCJPS1wiLFxuICAgICAgaGVhZGVyczogb3B0aW9uPy5oZWFkZXJzXG4gICAgfSxcbiAgICBib2R5LFxuICAgIF9mbGFnOiBcImpzb25cIlxuICB9O1xufTtcblxuLy8gc3JjL2Nvb2tpZS50c1xuaW1wb3J0IHsgc3VidGxlIH0gZnJvbSBcInVuY3J5cHRvXCI7XG52YXIgYWxnb3JpdGhtID0geyBuYW1lOiBcIkhNQUNcIiwgaGFzaDogXCJTSEEtMjU2XCIgfTtcbnZhciBnZXRDcnlwdG9LZXkgPSBhc3luYyAoc2VjcmV0KSA9PiB7XG4gIGNvbnN0IHNlY3JldEJ1ZiA9IHR5cGVvZiBzZWNyZXQgPT09IFwic3RyaW5nXCIgPyBuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUoc2VjcmV0KSA6IHNlY3JldDtcbiAgcmV0dXJuIGF3YWl0IHN1YnRsZS5pbXBvcnRLZXkoXCJyYXdcIiwgc2VjcmV0QnVmLCBhbGdvcml0aG0sIGZhbHNlLCBbXCJzaWduXCIsIFwidmVyaWZ5XCJdKTtcbn07XG52YXIgbWFrZVNpZ25hdHVyZSA9IGFzeW5jICh2YWx1ZSwgc2VjcmV0KSA9PiB7XG4gIGNvbnN0IGtleSA9IGF3YWl0IGdldENyeXB0b0tleShzZWNyZXQpO1xuICBjb25zdCBzaWduYXR1cmUgPSBhd2FpdCBzdWJ0bGUuc2lnbihhbGdvcml0aG0ubmFtZSwga2V5LCBuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUodmFsdWUpKTtcbiAgcmV0dXJuIGJ0b2EoU3RyaW5nLmZyb21DaGFyQ29kZSguLi5uZXcgVWludDhBcnJheShzaWduYXR1cmUpKSk7XG59O1xudmFyIHZlcmlmeVNpZ25hdHVyZSA9IGFzeW5jIChiYXNlNjRTaWduYXR1cmUsIHZhbHVlLCBzZWNyZXQpID0+IHtcbiAgdHJ5IHtcbiAgICBjb25zdCBzaWduYXR1cmVCaW5TdHIgPSBhdG9iKGJhc2U2NFNpZ25hdHVyZSk7XG4gICAgY29uc3Qgc2lnbmF0dXJlID0gbmV3IFVpbnQ4QXJyYXkoc2lnbmF0dXJlQmluU3RyLmxlbmd0aCk7XG4gICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IHNpZ25hdHVyZUJpblN0ci5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgc2lnbmF0dXJlW2ldID0gc2lnbmF0dXJlQmluU3RyLmNoYXJDb2RlQXQoaSk7XG4gICAgfVxuICAgIHJldHVybiBhd2FpdCBzdWJ0bGUudmVyaWZ5KGFsZ29yaXRobSwgc2VjcmV0LCBzaWduYXR1cmUsIG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZSh2YWx1ZSkpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59O1xudmFyIHZhbGlkQ29va2llTmFtZVJlZ0V4ID0gL15bXFx3ISMkJSYnKi5eYHx+Ky1dKyQvO1xudmFyIHZhbGlkQ29va2llVmFsdWVSZWdFeCA9IC9eWyAhIy06PC1bXFxdLX5dKiQvO1xudmFyIHBhcnNlID0gKGNvb2tpZSwgbmFtZSkgPT4ge1xuICBjb25zdCBwYWlycyA9IGNvb2tpZS50cmltKCkuc3BsaXQoXCI7XCIpO1xuICByZXR1cm4gcGFpcnMucmVkdWNlKChwYXJzZWRDb29raWUsIHBhaXJTdHIpID0+IHtcbiAgICBwYWlyU3RyID0gcGFpclN0ci50cmltKCk7XG4gICAgY29uc3QgdmFsdWVTdGFydFBvcyA9IHBhaXJTdHIuaW5kZXhPZihcIj1cIik7XG4gICAgaWYgKHZhbHVlU3RhcnRQb3MgPT09IC0xKSB7XG4gICAgICByZXR1cm4gcGFyc2VkQ29va2llO1xuICAgIH1cbiAgICBjb25zdCBjb29raWVOYW1lID0gcGFpclN0ci5zdWJzdHJpbmcoMCwgdmFsdWVTdGFydFBvcykudHJpbSgpO1xuICAgIGlmIChuYW1lICYmIG5hbWUgIT09IGNvb2tpZU5hbWUgfHwgIXZhbGlkQ29va2llTmFtZVJlZ0V4LnRlc3QoY29va2llTmFtZSkpIHtcbiAgICAgIHJldHVybiBwYXJzZWRDb29raWU7XG4gICAgfVxuICAgIGxldCBjb29raWVWYWx1ZSA9IHBhaXJTdHIuc3Vic3RyaW5nKHZhbHVlU3RhcnRQb3MgKyAxKS50cmltKCk7XG4gICAgaWYgKGNvb2tpZVZhbHVlLnN0YXJ0c1dpdGgoJ1wiJykgJiYgY29va2llVmFsdWUuZW5kc1dpdGgoJ1wiJykpIHtcbiAgICAgIGNvb2tpZVZhbHVlID0gY29va2llVmFsdWUuc2xpY2UoMSwgLTEpO1xuICAgIH1cbiAgICBpZiAodmFsaWRDb29raWVWYWx1ZVJlZ0V4LnRlc3QoY29va2llVmFsdWUpKSB7XG4gICAgICBwYXJzZWRDb29raWVbY29va2llTmFtZV0gPSBkZWNvZGVVUklDb21wb25lbnQoY29va2llVmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gcGFyc2VkQ29va2llO1xuICB9LCB7fSk7XG59O1xudmFyIHBhcnNlU2lnbmVkID0gYXN5bmMgKGNvb2tpZSwgc2VjcmV0LCBuYW1lKSA9PiB7XG4gIGNvbnN0IHBhcnNlZENvb2tpZSA9IHt9O1xuICBjb25zdCBzZWNyZXRLZXkgPSBhd2FpdCBnZXRDcnlwdG9LZXkoc2VjcmV0KTtcbiAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMocGFyc2UoY29va2llLCBuYW1lKSkpIHtcbiAgICBjb25zdCBzaWduYXR1cmVTdGFydFBvcyA9IHZhbHVlLmxhc3RJbmRleE9mKFwiLlwiKTtcbiAgICBpZiAoc2lnbmF0dXJlU3RhcnRQb3MgPCAxKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgY29uc3Qgc2lnbmVkVmFsdWUgPSB2YWx1ZS5zdWJzdHJpbmcoMCwgc2lnbmF0dXJlU3RhcnRQb3MpO1xuICAgIGNvbnN0IHNpZ25hdHVyZSA9IHZhbHVlLnN1YnN0cmluZyhzaWduYXR1cmVTdGFydFBvcyArIDEpO1xuICAgIGlmIChzaWduYXR1cmUubGVuZ3RoICE9PSA0NCB8fCAhc2lnbmF0dXJlLmVuZHNXaXRoKFwiPVwiKSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGNvbnN0IGlzVmVyaWZpZWQgPSBhd2FpdCB2ZXJpZnlTaWduYXR1cmUoc2lnbmF0dXJlLCBzaWduZWRWYWx1ZSwgc2VjcmV0S2V5KTtcbiAgICBwYXJzZWRDb29raWVba2V5XSA9IGlzVmVyaWZpZWQgPyBzaWduZWRWYWx1ZSA6IGZhbHNlO1xuICB9XG4gIHJldHVybiBwYXJzZWRDb29raWU7XG59O1xudmFyIF9zZXJpYWxpemUgPSAobmFtZSwgdmFsdWUsIG9wdCA9IHt9KSA9PiB7XG4gIGxldCBjb29raWUgPSBgJHtuYW1lfT0ke3ZhbHVlfWA7XG4gIGlmIChuYW1lLnN0YXJ0c1dpdGgoXCJfX1NlY3VyZS1cIikgJiYgIW9wdC5zZWN1cmUpIHtcbiAgICBvcHQuc2VjdXJlID0gdHJ1ZTtcbiAgfVxuICBpZiAobmFtZS5zdGFydHNXaXRoKFwiX19Ib3N0LVwiKSkge1xuICAgIGlmICghb3B0LnNlY3VyZSkge1xuICAgICAgb3B0LnNlY3VyZSA9IHRydWU7XG4gICAgfVxuICAgIGlmIChvcHQucGF0aCAhPT0gXCIvXCIpIHtcbiAgICAgIG9wdC5wYXRoID0gXCIvXCI7XG4gICAgfVxuICAgIGlmIChvcHQuZG9tYWluKSB7XG4gICAgICBvcHQuZG9tYWluID0gdm9pZCAwO1xuICAgIH1cbiAgfVxuICBpZiAob3B0ICYmIHR5cGVvZiBvcHQubWF4QWdlID09PSBcIm51bWJlclwiICYmIG9wdC5tYXhBZ2UgPj0gMCkge1xuICAgIGlmIChvcHQubWF4QWdlID4gMzQ1NmU0KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIFwiQ29va2llcyBNYXgtQWdlIFNIT1VMRCBOT1QgYmUgZ3JlYXRlciB0aGFuIDQwMCBkYXlzICgzNDU2MDAwMCBzZWNvbmRzKSBpbiBkdXJhdGlvbi5cIlxuICAgICAgKTtcbiAgICB9XG4gICAgY29va2llICs9IGA7IE1heC1BZ2U9JHtNYXRoLmZsb29yKG9wdC5tYXhBZ2UpfWA7XG4gIH1cbiAgaWYgKG9wdC5kb21haW4gJiYgb3B0LnByZWZpeCAhPT0gXCJob3N0XCIpIHtcbiAgICBjb29raWUgKz0gYDsgRG9tYWluPSR7b3B0LmRvbWFpbn1gO1xuICB9XG4gIGlmIChvcHQucGF0aCkge1xuICAgIGNvb2tpZSArPSBgOyBQYXRoPSR7b3B0LnBhdGh9YDtcbiAgfVxuICBpZiAob3B0LmV4cGlyZXMpIHtcbiAgICBpZiAob3B0LmV4cGlyZXMuZ2V0VGltZSgpIC0gRGF0ZS5ub3coKSA+IDM0NTZlNykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBcIkNvb2tpZXMgRXhwaXJlcyBTSE9VTEQgTk9UIGJlIGdyZWF0ZXIgdGhhbiA0MDAgZGF5cyAoMzQ1NjAwMDAgc2Vjb25kcykgaW4gdGhlIGZ1dHVyZS5cIlxuICAgICAgKTtcbiAgICB9XG4gICAgY29va2llICs9IGA7IEV4cGlyZXM9JHtvcHQuZXhwaXJlcy50b1VUQ1N0cmluZygpfWA7XG4gIH1cbiAgaWYgKG9wdC5odHRwT25seSkge1xuICAgIGNvb2tpZSArPSBcIjsgSHR0cE9ubHlcIjtcbiAgfVxuICBpZiAob3B0LnNlY3VyZSkge1xuICAgIGNvb2tpZSArPSBcIjsgU2VjdXJlXCI7XG4gIH1cbiAgaWYgKG9wdC5zYW1lU2l0ZSkge1xuICAgIGNvb2tpZSArPSBgOyBTYW1lU2l0ZT0ke29wdC5zYW1lU2l0ZS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIG9wdC5zYW1lU2l0ZS5zbGljZSgxKX1gO1xuICB9XG4gIGlmIChvcHQucGFydGl0aW9uZWQpIHtcbiAgICBpZiAoIW9wdC5zZWN1cmUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlBhcnRpdGlvbmVkIENvb2tpZSBtdXN0IGhhdmUgU2VjdXJlIGF0dHJpYnV0ZXNcIik7XG4gICAgfVxuICAgIGNvb2tpZSArPSBcIjsgUGFydGl0aW9uZWRcIjtcbiAgfVxuICByZXR1cm4gY29va2llO1xufTtcbnZhciBzZXJpYWxpemUgPSAobmFtZSwgdmFsdWUsIG9wdCkgPT4ge1xuICB2YWx1ZSA9IGVuY29kZVVSSUNvbXBvbmVudCh2YWx1ZSk7XG4gIHJldHVybiBfc2VyaWFsaXplKG5hbWUsIHZhbHVlLCBvcHQpO1xufTtcbnZhciBzZXJpYWxpemVTaWduZWQgPSBhc3luYyAobmFtZSwgdmFsdWUsIHNlY3JldCwgb3B0ID0ge30pID0+IHtcbiAgY29uc3Qgc2lnbmF0dXJlID0gYXdhaXQgbWFrZVNpZ25hdHVyZSh2YWx1ZSwgc2VjcmV0KTtcbiAgdmFsdWUgPSBgJHt2YWx1ZX0uJHtzaWduYXR1cmV9YDtcbiAgdmFsdWUgPSBlbmNvZGVVUklDb21wb25lbnQodmFsdWUpO1xuICByZXR1cm4gX3NlcmlhbGl6ZShuYW1lLCB2YWx1ZSwgb3B0KTtcbn07XG52YXIgc2lnbkNvb2tpZVZhbHVlID0gYXN5bmMgKHZhbHVlLCBzZWNyZXQpID0+IHtcbiAgY29uc3Qgc2lnbmF0dXJlID0gYXdhaXQgbWFrZVNpZ25hdHVyZSh2YWx1ZSwgc2VjcmV0KTtcbiAgdmFsdWUgPSBgJHt2YWx1ZX0uJHtzaWduYXR1cmV9YDtcbiAgdmFsdWUgPSBlbmNvZGVVUklDb21wb25lbnQodmFsdWUpO1xuICByZXR1cm4gdmFsdWU7XG59O1xuXG4vLyBzcmMvY29va2llLXV0aWxzLnRzXG52YXIgZ2V0Q29va2llID0gKGNvb2tpZSwga2V5LCBwcmVmaXgpID0+IHtcbiAgaWYgKCFjb29raWUpIHtcbiAgICByZXR1cm4gdm9pZCAwO1xuICB9XG4gIGxldCBmaW5hbEtleSA9IGtleTtcbiAgaWYgKHByZWZpeCkge1xuICAgIGlmIChwcmVmaXggPT09IFwic2VjdXJlXCIpIHtcbiAgICAgIGZpbmFsS2V5ID0gXCJfX1NlY3VyZS1cIiArIGtleTtcbiAgICB9IGVsc2UgaWYgKHByZWZpeCA9PT0gXCJob3N0XCIpIHtcbiAgICAgIGZpbmFsS2V5ID0gXCJfX0hvc3QtXCIgKyBrZXk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgfVxuICB9XG4gIGNvbnN0IG9iaiA9IHBhcnNlKGNvb2tpZSwgZmluYWxLZXkpO1xuICByZXR1cm4gb2JqW2ZpbmFsS2V5XTtcbn07XG52YXIgc2V0Q29va2llID0gKGhlYWRlciwgbmFtZSwgdmFsdWUsIG9wdCkgPT4ge1xuICBjb25zdCBleGlzdGluZ0Nvb2tpZXMgPSBoZWFkZXIuZ2V0KFwiU2V0LUNvb2tpZVwiKTtcbiAgaWYgKGV4aXN0aW5nQ29va2llcykge1xuICAgIGNvbnN0IGNvb2tpZXMgPSBleGlzdGluZ0Nvb2tpZXMuc3BsaXQoXCIsIFwiKTtcbiAgICBjb25zdCB1cGRhdGVkQ29va2llcyA9IGNvb2tpZXMuZmlsdGVyKChjb29raWUyKSA9PiAhY29va2llMi5zdGFydHNXaXRoKGAke25hbWV9PWApKTtcbiAgICBoZWFkZXIuZGVsZXRlKFwiU2V0LUNvb2tpZVwiKTtcbiAgICB1cGRhdGVkQ29va2llcy5mb3JFYWNoKChjb29raWUyKSA9PiBoZWFkZXIuYXBwZW5kKFwiU2V0LUNvb2tpZVwiLCBjb29raWUyKSk7XG4gIH1cbiAgbGV0IGNvb2tpZTtcbiAgaWYgKG9wdD8ucHJlZml4ID09PSBcInNlY3VyZVwiKSB7XG4gICAgY29va2llID0gc2VyaWFsaXplKFwiX19TZWN1cmUtXCIgKyBuYW1lLCB2YWx1ZSwgeyBwYXRoOiBcIi9cIiwgLi4ub3B0LCBzZWN1cmU6IHRydWUgfSk7XG4gIH0gZWxzZSBpZiAob3B0Py5wcmVmaXggPT09IFwiaG9zdFwiKSB7XG4gICAgY29va2llID0gc2VyaWFsaXplKFwiX19Ib3N0LVwiICsgbmFtZSwgdmFsdWUsIHtcbiAgICAgIC4uLm9wdCxcbiAgICAgIHBhdGg6IFwiL1wiLFxuICAgICAgc2VjdXJlOiB0cnVlLFxuICAgICAgZG9tYWluOiB2b2lkIDBcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBjb29raWUgPSBzZXJpYWxpemUobmFtZSwgdmFsdWUsIHsgcGF0aDogXCIvXCIsIC4uLm9wdCB9KTtcbiAgfVxuICBoZWFkZXIuYXBwZW5kKFwiU2V0LUNvb2tpZVwiLCBjb29raWUpO1xufTtcbnZhciBzZXRTaWduZWRDb29raWUgPSBhc3luYyAoaGVhZGVyLCBuYW1lLCB2YWx1ZSwgc2VjcmV0LCBvcHQpID0+IHtcbiAgbGV0IGNvb2tpZTtcbiAgaWYgKG9wdD8ucHJlZml4ID09PSBcInNlY3VyZVwiKSB7XG4gICAgY29va2llID0gYXdhaXQgc2VyaWFsaXplU2lnbmVkKFwiX19TZWN1cmUtXCIgKyBuYW1lLCB2YWx1ZSwgc2VjcmV0LCB7XG4gICAgICBwYXRoOiBcIi9cIixcbiAgICAgIC4uLm9wdCxcbiAgICAgIHNlY3VyZTogdHJ1ZVxuICAgIH0pO1xuICB9IGVsc2UgaWYgKG9wdD8ucHJlZml4ID09PSBcImhvc3RcIikge1xuICAgIGNvb2tpZSA9IGF3YWl0IHNlcmlhbGl6ZVNpZ25lZChcIl9fSG9zdC1cIiArIG5hbWUsIHZhbHVlLCBzZWNyZXQsIHtcbiAgICAgIC4uLm9wdCxcbiAgICAgIHBhdGg6IFwiL1wiLFxuICAgICAgc2VjdXJlOiB0cnVlLFxuICAgICAgZG9tYWluOiB2b2lkIDBcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBjb29raWUgPSBhd2FpdCBzZXJpYWxpemVTaWduZWQobmFtZSwgdmFsdWUsIHNlY3JldCwgeyBwYXRoOiBcIi9cIiwgLi4ub3B0IH0pO1xuICB9XG4gIGhlYWRlci5hcHBlbmQoXCJTZXQtQ29va2llXCIsIGNvb2tpZSk7XG59O1xudmFyIGdldFNpZ25lZENvb2tpZSA9IGFzeW5jIChoZWFkZXIsIHNlY3JldCwga2V5LCBwcmVmaXgpID0+IHtcbiAgY29uc3QgY29va2llID0gaGVhZGVyLmdldChcImNvb2tpZVwiKTtcbiAgaWYgKCFjb29raWUpIHtcbiAgICByZXR1cm4gdm9pZCAwO1xuICB9XG4gIGxldCBmaW5hbEtleSA9IGtleTtcbiAgaWYgKHByZWZpeCkge1xuICAgIGlmIChwcmVmaXggPT09IFwic2VjdXJlXCIpIHtcbiAgICAgIGZpbmFsS2V5ID0gXCJfX1NlY3VyZS1cIiArIGtleTtcbiAgICB9IGVsc2UgaWYgKHByZWZpeCA9PT0gXCJob3N0XCIpIHtcbiAgICAgIGZpbmFsS2V5ID0gXCJfX0hvc3QtXCIgKyBrZXk7XG4gICAgfVxuICB9XG4gIGNvbnN0IG9iaiA9IGF3YWl0IHBhcnNlU2lnbmVkKGNvb2tpZSwgc2VjcmV0LCBmaW5hbEtleSk7XG4gIHJldHVybiBvYmpbZmluYWxLZXldO1xufTtcblxuLy8gc3JjL2VuZHBvaW50LnRzXG5mdW5jdGlvbiBjcmVhdGVFbmRwb2ludENyZWF0b3Iob3B0cykge1xuICByZXR1cm4gKHBhdGgsIG9wdGlvbnMsIGhhbmRsZXIpID0+IHtcbiAgICByZXR1cm4gY3JlYXRlRW5kcG9pbnQoXG4gICAgICBwYXRoLFxuICAgICAge1xuICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICB1c2U6IFsuLi5vcHRpb25zPy51c2UgfHwgW10sIC4uLm9wdHM/LnVzZSB8fCBbXV1cbiAgICAgIH0sXG4gICAgICBoYW5kbGVyXG4gICAgKTtcbiAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUVuZHBvaW50KHBhdGgsIG9wdGlvbnMsIGhhbmRsZXIpIHtcbiAgbGV0IHJlc3BvbnNlSGVhZGVyID0gbmV3IEhlYWRlcnMoKTtcbiAgY29uc3QgaGFuZGxlID0gYXN5bmMgKC4uLmN0eCkgPT4ge1xuICAgIGxldCBpbnRlcm5hbEN0eCA9IHtcbiAgICAgIHNldEhlYWRlcihrZXksIHZhbHVlKSB7XG4gICAgICAgIHJlc3BvbnNlSGVhZGVyLnNldChrZXksIHZhbHVlKTtcbiAgICAgIH0sXG4gICAgICBzZXRDb29raWUoa2V5LCB2YWx1ZSwgb3B0aW9uczIpIHtcbiAgICAgICAgc2V0Q29va2llKHJlc3BvbnNlSGVhZGVyLCBrZXksIHZhbHVlLCBvcHRpb25zMik7XG4gICAgICB9LFxuICAgICAgZ2V0Q29va2llKGtleSwgcHJlZml4KSB7XG4gICAgICAgIGNvbnN0IGhlYWRlciA9IGN0eFswXT8uaGVhZGVycztcbiAgICAgICAgY29uc3QgY29va2llSCA9IGhlYWRlcj8uZ2V0KFwiY29va2llXCIpO1xuICAgICAgICBjb25zdCBjb29raWUgPSBnZXRDb29raWUoY29va2llSCB8fCBcIlwiLCBrZXksIHByZWZpeCk7XG4gICAgICAgIHJldHVybiBjb29raWU7XG4gICAgICB9LFxuICAgICAgZ2V0U2lnbmVkQ29va2llKGtleSwgc2VjcmV0LCBwcmVmaXgpIHtcbiAgICAgICAgY29uc3QgaGVhZGVyID0gY3R4WzBdPy5oZWFkZXJzO1xuICAgICAgICBpZiAoIWhlYWRlcikge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJIZWFkZXJzIGFyZSByZXF1aXJlZFwiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjb29raWUgPSBnZXRTaWduZWRDb29raWUoaGVhZGVyLCBzZWNyZXQsIGtleSwgcHJlZml4KTtcbiAgICAgICAgcmV0dXJuIGNvb2tpZTtcbiAgICAgIH0sXG4gICAgICBhc3luYyBzZXRTaWduZWRDb29raWUoa2V5LCB2YWx1ZSwgc2VjcmV0LCBvcHRpb25zMikge1xuICAgICAgICBhd2FpdCBzZXRTaWduZWRDb29raWUocmVzcG9uc2VIZWFkZXIsIGtleSwgdmFsdWUsIHNlY3JldCwgb3B0aW9uczIpO1xuICAgICAgfSxcbiAgICAgIHJlZGlyZWN0KHVybCkge1xuICAgICAgICByZXNwb25zZUhlYWRlci5zZXQoXCJMb2NhdGlvblwiLCB1cmwpO1xuICAgICAgICByZXR1cm4gbmV3IEFQSUVycm9yKFwiRk9VTkRcIik7XG4gICAgICB9LFxuICAgICAganNvbixcbiAgICAgIGNvbnRleHQ6IGN0eFswXT8uY29udGV4dCB8fCB7fSxcbiAgICAgIF9mbGFnOiBjdHhbMF0/LmFzUmVzcG9uc2UgPyBcInJvdXRlclwiIDogY3R4WzBdPy5fZmxhZyxcbiAgICAgIHJlc3BvbnNlSGVhZGVyLFxuICAgICAgcGF0aCxcbiAgICAgIC4uLmN0eFswXSB8fCB7fVxuICAgIH07XG4gICAgaWYgKG9wdGlvbnMudXNlPy5sZW5ndGgpIHtcbiAgICAgIGxldCBtaWRkbGV3YXJlQ29udGV4dHMgPSB7fTtcbiAgICAgIGxldCBtaWRkbGV3YXJlQm9keSA9IHt9O1xuICAgICAgZm9yIChjb25zdCBtaWRkbGV3YXJlIG9mIG9wdGlvbnMudXNlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgbWlkZGxld2FyZSAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKFwiTWlkZGxld2FyZSBpcyBub3QgYSBmdW5jdGlvblwiLCB7XG4gICAgICAgICAgICBtaWRkbGV3YXJlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzID0gYXdhaXQgbWlkZGxld2FyZShpbnRlcm5hbEN0eCk7XG4gICAgICAgIGlmIChyZXMpIHtcbiAgICAgICAgICBjb25zdCBib2R5ID0gcmVzLm9wdGlvbnM/LmJvZHkgPyByZXMub3B0aW9ucy5ib2R5LnBhcnNlKGludGVybmFsQ3R4LmJvZHkpIDogdm9pZCAwO1xuICAgICAgICAgIG1pZGRsZXdhcmVDb250ZXh0cyA9IHtcbiAgICAgICAgICAgIC4uLm1pZGRsZXdhcmVDb250ZXh0cyxcbiAgICAgICAgICAgIC4uLnJlc1xuICAgICAgICAgIH07XG4gICAgICAgICAgbWlkZGxld2FyZUJvZHkgPSB7XG4gICAgICAgICAgICAuLi5taWRkbGV3YXJlQm9keSxcbiAgICAgICAgICAgIC4uLmJvZHlcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpbnRlcm5hbEN0eCA9IHtcbiAgICAgICAgLi4uaW50ZXJuYWxDdHgsXG4gICAgICAgIGJvZHk6IHtcbiAgICAgICAgICAuLi5taWRkbGV3YXJlQm9keSxcbiAgICAgICAgICAuLi5pbnRlcm5hbEN0eC5ib2R5XG4gICAgICAgIH0sXG4gICAgICAgIGNvbnRleHQ6IHtcbiAgICAgICAgICAuLi5pbnRlcm5hbEN0eC5jb250ZXh0IHx8IHt9LFxuICAgICAgICAgIC4uLm1pZGRsZXdhcmVDb250ZXh0c1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgY29uc3QgYm9keSA9IG9wdGlvbnMuYm9keSA/IG9wdGlvbnMuYm9keS5wYXJzZShpbnRlcm5hbEN0eC5ib2R5KSA6IGludGVybmFsQ3R4LmJvZHk7XG4gICAgICBpbnRlcm5hbEN0eCA9IHtcbiAgICAgICAgLi4uaW50ZXJuYWxDdHgsXG4gICAgICAgIGJvZHk6IGJvZHkgPyB7XG4gICAgICAgICAgLi4uYm9keSxcbiAgICAgICAgICAuLi5pbnRlcm5hbEN0eC5ib2R5XG4gICAgICAgIH0gOiBpbnRlcm5hbEN0eC5ib2R5XG4gICAgICB9O1xuICAgICAgaW50ZXJuYWxDdHgucXVlcnkgPSBvcHRpb25zLnF1ZXJ5ID8gb3B0aW9ucy5xdWVyeS5wYXJzZShpbnRlcm5hbEN0eC5xdWVyeSkgOiBpbnRlcm5hbEN0eC5xdWVyeTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBpZiAoZSBpbnN0YW5jZW9mIFpvZEVycm9yKSB7XG4gICAgICAgIHRocm93IG5ldyBBUElFcnJvcihcIkJBRF9SRVFVRVNUXCIsIHtcbiAgICAgICAgICBtZXNzYWdlOiBlLm1lc3NhZ2UsXG4gICAgICAgICAgZGV0YWlsczogZS5lcnJvcnNcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICB0aHJvdyBlO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5yZXF1aXJlSGVhZGVycyAmJiAhaW50ZXJuYWxDdHguaGVhZGVycykge1xuICAgICAgdGhyb3cgbmV3IEFQSUVycm9yKFwiQkFEX1JFUVVFU1RcIiwge1xuICAgICAgICBtZXNzYWdlOiBcIkhlYWRlcnMgYXJlIHJlcXVpcmVkXCJcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5yZXF1aXJlUmVxdWVzdCAmJiAhaW50ZXJuYWxDdHgucmVxdWVzdCkge1xuICAgICAgdGhyb3cgbmV3IEFQSUVycm9yKFwiQkFEX1JFUVVFU1RcIiwge1xuICAgICAgICBtZXNzYWdlOiBcIlJlcXVlc3QgaXMgcmVxdWlyZWRcIlxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChpbnRlcm5hbEN0eC5yZXF1ZXN0ICYmICFpbnRlcm5hbEN0eC5oZWFkZXJzKSB7XG4gICAgICBpbnRlcm5hbEN0eC5oZWFkZXJzID0gaW50ZXJuYWxDdHgucmVxdWVzdC5oZWFkZXJzO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgbGV0IHJlcyA9IGF3YWl0IGhhbmRsZXIoaW50ZXJuYWxDdHgpO1xuICAgICAgbGV0IGFjdHVhbFJlc3BvbnNlID0gcmVzO1xuICAgICAgaWYgKHJlcyAmJiB0eXBlb2YgcmVzID09PSBcIm9iamVjdFwiICYmIFwiX2ZsYWdcIiBpbiByZXMpIHtcbiAgICAgICAgaWYgKHJlcy5fZmxhZyA9PT0gXCJqc29uXCIgJiYgaW50ZXJuYWxDdHguX2ZsYWcgPT09IFwicm91dGVyXCIpIHtcbiAgICAgICAgICBjb25zdCBoID0gcmVzLnJlc3BvbnNlLmhlYWRlcnM7XG4gICAgICAgICAgT2JqZWN0LmtleXMoaCB8fCB7fSkuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICAgICAgICByZXNwb25zZUhlYWRlci5zZXQoa2V5LCBoW2tleV0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJlc3BvbnNlSGVhZGVyLnNldChcIkNvbnRlbnQtVHlwZVwiLCBcImFwcGxpY2F0aW9uL2pzb25cIik7XG4gICAgICAgICAgYWN0dWFsUmVzcG9uc2UgPSBuZXcgUmVzcG9uc2UoSlNPTi5zdHJpbmdpZnkocmVzLnJlc3BvbnNlLmJvZHkpLCB7XG4gICAgICAgICAgICBzdGF0dXM6IHJlcy5yZXNwb25zZS5zdGF0dXMgPz8gMjAwLFxuICAgICAgICAgICAgc3RhdHVzVGV4dDogcmVzLnJlc3BvbnNlLnN0YXR1c1RleHQsXG4gICAgICAgICAgICBoZWFkZXJzOiByZXNwb25zZUhlYWRlclxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFjdHVhbFJlc3BvbnNlID0gcmVzLmJvZHk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJlc3BvbnNlSGVhZGVyID0gbmV3IEhlYWRlcnMoKTtcbiAgICAgIHJldHVybiBhY3R1YWxSZXNwb25zZTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBpZiAoZSBpbnN0YW5jZW9mIEFQSUVycm9yKSB7XG4gICAgICAgIHJlc3BvbnNlSGVhZGVyLnNldChcIkNvbnRlbnQtVHlwZVwiLCBcImFwcGxpY2F0aW9uL2pzb25cIik7XG4gICAgICAgIGUuaGVhZGVycyA9IHJlc3BvbnNlSGVhZGVyO1xuICAgICAgICByZXNwb25zZUhlYWRlciA9IG5ldyBIZWFkZXJzKCk7XG4gICAgICAgIHRocm93IGU7XG4gICAgICB9XG4gICAgICB0aHJvdyBlO1xuICAgIH1cbiAgfTtcbiAgaGFuZGxlLnBhdGggPSBwYXRoO1xuICBoYW5kbGUub3B0aW9ucyA9IG9wdGlvbnM7XG4gIGhhbmRsZS5tZXRob2QgPSBvcHRpb25zLm1ldGhvZDtcbiAgaGFuZGxlLmhlYWRlcnMgPSByZXNwb25zZUhlYWRlcjtcbiAgcmV0dXJuIGhhbmRsZTtcbn1cblxuLy8gc3JjL3JvdXRlci50c1xuaW1wb3J0IHsgY3JlYXRlUm91dGVyIGFzIGNyZWF0ZVJvdTNSb3V0ZXIsIGFkZFJvdXRlLCBmaW5kUm91dGUsIGZpbmRBbGxSb3V0ZXMgfSBmcm9tIFwicm91M1wiO1xuXG4vLyBzcmMvdXRpbHMudHNcbmFzeW5jIGZ1bmN0aW9uIGdldEJvZHkocmVxdWVzdCkge1xuICBjb25zdCBjb250ZW50VHlwZSA9IHJlcXVlc3QuaGVhZGVycy5nZXQoXCJjb250ZW50LXR5cGVcIikgfHwgXCJcIjtcbiAgaWYgKCFyZXF1ZXN0LmJvZHkpIHtcbiAgICByZXR1cm4gdm9pZCAwO1xuICB9XG4gIGlmIChjb250ZW50VHlwZS5pbmNsdWRlcyhcImFwcGxpY2F0aW9uL2pzb25cIikpIHtcbiAgICByZXR1cm4gYXdhaXQgcmVxdWVzdC5qc29uKCk7XG4gIH1cbiAgaWYgKGNvbnRlbnRUeXBlLmluY2x1ZGVzKFwiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkXCIpKSB7XG4gICAgY29uc3QgZm9ybURhdGEgPSBhd2FpdCByZXF1ZXN0LmZvcm1EYXRhKCk7XG4gICAgY29uc3QgcmVzdWx0ID0ge307XG4gICAgZm9ybURhdGEuZm9yRWFjaCgodmFsdWUsIGtleSkgPT4ge1xuICAgICAgcmVzdWx0W2tleV0gPSB2YWx1ZS50b1N0cmluZygpO1xuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgaWYgKGNvbnRlbnRUeXBlLmluY2x1ZGVzKFwibXVsdGlwYXJ0L2Zvcm0tZGF0YVwiKSkge1xuICAgIGNvbnN0IGZvcm1EYXRhID0gYXdhaXQgcmVxdWVzdC5mb3JtRGF0YSgpO1xuICAgIGNvbnN0IHJlc3VsdCA9IHt9O1xuICAgIGZvcm1EYXRhLmZvckVhY2goKHZhbHVlLCBrZXkpID0+IHtcbiAgICAgIHJlc3VsdFtrZXldID0gdmFsdWU7XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBpZiAoY29udGVudFR5cGUuaW5jbHVkZXMoXCJ0ZXh0L3BsYWluXCIpKSB7XG4gICAgcmV0dXJuIGF3YWl0IHJlcXVlc3QudGV4dCgpO1xuICB9XG4gIGlmIChjb250ZW50VHlwZS5pbmNsdWRlcyhcImFwcGxpY2F0aW9uL29jdGV0LXN0cmVhbVwiKSkge1xuICAgIHJldHVybiBhd2FpdCByZXF1ZXN0LmFycmF5QnVmZmVyKCk7XG4gIH1cbiAgaWYgKGNvbnRlbnRUeXBlLmluY2x1ZGVzKFwiYXBwbGljYXRpb24vcGRmXCIpIHx8IGNvbnRlbnRUeXBlLmluY2x1ZGVzKFwiaW1hZ2UvXCIpIHx8IGNvbnRlbnRUeXBlLmluY2x1ZGVzKFwidmlkZW8vXCIpKSB7XG4gICAgY29uc3QgYmxvYiA9IGF3YWl0IHJlcXVlc3QuYmxvYigpO1xuICAgIHJldHVybiBibG9iO1xuICB9XG4gIGlmIChjb250ZW50VHlwZS5pbmNsdWRlcyhcImFwcGxpY2F0aW9uL3N0cmVhbVwiKSB8fCByZXF1ZXN0LmJvZHkgaW5zdGFuY2VvZiBSZWFkYWJsZVN0cmVhbSkge1xuICAgIHJldHVybiByZXF1ZXN0LmJvZHk7XG4gIH1cbiAgcmV0dXJuIGF3YWl0IHJlcXVlc3QudGV4dCgpO1xufVxuZnVuY3Rpb24gc2hvdWxkU2VyaWFsaXplKGJvZHkpIHtcbiAgcmV0dXJuIHR5cGVvZiBib2R5ID09PSBcIm9iamVjdFwiICYmIGJvZHkgIT09IG51bGwgJiYgIShib2R5IGluc3RhbmNlb2YgQmxvYikgJiYgIShib2R5IGluc3RhbmNlb2YgRm9ybURhdGEpO1xufVxudmFyIHN0YXR1c0NvZGUgPSB7XG4gIE9LOiAyMDAsXG4gIENSRUFURUQ6IDIwMSxcbiAgQUNDRVBURUQ6IDIwMixcbiAgTk9fQ09OVEVOVDogMjA0LFxuICBNVUxUSVBMRV9DSE9JQ0VTOiAzMDAsXG4gIE1PVkVEX1BFUk1BTkVOVExZOiAzMDEsXG4gIEZPVU5EOiAzMDIsXG4gIFNFRV9PVEhFUjogMzAzLFxuICBOT1RfTU9ESUZJRUQ6IDMwNCxcbiAgVEVNUE9SQVJZX1JFRElSRUNUOiAzMDcsXG4gIEJBRF9SRVFVRVNUOiA0MDAsXG4gIFVOQVVUSE9SSVpFRDogNDAxLFxuICBQQVlNRU5UX1JFUVVJUkVEOiA0MDIsXG4gIEZPUkJJRERFTjogNDAzLFxuICBOT1RfRk9VTkQ6IDQwNCxcbiAgTUVUSE9EX05PVF9BTExPV0VEOiA0MDUsXG4gIE5PVF9BQ0NFUFRBQkxFOiA0MDYsXG4gIFBST1hZX0FVVEhFTlRJQ0FUSU9OX1JFUVVJUkVEOiA0MDcsXG4gIFJFUVVFU1RfVElNRU9VVDogNDA4LFxuICBDT05GTElDVDogNDA5LFxuICBHT05FOiA0MTAsXG4gIExFTkdUSF9SRVFVSVJFRDogNDExLFxuICBQUkVDT05ESVRJT05fRkFJTEVEOiA0MTIsXG4gIFBBWUxPQURfVE9PX0xBUkdFOiA0MTMsXG4gIFVSSV9UT09fTE9ORzogNDE0LFxuICBVTlNVUFBPUlRFRF9NRURJQV9UWVBFOiA0MTUsXG4gIFJBTkdFX05PVF9TQVRJU0ZJQUJMRTogNDE2LFxuICBFWFBFQ1RBVElPTl9GQUlMRUQ6IDQxNyxcbiAgXCJJJ01fQV9URUFQT1RcIjogNDE4LFxuICBNSVNESVJFQ1RFRF9SRVFVRVNUOiA0MjEsXG4gIFVOUFJPQ0VTU0FCTEVfRU5USVRZOiA0MjIsXG4gIExPQ0tFRDogNDIzLFxuICBGQUlMRURfREVQRU5ERU5DWTogNDI0LFxuICBUT09fRUFSTFk6IDQyNSxcbiAgVVBHUkFERV9SRVFVSVJFRDogNDI2LFxuICBQUkVDT05ESVRJT05fUkVRVUlSRUQ6IDQyOCxcbiAgVE9PX01BTllfUkVRVUVTVFM6IDQyOSxcbiAgUkVRVUVTVF9IRUFERVJfRklFTERTX1RPT19MQVJHRTogNDMxLFxuICBVTkFWQUlMQUJMRV9GT1JfTEVHQUxfUkVBU09OUzogNDUxLFxuICBJTlRFUk5BTF9TRVJWRVJfRVJST1I6IDUwMCxcbiAgTk9UX0lNUExFTUVOVEVEOiA1MDEsXG4gIEJBRF9HQVRFV0FZOiA1MDIsXG4gIFNFUlZJQ0VfVU5BVkFJTEFCTEU6IDUwMyxcbiAgR0FURVdBWV9USU1FT1VUOiA1MDQsXG4gIEhUVFBfVkVSU0lPTl9OT1RfU1VQUE9SVEVEOiA1MDUsXG4gIFZBUklBTlRfQUxTT19ORUdPVElBVEVTOiA1MDYsXG4gIElOU1VGRklDSUVOVF9TVE9SQUdFOiA1MDcsXG4gIExPT1BfREVURUNURUQ6IDUwOCxcbiAgTk9UX0VYVEVOREVEOiA1MTAsXG4gIE5FVFdPUktfQVVUSEVOVElDQVRJT05fUkVRVUlSRUQ6IDUxMVxufTtcblxuLy8gc3JjL3JvdXRlci50c1xudmFyIGNyZWF0ZVJvdXRlciA9IChlbmRwb2ludHMsIGNvbmZpZykgPT4ge1xuICBjb25zdCBfZW5kcG9pbnRzID0gT2JqZWN0LnZhbHVlcyhlbmRwb2ludHMpO1xuICBjb25zdCByb3V0ZXIgPSBjcmVhdGVSb3UzUm91dGVyKCk7XG4gIGZvciAoY29uc3QgZW5kcG9pbnQgb2YgX2VuZHBvaW50cykge1xuICAgIGlmIChlbmRwb2ludC5vcHRpb25zLm1ldGFkYXRhPy5TRVJWRVJfT05MWSkgY29udGludWU7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZW5kcG9pbnQub3B0aW9ucz8ubWV0aG9kKSkge1xuICAgICAgZm9yIChjb25zdCBtZXRob2Qgb2YgZW5kcG9pbnQub3B0aW9ucy5tZXRob2QpIHtcbiAgICAgICAgYWRkUm91dGUocm91dGVyLCBtZXRob2QsIGVuZHBvaW50LnBhdGgsIGVuZHBvaW50KTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgYWRkUm91dGUocm91dGVyLCBlbmRwb2ludC5vcHRpb25zLm1ldGhvZCwgZW5kcG9pbnQucGF0aCwgZW5kcG9pbnQpO1xuICAgIH1cbiAgfVxuICBjb25zdCBtaWRkbGV3YXJlUm91dGVyID0gY3JlYXRlUm91M1JvdXRlcigpO1xuICBmb3IgKGNvbnN0IHJvdXRlIG9mIGNvbmZpZz8ucm91dGVyTWlkZGxld2FyZSB8fCBbXSkge1xuICAgIGFkZFJvdXRlKG1pZGRsZXdhcmVSb3V0ZXIsIFwiKlwiLCByb3V0ZS5wYXRoLCByb3V0ZS5taWRkbGV3YXJlKTtcbiAgfVxuICBjb25zdCBoYW5kbGVyID0gYXN5bmMgKHJlcXVlc3QpID0+IHtcbiAgICBjb25zdCB1cmwgPSBuZXcgVVJMKHJlcXVlc3QudXJsKTtcbiAgICBsZXQgcGF0aCA9IHVybC5wYXRobmFtZTtcbiAgICBpZiAoY29uZmlnPy5iYXNlUGF0aCkge1xuICAgICAgcGF0aCA9IHBhdGguc3BsaXQoY29uZmlnLmJhc2VQYXRoKVsxXTtcbiAgICB9XG4gICAgaWYgKCFwYXRoPy5sZW5ndGgpIHtcbiAgICAgIGNvbmZpZz8ub25FcnJvcj8uKG5ldyBBUElFcnJvcihcIk5PVF9GT1VORFwiKSk7XG4gICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgIGBbYmV0dGVyLWNhbGxdOiBNYWtlIHN1cmUgdGhlIFVSTCBoYXMgdGhlIGJhc2VQYXRoICgke2NvbmZpZz8uYmFzZVBhdGh9KS5gXG4gICAgICApO1xuICAgICAgcmV0dXJuIG5ldyBSZXNwb25zZShudWxsLCB7XG4gICAgICAgIHN0YXR1czogNDA0LFxuICAgICAgICBzdGF0dXNUZXh0OiBcIk5vdCBGb3VuZFwiXG4gICAgICB9KTtcbiAgICB9XG4gICAgY29uc3QgbWV0aG9kID0gcmVxdWVzdC5tZXRob2Q7XG4gICAgY29uc3Qgcm91dGUgPSBmaW5kUm91dGUocm91dGVyLCBtZXRob2QsIHBhdGgpO1xuICAgIGNvbnN0IGhhbmRsZXIyID0gcm91dGU/LmRhdGE7XG4gICAgY29uc3QgYm9keSA9IGF3YWl0IGdldEJvZHkocmVxdWVzdCk7XG4gICAgY29uc3QgaGVhZGVycyA9IHJlcXVlc3QuaGVhZGVycztcbiAgICBjb25zdCBxdWVyeSA9IE9iamVjdC5mcm9tRW50cmllcyh1cmwuc2VhcmNoUGFyYW1zKTtcbiAgICBjb25zdCByb3V0ZXJNaWRkbGV3YXJlID0gZmluZEFsbFJvdXRlcyhtaWRkbGV3YXJlUm91dGVyLCBcIipcIiwgcGF0aCk7XG4gICAgaWYgKCFoYW5kbGVyMikge1xuICAgICAgcmV0dXJuIG5ldyBSZXNwb25zZShudWxsLCB7XG4gICAgICAgIHN0YXR1czogNDA0LFxuICAgICAgICBzdGF0dXNUZXh0OiBcIk5vdCBGb3VuZFwiXG4gICAgICB9KTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIGxldCBtaWRkbGV3YXJlQ29udGV4dCA9IHt9O1xuICAgICAgaWYgKHJvdXRlck1pZGRsZXdhcmU/Lmxlbmd0aCkge1xuICAgICAgICBmb3IgKGNvbnN0IHJvdXRlMiBvZiByb3V0ZXJNaWRkbGV3YXJlKSB7XG4gICAgICAgICAgY29uc3QgbWlkZGxld2FyZSA9IHJvdXRlMi5kYXRhO1xuICAgICAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IG1pZGRsZXdhcmUoe1xuICAgICAgICAgICAgcGF0aCxcbiAgICAgICAgICAgIG1ldGhvZCxcbiAgICAgICAgICAgIGhlYWRlcnMsXG4gICAgICAgICAgICBwYXJhbXM6IHJvdXRlMj8ucGFyYW1zLFxuICAgICAgICAgICAgcmVxdWVzdCxcbiAgICAgICAgICAgIGJvZHksXG4gICAgICAgICAgICBxdWVyeSxcbiAgICAgICAgICAgIGNvbnRleHQ6IHtcbiAgICAgICAgICAgICAgLi4uY29uZmlnPy5leHRyYUNvbnRleHRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICBpZiAocmVzIGluc3RhbmNlb2YgUmVzcG9uc2UpIHtcbiAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChyZXM/Ll9mbGFnID09PSBcImpzb25cIikge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBSZXNwb25zZShKU09OLnN0cmluZ2lmeShyZXMpLCB7XG4gICAgICAgICAgICAgIGhlYWRlcnM6IHJlcy5oZWFkZXJzXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHJlcykge1xuICAgICAgICAgICAgbWlkZGxld2FyZUNvbnRleHQgPSB7XG4gICAgICAgICAgICAgIC4uLnJlcyxcbiAgICAgICAgICAgICAgLi4ubWlkZGxld2FyZUNvbnRleHRcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjb25zdCBoYW5kbGVyUmVzID0gYXdhaXQgaGFuZGxlcjIoe1xuICAgICAgICBwYXRoLFxuICAgICAgICBtZXRob2QsXG4gICAgICAgIGhlYWRlcnMsXG4gICAgICAgIHBhcmFtczogcm91dGU/LnBhcmFtcyxcbiAgICAgICAgcmVxdWVzdCxcbiAgICAgICAgYm9keSxcbiAgICAgICAgcXVlcnksXG4gICAgICAgIF9mbGFnOiBcInJvdXRlclwiLFxuICAgICAgICBjb250ZXh0OiB7XG4gICAgICAgICAgLi4ubWlkZGxld2FyZUNvbnRleHQsXG4gICAgICAgICAgLi4uY29uZmlnPy5leHRyYUNvbnRleHRcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBpZiAoaGFuZGxlclJlcyBpbnN0YW5jZW9mIFJlc3BvbnNlKSB7XG4gICAgICAgIHJldHVybiBoYW5kbGVyUmVzO1xuICAgICAgfVxuICAgICAgY29uc3QgcmVzQm9keSA9IHNob3VsZFNlcmlhbGl6ZShoYW5kbGVyUmVzKSA/IEpTT04uc3RyaW5naWZ5KGhhbmRsZXJSZXMpIDogaGFuZGxlclJlcztcbiAgICAgIHJldHVybiBuZXcgUmVzcG9uc2UocmVzQm9keSwge1xuICAgICAgICBoZWFkZXJzOiBoYW5kbGVyMi5oZWFkZXJzXG4gICAgICB9KTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBpZiAoY29uZmlnPy5vbkVycm9yKSB7XG4gICAgICAgIGNvbnN0IG9uRXJyb3JSZXMgPSBhd2FpdCBjb25maWcub25FcnJvcihlKTtcbiAgICAgICAgaWYgKG9uRXJyb3JSZXMgaW5zdGFuY2VvZiBSZXNwb25zZSkge1xuICAgICAgICAgIHJldHVybiBvbkVycm9yUmVzO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoZSBpbnN0YW5jZW9mIEFQSUVycm9yKSB7XG4gICAgICAgIHJldHVybiBuZXcgUmVzcG9uc2UoZS5ib2R5ID8gSlNPTi5zdHJpbmdpZnkoZS5ib2R5KSA6IG51bGwsIHtcbiAgICAgICAgICBzdGF0dXM6IHN0YXR1c0NvZGVbZS5zdGF0dXNdLFxuICAgICAgICAgIHN0YXR1c1RleHQ6IGUuc3RhdHVzLFxuICAgICAgICAgIGhlYWRlcnM6IGUuaGVhZGVyc1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGlmIChjb25maWc/LnRocm93RXJyb3IpIHtcbiAgICAgICAgdGhyb3cgZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXcgUmVzcG9uc2UobnVsbCwge1xuICAgICAgICBzdGF0dXM6IDUwMCxcbiAgICAgICAgc3RhdHVzVGV4dDogXCJJbnRlcm5hbCBTZXJ2ZXIgRXJyb3JcIlxuICAgICAgfSk7XG4gICAgfVxuICB9O1xuICByZXR1cm4ge1xuICAgIGhhbmRsZXI6IGFzeW5jIChyZXF1ZXN0KSA9PiB7XG4gICAgICBjb25zdCBvblJlcSA9IGF3YWl0IGNvbmZpZz8ub25SZXF1ZXN0Py4ocmVxdWVzdCk7XG4gICAgICBpZiAob25SZXEgaW5zdGFuY2VvZiBSZXNwb25zZSkge1xuICAgICAgICByZXR1cm4gb25SZXE7XG4gICAgICB9XG4gICAgICBjb25zdCByZXEgPSBvblJlcSBpbnN0YW5jZW9mIFJlcXVlc3QgPyBvblJlcSA6IHJlcXVlc3Q7XG4gICAgICBjb25zdCByZXMgPSBhd2FpdCBoYW5kbGVyKHJlcSk7XG4gICAgICBjb25zdCBvblJlcyA9IGF3YWl0IGNvbmZpZz8ub25SZXNwb25zZT8uKHJlcyk7XG4gICAgICBpZiAob25SZXMgaW5zdGFuY2VvZiBSZXNwb25zZSkge1xuICAgICAgICByZXR1cm4gb25SZXM7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzO1xuICAgIH0sXG4gICAgZW5kcG9pbnRzXG4gIH07XG59O1xuXG4vLyBzcmMvbWlkZGxld2FyZS50c1xuZnVuY3Rpb24gY3JlYXRlTWlkZGxld2FyZShvcHRpb25zT3JIYW5kbGVyLCBoYW5kbGVyKSB7XG4gIGlmICh0eXBlb2Ygb3B0aW9uc09ySGFuZGxlciA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUVuZHBvaW50KFxuICAgICAgXCIqXCIsXG4gICAgICB7XG4gICAgICAgIG1ldGhvZDogXCIqXCJcbiAgICAgIH0sXG4gICAgICBvcHRpb25zT3JIYW5kbGVyXG4gICAgKTtcbiAgfVxuICBpZiAoIWhhbmRsZXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJNaWRkbGV3YXJlIGhhbmRsZXIgaXMgcmVxdWlyZWRcIik7XG4gIH1cbiAgY29uc3QgZW5kcG9pbnQgPSBjcmVhdGVFbmRwb2ludChcbiAgICBcIipcIixcbiAgICB7XG4gICAgICAuLi5vcHRpb25zT3JIYW5kbGVyLFxuICAgICAgbWV0aG9kOiBcIipcIlxuICAgIH0sXG4gICAgaGFuZGxlclxuICApO1xuICByZXR1cm4gZW5kcG9pbnQ7XG59XG52YXIgY3JlYXRlTWlkZGxld2FyZUNyZWF0b3IgPSAob3B0cykgPT4ge1xuICBmdW5jdGlvbiBmbihvcHRpb25zT3JIYW5kbGVyLCBoYW5kbGVyKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zT3JIYW5kbGVyID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIHJldHVybiBjcmVhdGVFbmRwb2ludChcbiAgICAgICAgXCIqXCIsXG4gICAgICAgIHtcbiAgICAgICAgICBtZXRob2Q6IFwiKlwiXG4gICAgICAgIH0sXG4gICAgICAgIG9wdGlvbnNPckhhbmRsZXJcbiAgICAgICk7XG4gICAgfVxuICAgIGlmICghaGFuZGxlcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTWlkZGxld2FyZSBoYW5kbGVyIGlzIHJlcXVpcmVkXCIpO1xuICAgIH1cbiAgICBjb25zdCBlbmRwb2ludCA9IGNyZWF0ZUVuZHBvaW50KFxuICAgICAgXCIqXCIsXG4gICAgICB7XG4gICAgICAgIC4uLm9wdGlvbnNPckhhbmRsZXIsXG4gICAgICAgIG1ldGhvZDogXCIqXCJcbiAgICAgIH0sXG4gICAgICBoYW5kbGVyXG4gICAgKTtcbiAgICByZXR1cm4gZW5kcG9pbnQ7XG4gIH1cbiAgcmV0dXJuIGZuO1xufTtcblxuLy8gc3JjL3R5cGVzLnRzXG5pbXBvcnQgXCJ6b2RcIjtcblxuLy8gc3JjL2FkYXB0ZXIvcmVxdWVzdC50c1xuaW1wb3J0ICogYXMgc2V0X2Nvb2tpZV9wYXJzZXIgZnJvbSBcInNldC1jb29raWUtcGFyc2VyXCI7XG5mdW5jdGlvbiBnZXRfcmF3X2JvZHkocmVxLCBib2R5X3NpemVfbGltaXQpIHtcbiAgY29uc3QgaCA9IHJlcS5oZWFkZXJzO1xuICBpZiAoIWhbXCJjb250ZW50LXR5cGVcIl0pIHJldHVybiBudWxsO1xuICBjb25zdCBjb250ZW50X2xlbmd0aCA9IE51bWJlcihoW1wiY29udGVudC1sZW5ndGhcIl0pO1xuICBpZiAocmVxLmh0dHBWZXJzaW9uTWFqb3IgPT09IDEgJiYgaXNOYU4oY29udGVudF9sZW5ndGgpICYmIGhbXCJ0cmFuc2Zlci1lbmNvZGluZ1wiXSA9PSBudWxsIHx8IGNvbnRlbnRfbGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgbGV0IGxlbmd0aCA9IGNvbnRlbnRfbGVuZ3RoO1xuICBpZiAoYm9keV9zaXplX2xpbWl0KSB7XG4gICAgaWYgKCFsZW5ndGgpIHtcbiAgICAgIGxlbmd0aCA9IGJvZHlfc2l6ZV9saW1pdDtcbiAgICB9IGVsc2UgaWYgKGxlbmd0aCA+IGJvZHlfc2l6ZV9saW1pdCkge1xuICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgIGBSZWNlaXZlZCBjb250ZW50LWxlbmd0aCBvZiAke2xlbmd0aH0sIGJ1dCBvbmx5IGFjY2VwdCB1cCB0byAke2JvZHlfc2l6ZV9saW1pdH0gYnl0ZXMuYFxuICAgICAgKTtcbiAgICB9XG4gIH1cbiAgaWYgKHJlcS5kZXN0cm95ZWQpIHtcbiAgICBjb25zdCByZWFkYWJsZSA9IG5ldyBSZWFkYWJsZVN0cmVhbSgpO1xuICAgIHJlYWRhYmxlLmNhbmNlbCgpO1xuICAgIHJldHVybiByZWFkYWJsZTtcbiAgfVxuICBsZXQgc2l6ZSA9IDA7XG4gIGxldCBjYW5jZWxsZWQgPSBmYWxzZTtcbiAgcmV0dXJuIG5ldyBSZWFkYWJsZVN0cmVhbSh7XG4gICAgc3RhcnQoY29udHJvbGxlcikge1xuICAgICAgcmVxLm9uKFwiZXJyb3JcIiwgKGVycm9yKSA9PiB7XG4gICAgICAgIGNhbmNlbGxlZCA9IHRydWU7XG4gICAgICAgIGNvbnRyb2xsZXIuZXJyb3IoZXJyb3IpO1xuICAgICAgfSk7XG4gICAgICByZXEub24oXCJlbmRcIiwgKCkgPT4ge1xuICAgICAgICBpZiAoY2FuY2VsbGVkKSByZXR1cm47XG4gICAgICAgIGNvbnRyb2xsZXIuY2xvc2UoKTtcbiAgICAgIH0pO1xuICAgICAgcmVxLm9uKFwiZGF0YVwiLCAoY2h1bmspID0+IHtcbiAgICAgICAgaWYgKGNhbmNlbGxlZCkgcmV0dXJuO1xuICAgICAgICBzaXplICs9IGNodW5rLmxlbmd0aDtcbiAgICAgICAgaWYgKHNpemUgPiBsZW5ndGgpIHtcbiAgICAgICAgICBjYW5jZWxsZWQgPSB0cnVlO1xuICAgICAgICAgIGNvbnRyb2xsZXIuZXJyb3IoXG4gICAgICAgICAgICBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgIGByZXF1ZXN0IGJvZHkgc2l6ZSBleGNlZWRlZCAke2NvbnRlbnRfbGVuZ3RoID8gXCInY29udGVudC1sZW5ndGgnXCIgOiBcIkJPRFlfU0laRV9MSU1JVFwifSBvZiAke2xlbmd0aH1gXG4gICAgICAgICAgICApXG4gICAgICAgICAgKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKGNodW5rKTtcbiAgICAgICAgaWYgKGNvbnRyb2xsZXIuZGVzaXJlZFNpemUgPT09IG51bGwgfHwgY29udHJvbGxlci5kZXNpcmVkU2l6ZSA8PSAwKSB7XG4gICAgICAgICAgcmVxLnBhdXNlKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0sXG4gICAgcHVsbCgpIHtcbiAgICAgIHJlcS5yZXN1bWUoKTtcbiAgICB9LFxuICAgIGNhbmNlbChyZWFzb24pIHtcbiAgICAgIGNhbmNlbGxlZCA9IHRydWU7XG4gICAgICByZXEuZGVzdHJveShyZWFzb24pO1xuICAgIH1cbiAgfSk7XG59XG5mdW5jdGlvbiBnZXRSZXF1ZXN0KHtcbiAgcmVxdWVzdCxcbiAgYmFzZSxcbiAgYm9keVNpemVMaW1pdFxufSkge1xuICByZXR1cm4gbmV3IFJlcXVlc3QoYmFzZSArIHJlcXVlc3QudXJsLCB7XG4gICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgIGR1cGxleDogXCJoYWxmXCIsXG4gICAgbWV0aG9kOiByZXF1ZXN0Lm1ldGhvZCxcbiAgICBib2R5OiBnZXRfcmF3X2JvZHkocmVxdWVzdCwgYm9keVNpemVMaW1pdCksXG4gICAgaGVhZGVyczogcmVxdWVzdC5oZWFkZXJzXG4gIH0pO1xufVxuYXN5bmMgZnVuY3Rpb24gc2V0UmVzcG9uc2UocmVzLCByZXNwb25zZSkge1xuICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiByZXNwb25zZS5oZWFkZXJzKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJlcy5zZXRIZWFkZXIoXG4gICAgICAgIGtleSxcbiAgICAgICAga2V5ID09PSBcInNldC1jb29raWVcIiA/IHNldF9jb29raWVfcGFyc2VyLnNwbGl0Q29va2llc1N0cmluZyhyZXNwb25zZS5oZWFkZXJzLmdldChrZXkpKSA6IHZhbHVlXG4gICAgICApO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICByZXMuZ2V0SGVhZGVyTmFtZXMoKS5mb3JFYWNoKChuYW1lKSA9PiByZXMucmVtb3ZlSGVhZGVyKG5hbWUpKTtcbiAgICAgIHJlcy53cml0ZUhlYWQoNTAwKS5lbmQoU3RyaW5nKGVycm9yKSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9XG4gIHJlcy53cml0ZUhlYWQocmVzcG9uc2Uuc3RhdHVzKTtcbiAgaWYgKCFyZXNwb25zZS5ib2R5KSB7XG4gICAgcmVzLmVuZCgpO1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAocmVzcG9uc2UuYm9keS5sb2NrZWQpIHtcbiAgICByZXMuZW5kKFxuICAgICAgXCJGYXRhbCBlcnJvcjogUmVzcG9uc2UgYm9keSBpcyBsb2NrZWQuIFRoaXMgY2FuIGhhcHBlbiB3aGVuIHRoZSByZXNwb25zZSB3YXMgYWxyZWFkeSByZWFkIChmb3IgZXhhbXBsZSB0aHJvdWdoICdyZXNwb25zZS5qc29uKCknIG9yICdyZXNwb25zZS50ZXh0KCknKS5cIlxuICAgICk7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IHJlYWRlciA9IHJlc3BvbnNlLmJvZHkuZ2V0UmVhZGVyKCk7XG4gIGlmIChyZXMuZGVzdHJveWVkKSB7XG4gICAgcmVhZGVyLmNhbmNlbCgpO1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBjYW5jZWwgPSAoZXJyb3IpID0+IHtcbiAgICByZXMub2ZmKFwiY2xvc2VcIiwgY2FuY2VsKTtcbiAgICByZXMub2ZmKFwiZXJyb3JcIiwgY2FuY2VsKTtcbiAgICByZWFkZXIuY2FuY2VsKGVycm9yKS5jYXRjaCgoKSA9PiB7XG4gICAgfSk7XG4gICAgaWYgKGVycm9yKSByZXMuZGVzdHJveShlcnJvcik7XG4gIH07XG4gIHJlcy5vbihcImNsb3NlXCIsIGNhbmNlbCk7XG4gIHJlcy5vbihcImVycm9yXCIsIGNhbmNlbCk7XG4gIG5leHQoKTtcbiAgYXN5bmMgZnVuY3Rpb24gbmV4dCgpIHtcbiAgICB0cnkge1xuICAgICAgZm9yICg7IDsgKSB7XG4gICAgICAgIGNvbnN0IHsgZG9uZSwgdmFsdWUgfSA9IGF3YWl0IHJlYWRlci5yZWFkKCk7XG4gICAgICAgIGlmIChkb25lKSBicmVhaztcbiAgICAgICAgaWYgKCFyZXMud3JpdGUodmFsdWUpKSB7XG4gICAgICAgICAgcmVzLm9uY2UoXCJkcmFpblwiLCBuZXh0KTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJlcy5lbmQoKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY2FuY2VsKGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvciA6IG5ldyBFcnJvcihTdHJpbmcoZXJyb3IpKSk7XG4gICAgfVxuICB9XG59XG5cbi8vIHNyYy9hZGFwdGVyL25vZGUudHNcbmZ1bmN0aW9uIHRvTm9kZUhhbmRsZXIoaGFuZGxlcikge1xuICByZXR1cm4gYXN5bmMgKHJlcSwgcmVzKSA9PiB7XG4gICAgY29uc3QgcHJvdG9jb2wgPSByZXEuaGVhZGVyc1tcIngtZm9yd2FyZGVkLXByb3RvXCJdIHx8IChyZXEuc29ja2V0LmVuY3J5cHRlZCA/IFwiaHR0cHNcIiA6IFwiaHR0cFwiKTtcbiAgICBjb25zdCBiYXNlID0gYCR7cHJvdG9jb2x9Oi8vJHtyZXEuaGVhZGVyc1tcIjphdXRob3JpdHlcIl0gfHwgcmVxLmhlYWRlcnMuaG9zdH1gO1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgaGFuZGxlcihnZXRSZXF1ZXN0KHsgYmFzZSwgcmVxdWVzdDogcmVxIH0pKTtcbiAgICBzZXRSZXNwb25zZShyZXMsIHJlc3BvbnNlKTtcbiAgfTtcbn1cbmV4cG9ydCB7XG4gIEFQSUVycm9yLFxuICBjcmVhdGVFbmRwb2ludCxcbiAgY3JlYXRlRW5kcG9pbnRDcmVhdG9yLFxuICBjcmVhdGVNaWRkbGV3YXJlLFxuICBjcmVhdGVNaWRkbGV3YXJlQ3JlYXRvcixcbiAgY3JlYXRlUm91dGVyLFxuICBnZXRCb2R5LFxuICBnZXRDb29raWUsXG4gIGdldFJlcXVlc3QsXG4gIGdldFNpZ25lZENvb2tpZSxcbiAganNvbixcbiAgcGFyc2UsXG4gIHBhcnNlU2lnbmVkLFxuICBzZXJpYWxpemUsXG4gIHNlcmlhbGl6ZVNpZ25lZCxcbiAgc2V0Q29va2llLFxuICBzZXRSZXNwb25zZSxcbiAgc2V0U2lnbmVkQ29va2llLFxuICBzaG91bGRTZXJpYWxpemUsXG4gIHNpZ25Db29raWVWYWx1ZSxcbiAgc3RhdHVzQ29kZSxcbiAgdG9Ob2RlSGFuZGxlclxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../../../node_modules/better-call/dist/index.js\n");

/***/ })

};
;